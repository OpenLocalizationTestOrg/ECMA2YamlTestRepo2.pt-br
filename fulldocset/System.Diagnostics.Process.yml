### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Fornece acesso a processos locais e remotos e permite iniciar e parar os processos de sistema local.       Para procurar o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.Process&quot;> </xref> classe."
  remarks: "Se você não especificar o <xref:System.Diagnostics.Process.MachineName%2A>propriedade, o padrão é o computador local, (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Você tem duas opções para associar um novo <xref:System.Diagnostics.Process>componente com um processo no computador.</xref:System.Diagnostics.Process> A primeira opção é usar o construtor para criar o <xref:System.Diagnostics.Process>componente, definir os membros apropriados a <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chame <xref:System.Diagnostics.Process.Start%2A>para associar o <xref:System.Diagnostics.Process>com um novo processo de sistema.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> A segunda opção é associar o <xref:System.Diagnostics.Process>com um processo de sistema em execução usando <xref:System.Diagnostics.Process.GetProcessById%2A>ou uma da <xref:System.Diagnostics.Process.GetProcesses%2A>valores de retorno.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Se você usar um `static` de sobrecarga do <xref:System.Diagnostics.Process.Start%2A>método para iniciar um novo processo do sistema, o método cria um novo <xref:System.Diagnostics.Process>componente e a associa o processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Quando o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>propriedade é definida como seu valor padrão, `true`, você pode iniciar aplicativos e documentos de maneira semelhante ao uso de `Run` caixa de diálogo do Windows `Start` menu.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>é `false`, você pode iniciar somente executáveis.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Qualquer arquivo executável que você pode chamar a partir da linha de comando pode ser iniciado em uma das duas maneiras: definindo os membros apropriados do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar o <xref:System.Diagnostics.Process.Start%2A>método sem parâmetros ou passando o parâmetro apropriado para o `static` <xref:System.Diagnostics.Process.Start%2A>membro.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Você pode criar um <xref:System.Diagnostics.Process>componente usando o construtor, um estático <xref:System.Diagnostics.Process.Start%2A>sobrecargas ou qualquer o <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>métodos.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Depois de você ter feito isso, você tem uma exibição para o processo associado. Isso não é uma exibição dinâmica que se atualiza automaticamente quando as propriedades de processo foram alteradas na memória. Em vez disso, você deve chamar <xref:System.Diagnostics.Process.Refresh%2A>para o componente atualizar o <xref:System.Diagnostics.Process>informações de propriedade em seu aplicativo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a prioridade básica do processo associado."
  remarks: "BasePriority do processo é a prioridade inicial de threads criados dentro do processo associado. Você pode exibir informações sobre a prioridade base por meio de contador Base de prioridade do Monitor do sistema.       Com base no tempo decorrida ou outras aumenta, o sistema operacional pode alterar a prioridade base quando um processo deve ser colocado antes dos outros.       A propriedade BasePriority lhe permite exibir inicial prioridade atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o BasePriority para definir a prioridade do processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A>propriedade.</xref:System.Diagnostics.Process.PriorityClass%2A> O BasePriority pode ser visto usando o Monitor do sistema, enquanto o <xref:System.Diagnostics.Process.PriorityClass%2A>não é.</xref:System.Diagnostics.Process.PriorityClass%2A> Ambos o BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>podem ser exibidas programaticamente.</xref:System.Diagnostics.Process.PriorityClass%2A> A tabela a seguir mostra a relação entre os valores de BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>valores.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | Classe de prioridade |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "A prioridade base, que é computada a partir de <xref:System.Diagnostics.Process.PriorityClass*>do processo associado.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo foi encerrado.       - ou - o processo não foi iniciado, portanto, não há nenhuma ID de processo."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia as operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardError*>fluxo do aplicativo.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "O <xref:System.Diagnostics.Process.StandardError%2A>fluxo pode ser lido de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardError%2A> Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>executar operações de leitura síncronas no fluxo de saída de erro do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process>grava seu <xref:System.Diagnostics.Process.StandardError%2A>fluxo ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Por outro lado, BeginErrorReadLine inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Esse método permite que o manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.       Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>para um <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived>evento.</xref:System.Diagnostics.Process.ErrorDataReceived> O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>assinatura do delegado.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Iniciar <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chamar BeginErrorReadLine para <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process>escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar BeginErrorReadLine novamente para retomar as operações de leitura assíncronas.      > [!NOTE] > Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não execute BeginErrorReadLine com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no <xref:System.Diagnostics.Process.StandardError%2A>fluxo, ou vice-versa.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar BeginErrorReadLine e, em seguida, chamar <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia as operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput*>fluxo do aplicativo.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "O <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo pode ser lido de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardOutput%2A> Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>executar operações de leitura síncronas no fluxo de saída do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process>grava seu <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Por outro lado, BeginOutputReadLine inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.       Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>para um <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived>evento.</xref:System.Diagnostics.Process.OutputDataReceived> O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>assinatura do delegado.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Iniciar <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chamar BeginOutputReadLine para <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process>escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar BeginOutputReadLine novamente para retomar as operações de leitura assíncronas.      > [!NOTE] > Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não execute BeginOutputReadLine com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo, ou vice-versa.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar BeginOutputReadLine e, em seguida, chamar <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cancela o assíncrono da operação de leitura sobre o redirecionamento <xref:System.Diagnostics.Process.StandardError*>fluxo de um aplicativo.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead termina a operação de leitura assíncrona.       Depois de cancelar, você pode retomar a operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>novamente.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       Quando você chama CancelErrorRead, em andamento todas as operações de leitura de para <xref:System.Diagnostics.Process.StandardError%2A>são concluídas e, em seguida, o manipulador de eventos está desabilitado.</xref:System.Diagnostics.Process.StandardError%2A> Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardError%2A>é salvo em um buffer.</xref:System.Diagnostics.Process.StandardError%2A> Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardError%2A>e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>para retomar as operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Não siga CancelErrorRead com uma chamada para os métodos de leitura síncronas de <xref:System.Diagnostics.Process.StandardError%2A>como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref:System.Diagnostics.Process.StandardError*>fluxo não está habilitado para operações de leitura assíncronas.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cancela o assíncrono da operação de leitura sobre o redirecionamento <xref:System.Diagnostics.Process.StandardOutput*>fluxo de um aplicativo.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead termina a operação de leitura assíncrona.       Depois de cancelar, você pode retomar operações de leitura assíncronas chamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>novamente.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       Quando você chama CancelOutputRead, em andamento todas as operações de leitura de para <xref:System.Diagnostics.Process.StandardOutput%2A>são concluídas e, em seguida, o manipulador de eventos está desabilitado.</xref:System.Diagnostics.Process.StandardOutput%2A> Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardOutput%2A>é salvo em um buffer.</xref:System.Diagnostics.Process.StandardOutput%2A> Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardOutput%2A>e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>para retomar as operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Não siga CancelOutputRead com uma chamada para os métodos de leitura síncronas de <xref:System.Diagnostics.Process.StandardOutput%2A>como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref:System.Diagnostics.Process.StandardOutput*>fluxo não está habilitado para operações de leitura assíncronas.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Libera todos os recursos que estão associados este componente."
  remarks: "O método Close faz com que o processo de interromper a espera de saída se ele estava aguardando, fecha o identificador de processo e limpa propriedades específicas do processo. Fechar não fecha o gravadores e leitores de saída, de entrada e de erro padrão caso eles estão sendo referenciados externamente.      > [!NOTE] > O <xref:System.Diagnostics.Process.Dispose%2A>Fechar chamadas de método.</xref:System.Diagnostics.Process.Dispose%2A> Colocando o <xref:System.Diagnostics.Process>do objeto em um `using` bloco libera recursos sem a necessidade de chamar Close.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Fecha um processo que tenha uma interface de usuário, enviando uma mensagem de fechamento para a janela principal."
  remarks: "Quando um processo está em execução, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamar CloseMainWindow envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo. A solicitação para sair do processo chamando CloseMainWindow não força o aplicativo para sair. O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A>método.</xref:System.Diagnostics.Process.Kill%2A> O comportamento de CloseMainWindow é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.       Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>faz com que um encerramento anormal de processo e deve ser usado somente quando necessário.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow permite um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se CloseMainWindow falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A>para encerrar o processo.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>é a única maneira de encerrar os processos que não têm interfaces gráficas.</xref:System.Diagnostics.Process.Kill%2A>       Você pode chamar <xref:System.Diagnostics.Process.Kill%2A>e CloseMainWindow somente para processos em execução no computador local.</xref:System.Diagnostics.Process.Kill%2A> Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a mensagem de fechamento foi enviada com êxito; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o processo associado não tem uma janela principal ou se a janela principal é desabilitada (por exemplo, se uma caixa de diálogo modal está sendo exibida)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo já foi encerrado.       - ou - nenhum processo está associado a essa <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Libere todos os recursos usados por esse processo."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define se o <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> deve ser gerado quando o processo é encerrado."
  remarks: "A propriedade EnableRaisingEvents indica se o componente deve ser notificado quando o sistema operacional foi fechado por um processo. A propriedade EnableRaisingEvents é usada no processamento assíncrono para notificar o aplicativo que um processo foi encerrado. Para forçar o aplicativo de forma síncrona espera para um evento de saída (que interrompe o processamento do aplicativo até que o evento de saída ocorreu), use o <xref:System.Diagnostics.Process.WaitForExit%2A>método.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Se você estiver usando o Visual Studio e clique duas vezes em um <xref:System.Diagnostics.Process>componente no seu projeto, um <xref:System.Diagnostics.Process.Exited>delegado do evento e o manipulador de eventos são gerados automaticamente.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Código adicional define a propriedade EnableRaisingEvents `false`. Você deve alterar essa propriedade como `true` para o manipulador de eventos a ser executado quando o processo associado for encerrado.       Quando um processo associado foi encerrado após sendo desligado pelo sistema operacional ou por meio de um encerramento normal ou anormal, o sistema operacional notifica cada componente do processo ao qual o processo foi associado, como o valor do componente EnableRaisingEvents é `true`. Se um componente iniciado o processo, o componente pode acessar as informações administrativas para o processo associado, que ainda está sendo armazenado pelo sistema operacional. Essas informações incluem o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       Depois que o processo associado for encerrado, o <xref:System.Diagnostics.Process.Handle%2A>do componente não aponta para um recurso existente do processo.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, ele pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema operacional está ciente de que há identificadores encerrados processos que não foram liberados por <xref:System.Diagnostics.Process>componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Há um custo associado observando um processo sair. Se for EnableRaisingEvents `true`, o <xref:System.Diagnostics.Process.Exited>evento é gerado quando o processo associado será encerrado.</xref:System.Diagnostics.Process.Exited> Os procedimentos que você especificou para o <xref:System.Diagnostics.Process.Exited>eventos que são executados nesse horário.</xref:System.Diagnostics.Process.Exited>       Às vezes, seu aplicativo inicia um processo, mas não precisa ser notificado sobre seu fechamento. Por exemplo, seu aplicativo pode iniciar o bloco de notas para permitir que o usuário efetue a edição de texto, mas nenhuma outra fazer uso do aplicativo bloco de notas. Você pode optar por não ser notificado quando o processo foi encerrado, porque ele não é relevante para a operação contínua de seu aplicativo. Definindo EnableRaisingEvents como `false` salva os recursos do sistema."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> deve ser gerado quando o processo associado foi finalizado (por meio de uma saída ou uma chamada para <xref:System.Diagnostics.Process.Kill*>); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Coloca um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente no estado para interagir com o sistema operacional processos executados em um modo especial, permitindo que a propriedade nativo <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> no thread atual."
  remarks: "Alguns processos do sistema operacional executado em um modo especial. Não é possível tentar ler as propriedades de ou anexar a esses processos, a menos que você chamou EnterDebugMode no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A>quando você não precisa mais acesso a esses processos que são executados em modo especial.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando um aplicativo grava seu redirecionado <xref:System.Diagnostics.Process.StandardError*>stream.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "O evento ErrorDataReceived indica que o processo associado foi gravados seu redirecionado <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       O evento ocorre apenas durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardError%2A>fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o evento ErrorDataReceived e chame <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Depois disso, os sinais de evento ErrorDataReceived cada vez que o processo grava uma linha no redirecionamento <xref:System.Diagnostics.Process.StandardError%2A>fluxo, até que o processo foi encerrado ou chamadas <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para garantir que o buffer de saída foi liberado.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o valor que o processo associado especificado quando ele terminar."
  remarks: "Use ExitCode para obter o status que o processo de sistema retornado quando ele foi encerrado. Você pode usar o código de saída muito, como um número inteiro retornar o valor de uma `main()` procedimento.       O valor de ExitCode para um processo reflete a convenção específica implementada pelo desenvolvedor do aplicativo para que o processo. Se você usar o valor de código de saída para tomar decisões em seu código, certifique-se de que você sabe que a convenção de código de saída usada pelo processo de aplicativo.       Os desenvolvedores geralmente indicam uma saída com êxito por um valor ExitCode zero e designar erros por valores diferentes de zero e o método de chamada pode usar para identificar a causa do encerramento de um processo anormal. Não é necessário seguir essas diretrizes, mas eles são a convenção.       Se você tentar obter o ExitCode antes que o processo foi encerrado, a tentativa de lança uma exceção. Examine o <xref:System.Diagnostics.Process.HasExited%2A>propriedade primeiro para verificar se o processo associado foi encerrado.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída terá não concluído quando <xref:System.Diagnostics.Process.HasExited%2A>retorna `true`.</xref:System.Diagnostics.Process.HasExited%2A> Para garantir que a manipulação de eventos assíncrona foi concluída, chame a <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       Você pode usar o <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou o <xref:System.Diagnostics.Process.Kill%2A>método para fazer com que um processo associado ao sair.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona depende de chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para pausar o processamento de seu aplicativo até que o componente associado será encerrado.</xref:System.Diagnostics.Process.WaitForExit%2A> Notificação assíncrona depende de <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited> Ao usar a notificação assíncrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve ser definido como `true` para o <xref:System.Diagnostics.Process>componente para receber a notificação de que o processo foi encerrado.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "O código que o processo associado especificado quando ele terminar."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi encerrado.       o processo - ou - <xref:System.Diagnostics.Process.Handle*>não é válido.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade ExitCode para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando um processo foi encerrado."
  remarks: "O evento Exited indica que o processo associado foi encerrado. Essa ocorrência significa que o processo encerrado (interrompida) ou fechada com êxito. Esse evento pode ocorrer somente se o valor de <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>é de propriedade `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona significa chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para bloquear o thread atual até que o processo foi encerrado.</xref:System.Diagnostics.Process.WaitForExit%2A> Notificação assíncrona usa o evento Exited, que permite que o thread de chamada continuar a execução nesse meio tempo. No último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve ser definido como `true` para o aplicativo de chamada receber o evento Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Quando o sistema operacional é desligado por um processo, ele notifica todos os outros processos que registraram manipuladores para o evento Exited. Neste momento, o identificador do processo que acabou de sair pode ser usado para acessar algumas propriedades como <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.HasExited%2A>que o sistema operacional mantém até que ele libera esse identificador completamente.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Mesmo se você tiver um identificador para um processo encerrado, não é possível chamar <xref:System.Diagnostics.Process.Start%2A>novamente para reconectar-se para o mesmo processo.</xref:System.Diagnostics.Process.Start%2A> Chamar <xref:System.Diagnostics.Process.Start%2A>automaticamente libera o processo associado e se conecta a um processo com o mesmo arquivo, mas um totalmente novo <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.Start%2A>       Para obter mais informações sobre o uso do evento Exited em aplicativos de formulários do Windows, consulte o <xref:System.Diagnostics.Process.SynchronizingObject%2A>propriedade.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a hora em que o processo associado foi encerrado."
  remarks: "Se o processo não foi encerrado, a tentativa de recuperar a propriedade ExitTime lança uma exceção. Use <xref:System.Diagnostics.Process.HasExited%2A>antes de obter a propriedade ExitTime para determinar se o processo associado foi encerrado.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "Um <xref:System.DateTime>que indica quando o processo associado foi encerrado.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade ExitTime para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém uma nova <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e a associa o processo ativo no momento."
  remarks: "Use esse método para criar um novo <xref:System.Diagnostics.Process>instância e associá-lo com o recurso de processo no computador local.</xref:System.Diagnostics.Process>       Como o semelhante <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A>métodos, GetCurrentProcess associa um recurso existente com um novo <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente associado ao recurso de processo que está executando o aplicativo de chamada."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Retorna um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, considerando o identificador de um processo no computador local."
  remarks: "Use esse método para criar um novo <xref:System.Diagnostics.Process>componente e associá-lo a um recurso de processo no computador local.</xref:System.Diagnostics.Process> O recurso de processo já deve existir no computador, porque GetProcessById não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Um processo <xref:System.Diagnostics.Process.Id%2A>pode ser recuperado somente para um processo que está sendo executado no computador.</xref:System.Diagnostics.Process.Id%2A> Depois que o processo termina, GetProcessById lança uma exceção se você passar um identificador expirado.       Em qualquer computador em particular, o identificador de um processo é exclusivo. GetProcessById retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>retorna uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "O identificador exclusivo de sistema de um recurso de processo."
    return:
      type: System.Diagnostics.Process
      description: "Um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente que está associado com o recurso de local de processo identificado pelo <code> processId </code> parâmetro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo especificado pelo <code> processId </code> parâmetro não está em execução. O identificador pode ter expirado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado por este objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Retorna um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, dado um identificador de processo e o nome de um computador na rede."
  remarks: "Use esse método para criar um novo <xref:System.Diagnostics.Process>componente e associá-lo a um recurso de processo em um computador remoto na rede.</xref:System.Diagnostics.Process> O recurso de processo já deve existir no computador especificado, porque GetProcessById não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Um processo <xref:System.Diagnostics.Process.Id%2A>pode ser recuperado somente para um processo que está sendo executado no computador.</xref:System.Diagnostics.Process.Id%2A> Depois que o processo termina, GetProcessById lança uma exceção se você passar um identificador expirado.       Em qualquer computador em particular, o identificador de um processo é exclusivo. GetProcessById retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>retorna uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.       Se você não especificar um `machineName`, será usado o computador local. Como alternativa, você pode especificar o computador local, definindo `machineName` com o valor &quot;.&quot; ou uma cadeia de caracteres vazia (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "O identificador exclusivo de sistema de um recurso de processo."
    - id: machineName
      type: System.String
      description: "O nome de um computador na rede."
    return:
      type: System.Diagnostics.Process
      description: "Um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente que está associado a um recurso de processo remoto identificado pelo <code> processId </code> parâmetro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo especificado pelo <code> processId </code> parâmetro não está em execução. O identificador pode ter expirado.       - ou - <code> machineName </code> sintaxe do parâmetro é inválido. O nome pode ter comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado por este objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para cada recurso de processo no computador local."
  remarks: "Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo no computador local.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador local, pois GetProcesses não criar recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.       Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A>ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>método.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process>componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process>componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Serviços várias janelas podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa todos os recursos de processo em execução no computador local."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para cada recurso de processo no computador especificado."
  remarks: "Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo no computador (geralmente remoto) especificado.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador local, porque <xref:System.Diagnostics.Process.GetProcesses%2A>não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.       Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A>ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>método.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process>componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process>componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Esta sobrecarga do <xref:System.Diagnostics.Process.GetProcesses%2A>método geralmente é usado para recuperar a lista de recursos do processo em execução em um computador remoto na rede, mas você pode especificar o computador local, passando &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Serviços várias janelas podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "O computador do qual ler a lista de processos."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa todos os recursos de processo em execução no computador especificado."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> sintaxe do parâmetro é inválido. Ele pode ter comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Há problemas para acessar o contador de desempenho que API usada para obter informações do processo. Essa exceção é específica do Windows NT, Windows 2000 e Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um problema ao acessar uma API do sistema subjacente."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma matriz de novos <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componentes e as associa com todos os recursos de processo no computador local que compartilham o nome do processo especificado."
  remarks: "Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador local.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador, porque GetProcessesByName não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.       O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. GetProcessesByName é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.       Embora um processo <xref:System.Diagnostics.Process.Id%2A>é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro.</xref:System.Diagnostics.Process.Id%2A> Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A>retorna um processo no máximo, mas retorna GetProcessesByName, uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessById%2A> Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process>componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "O nome amigável do processo."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa os recursos de processo que executa o aplicativo especificado ou o arquivo."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Há problemas para acessar o contador de desempenho que API usada para obter informações do processo. Essa exceção é específica do Windows NT, Windows 2000 e Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma matriz de novos <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componentes e as associa com todos os recursos de processo em um computador remoto que compartilham o nome do processo especificado."
  remarks: "Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador especificado.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador, pois <xref:System.Diagnostics.Process.GetProcessesByName%2A>não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.       O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A>é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.       Embora um processo <xref:System.Diagnostics.Process.Id%2A>é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro.</xref:System.Diagnostics.Process.Id%2A> Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A>retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A>retorna uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process>componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.</xref:System.Diagnostics.Process>       Você pode usar essa sobrecarga para obter os processos no computador local, bem como em um computador remoto. Use &quot;.&quot; para especificar o computador local. Outra sobrecarga existe que utiliza o computador local por padrão.       Você pode acessar processos em computadores remotos somente para exibir informações, como estatísticas sobre os processos. Você não pode fechar, encerrar (usando <xref:System.Diagnostics.Process.Kill%2A>), ou inicie os processos em computadores remotos.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "O nome amigável do processo."
    - id: machineName
      type: System.String
      description: "O nome de um computador na rede."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa os recursos de processo que executa o aplicativo especificado ou o arquivo."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> sintaxe do parâmetro é inválido. Ele pode ter comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Há problemas para acessar o contador de desempenho que API usada para obter informações do processo. Essa exceção é específica do Windows NT, Windows 2000 e Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um problema ao acessar uma API do sistema subjacente."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador nativo do processo associado."
  remarks: "Um aplicativo pode obter um identificador para um processo que pode ser usado como um parâmetro para muitas funções de informações de processo e controle. Você pode usar esse identificador para inicializar um <xref:System.Threading.WaitHandle>ou chamar métodos nativos com a plataforma de invocar.</xref:System.Threading.WaitHandle>       Esse identificador de processo é particular para um aplicativo - em outras palavras, processo identificadores não podem ser compartilhados. Um processo também tem um processo <xref:System.Diagnostics.Process.Id%2A>que, ao contrário, o identificador é exclusivo e, portanto, válido em todo o sistema.</xref:System.Diagnostics.Process.Id%2A>       Somente processos iniciados por meio de uma chamada para <xref:System.Diagnostics.Process.Start%2A>definir a propriedade do identificador do <xref:System.Diagnostics.Process>instâncias.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "O identificador que o sistema operacional atribuído ao processo associado quando o processo foi iniciado. O sistema usa esse identificador para manter o controle de atributos de processo."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado ou foi encerrado. A propriedade do identificador não pode ser lido porque não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância.       - ou - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância foi anexada a um processo em execução, mas você não tem as permissões necessárias para obter um identificador com direitos de acesso completo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade de identificador para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o número de identificadores abertos pelo processo."
  remarks: "Identificadores fornecem uma maneira para um processo para se referir a objetos. Um processo pode obter identificadores de arquivos, recursos, filas de mensagens e muitos outros objetos do sistema operacional. O sistema operacional recupera a memória associada ao processo somente quando a contagem de identificadores é zero."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "O número de identificadores abertos pelo processo do sistema operacional."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um valor que indica se o processo associado foi encerrado."
  remarks: "Um valor de `true` para HasExited indica que o processo associado foi finalizado, normalmente ou anormal. Você pode solicitar ou forçar o processo associado ao sair chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Se um identificador é aberto para o processo, o sistema operacional libera a memória do processo quando o processo foi encerrado, mas retém informações administrativas sobre o processo, como o identificador, o código de saída e a hora de saída. Para obter essas informações, você pode usar o <xref:System.Diagnostics.Process.ExitCode%2A>e <xref:System.Diagnostics.Process.ExitTime%2A>Propriedades.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Essas propriedades são preenchidas automaticamente para os processos que foram iniciados por este componente. A informação administrativa é liberada quando todos os a <xref:System.Diagnostics.Process>componentes que estão associados com o processo de sistema são destruídos e manter não mais identificadores para o processo encerrado.</xref:System.Diagnostics.Process>       Um processo pode encerrar independentemente de seu código. Se você iniciou o processo usando esse componente, o sistema atualiza o valor de HasExited automaticamente, mesmo que o processo associado for encerrado independentemente.      > [!NOTE] > Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando essa propriedade retornará `true`. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não utiliza nenhum parâmetro antes de verificar HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo do sistema operacional é referenciada pelo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente foi finalizado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado ao objeto."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível recuperar o código de saída para o processo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade HasExited para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador exclusivo para o processo associado."
  remarks: "O processo de Id não é válido se o processo associado não está em execução. Portanto, você deve garantir que o processo está em execução antes de tentar recuperar a propriedade de Id. Até que o processo termina, o identificador de processo identifica exclusivamente o processo em todo o sistema.       Você pode se conectar a um processo que está em execução em um computador local ou remoto para um novo <xref:System.Diagnostics.Process>instância passando o identificador de processo para o <xref:System.Diagnostics.Process.GetProcessById%2A>método.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>é um `static` método que cria um novo componente e define a propriedade Id para o novo <xref:System.Diagnostics.Process>instância automaticamente.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Identificadores de processo podem ser reutilizados pelo sistema. O valor da propriedade Id é exclusivo somente enquanto o processo associado está em execução. Depois que o processo foi encerrado, o sistema pode reutilizar o valor da propriedade Id para um processo relacionado.       Como o identificador é exclusivo no sistema, você pode passar para outros threads como uma alternativa para passar um <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> Esta ação pode economizar recursos do sistema e garantir que o processo é identificado corretamente."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "O identificador exclusivo gerado pelo sistema do processo que é referenciado por este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Propriedade de Id do processo não foi definida.       - ou - não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Interrompe imediatamente o processo associado."
  remarks: "Kill força um encerramento do processo, enquanto <xref:System.Diagnostics.Process.CloseMainWindow%2A>solicita somente um encerramento.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Durante a execução de um processo com uma interface gráfica, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo.</xref:System.Diagnostics.Process.CloseMainWindow%2A> A solicitação para sair do processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>não força o aplicativo fechar.</xref:System.Diagnostics.Process.CloseMainWindow%2A> O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o método Kill. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A>é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.      > [!NOTE] > Eliminar o método executa de forma assíncrona. Depois de chamar o método Kill, chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para aguardar o processo sair ou verificar o <xref:System.Diagnostics.Process.HasExited%2A>propriedade para determinar se o processo foi encerrado.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar Kill. Kill faz com que um encerramento anormal de processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Se <xref:System.Diagnostics.Process.CloseMainWindow%2A>falhar, você pode usar Kill para encerrar o processo.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill é a única maneira de encerrar os processos que não têm interfaces gráficas.       Você pode chamar Kill e <xref:System.Diagnostics.Process.CloseMainWindow%2A>somente para processos em execução no computador local.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.      > [!NOTE] > Se for feita a chamada ao método Kill enquanto o processo está sendo encerrado no momento, um <xref:System.ComponentModel.Win32Exception>é lançada para acesso negado.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível terminar o processo associado.       - ou - o processo está sendo encerrado.       - ou - o processo associado é um executável de Win16."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando chamar Kill para um processo que está em execução em um computador remoto. O método está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo já foi encerrado.       - ou - não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Leva um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente fora do estado que permite interagir com processos do sistema operacional que são executados em um modo especial."
  remarks: "Alguns processos do sistema operacional executado em um modo especial. Tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você chamou <xref:System.Diagnostics.Process.EnterDebugMode%2A>no componente.</xref:System.Diagnostics.Process.EnterDebugMode%2A> Chame LeaveDebugMode quando você não precisa mais acesso a esses processos que são executados em modo especial."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do processo associado está em execução no computador."
  remarks: "Você pode exibir dados de estatísticas e informações de processo para processos em execução em computadores remotos, mas não é possível chamar <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A>em computadores remotos.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > Quando o processo associado está em execução no computador local, essa propriedade retorna um ponto (&quot;.&quot;) para o nome do computador. Você deve usar o <xref:System.Environment.MachineName%2A?displayProperty=fullName>propriedade para obter o nome do computador correto.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "O nome do computador que está executando o processo associado."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o módulo principal para o processo associado."
  remarks: "Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. A propriedade MainModule lhe permite exibir informações sobre o executável usado para iniciar o processo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "O <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> que foi usado para iniciar o processo."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade MainModule para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Um processo de 32 bits está tentando acessar os módulos de um processo de 64 bits."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi encerrado."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador de janela da janela principal do processo associado."
  remarks: "A janela principal é a janela aberta pelo processo que atualmente tem o foco (o <xref:System.Windows.Forms.Form.TopLevel%2A>formulário).</xref:System.Windows.Forms.Form.TopLevel%2A> Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A>método para atualizar o <xref:System.Diagnostics.Process>objeto para obter o identificador de janela principal atual, se ele tiver sido alterada.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> Em geral, como o identificador de janela é armazenado em cache, use <xref:System.Diagnostics.Process.Refresh%2A>antecipadamente para garantir que você vai recuperar o identificador atual.</xref:System.Diagnostics.Process.Refresh%2A>       Você pode obter a propriedade MainWindowHandle somente para processos em execução no computador local. A propriedade MainWindowHandle é um valor que identifica exclusivamente a janela que está associada com o processo.       Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal, o valor de MainWindowHandle é zero. O valor também é zero para processos que foram ocultos, ou seja, processos que não são visíveis na barra de tarefas. Isso pode ser o caso para processos que são exibidos como ícones na área de notificação, na extrema direita da barra de tarefas.       Se você acabou de iniciar um processo e deseja usar seu identificador de janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A>método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Caso contrário, uma exceção será lançada."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "O identificador de janela gerada pelo sistema da janela principal do processo associado."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O MainWindowHandle não foi definido porque o processo foi encerrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade MainWindowHandle para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a legenda da janela principal do processo."
  remarks: "Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal (para que <xref:System.Diagnostics.Process.MainWindowHandle%2A>é zero), MainWindowTitle é uma cadeia de caracteres vazia (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Se você acabou de iniciar um processo e deseja usar o título da janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A>método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Caso contrário, o sistema gerará uma exceção.      > [!NOTE] > A janela principal é a janela que tem o foco no momento; Observe que isso pode não ser a janela principal para o processo. Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A>método para atualizar o <xref:System.Diagnostics.Process>objeto para obter o identificador de janela principal atual, se ele tiver sido alterada.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "O título da janela principal do processo."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A propriedade MainWindowTitle não está definida como o processo foi encerrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade MainWindowTitle para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho máximo permitido trabalho conjunto, em bytes, para o processo associado."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.       Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.       O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o MaxWorkingSet e <xref:System.Diagnostics.Process.MinWorkingSet%2A>membros.</xref:System.Diagnostics.Process.MinWorkingSet%2A> No entanto, definir esses valores não garante que a memória será reservado ou residente.      > [!NOTE] > Quando você aumenta o tamanho do conjunto de trabalho de um processo, você levar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "O máximo conjunto de trabalho tamanho permitido na memória para o processo, em bytes."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho do conjunto de trabalho máximo é inválido. Ele deve ser maior ou igual ao mínimo o tamanho do conjunto de trabalho."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não é possível recuperar informações do conjunto de trabalho do recurso para o processo associado.       - ou - o identificador de processo ou o identificador de processo é zero porque o processo não foi iniciado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade MaxWorkingSet para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi encerrado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho mínimo permitido trabalho conjunto, em bytes, para o processo associado."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.       Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.       O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A>e membros MinWorkingSet.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> No entanto, definir esses valores não garante que a memória será reservado ou residente.      > [!NOTE] > Quando você aumenta o tamanho do conjunto de trabalho de um processo, você levar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "O trabalho mínimo define tamanho necessário na memória para o processo, em bytes."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O mínimo de tamanho do conjunto de trabalho é inválido. Ele deve ser menor ou igual ao máximo o tamanho do conjunto de trabalho."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não é possível recuperar informações do conjunto de trabalho do recurso para o processo associado.       - ou - o identificador de processo ou o identificador de processo é zero porque o processo não foi iniciado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade MinWorkingSet para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi encerrado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém os módulos que foram carregados pelo processo associado."
  remarks: "Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. Um <xref:System.Diagnostics.ProcessModule>instância permite que você exiba informações sobre um módulo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo.</xref:System.Diagnostics.ProcessModule>       Um processo pode carregar vários módulos na memória. Por exemplo, arquivos de .exe que carregar arquivos. dll adicionais têm vários módulos.       Depois de iniciar o processo, essa coleção está vazia até que o sistema tenha carregado o processo. Se o processo tem uma janela principal, você pode chamar <xref:System.Diagnostics.Process.WaitForInputIdle%2A>antes de recuperar esta propriedade para garantir que a coleção está vazia quando você obtém a lista.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> que representa os módulos que foram carregados pelo processo associado."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade de módulos para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Você está tentando acessar a propriedade de módulos para o processo do sistema ou o processo ocioso. Esses processos não têm módulos."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória do sistema não-paginável, em bytes, alocados para o processo associado."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, o sistema tem alocada para o processo associado não é possível gravar o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória do sistema não-paginável, em bytes, alocados para o processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual de memória não paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Alocações de memória não paginada permanecem na memória do sistema e não são transferidas para o arquivo de paginação de memória virtual.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool não-paginável** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória do sistema, em bytes, alocado para o processo associado não é possível gravar o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gera o <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> eventos."
  remarks: "OnExited é o método de API que gera o <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited> Chamando OnExited faz com que o <xref:System.Diagnostics.Process.Exited>evento ocorra e é a única maneira de gerar o evento usando o <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited é usado principalmente ao derivar de classes do componente.       Como alternativa para OnExited, você pode escrever seu próprio manipulador de eventos. Crie seu próprio delegado do manipulador de eventos e seu próprio método de manipulação de eventos.      > [!NOTE] > Se você estiver usando o ambiente do Visual Studio, um representante do manipulador de eventos (AddOnExited) e um método de manipulação de eventos (Process1_Exited) são criados para você quando você arrasta um <xref:System.Diagnostics.Process>componente em um formulário e clique duas vezes no ícone.</xref:System.Diagnostics.Process> O código que você cria para executar quando o <xref:System.Diagnostics.Process.Exited>evento ocorre é inserido no procedimento Process1_Exited.</xref:System.Diagnostics.Process.Exited> Você não precisa criar o membro OnExited, porque ele é implementado para você.       Gerar um evento invoca o manipulador de eventos por meio de um representante. Para obter uma visão geral, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre sempre que um aplicativo grava uma linha para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput*>stream.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "O evento OutputDataReceived indica que o associado <xref:System.Diagnostics.Process>escreveu uma linha, terminando com um caractere de nova linha, para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       O evento é habilitado durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o evento OutputDataReceived e chame <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Depois disso, os sinais de evento OutputDataReceived cada vez que o processo grava uma linha no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo, até que o processo foi encerrado ou chamadas <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para garantir que o buffer de saída foi liberado.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginável, em bytes, alocados para o processo associado."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, alocada pelo processo associado que pode ser gravado para o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginável, em bytes, alocados para o processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual da memória no arquivo de paginação de memória virtual usada pelo processo, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho de memória usada pelo sistema operacional para o processo, use o <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>propriedade.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes do arquivo de página** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória do sistema paginável, em bytes, alocados para o processo associado."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, o sistema tem alocada para o processo associado que pode ser gravado para o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória do sistema paginável, em bytes, alocados para o processo associado."
  remarks: "O valor retornado pelo valor dessa propriedade representa o tamanho atual de memória paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho da memória do aplicativo usado pelo processo, use o <xref:System.Diagnostics.Process.PagedMemorySize64%2A>propriedade.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool paginável** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória do sistema, em bytes, alocado para o processo associado que pode ser gravado para o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória no arquivo de paginação de memória virtual, em bytes, usada pelo processo associado."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória, em bytes, alocada pelo processo associado foi possível gravar o arquivo de paginação de memória virtual."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória no arquivo de paginação de memória virtual, em bytes, usada pelo processo associado."
  remarks: "O valor retornado pelo valor dessa propriedade representa o tamanho máximo de memória no arquivo de paginação de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes de arquivo de paginação** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado, desde que ele foi iniciado."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória virtual, em bytes, que solicitou o processo associado."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho máximo de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes virtuais** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória virtual, em bytes, alocado para o processo associado, desde que ele foi iniciado."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tamanho máximo de trabalho conjunto para o processo associado, em bytes."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo módulos de processo e as bibliotecas do sistema."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória física que o processo associado foi necessária uma só vez, em bytes."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória física, em bytes, usada pelo processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho máximo do trabalho conjunto de memória usada pelo processo desde que ele iniciado, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções de módulos de processo e as bibliotecas do sistema.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de conjunto de trabalho** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória física, em bytes, alocado para o processo associado, desde que ele foi iniciado."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se a prioridade do processo associado temporariamente deve ser ampliada pelo sistema operacional quando o foco está na janela principal."
  remarks: "Quando um thread é executado em um processo para o qual a classe de prioridade tem um dos valores de enumeração prioridade dinâmica (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, ou <xref:System.Diagnostics.ProcessPriorityClass>), o sistema aumenta a prioridade do segmento temporariamente quando ele é retirado de um estado de espera.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Essa ação impede que outros processos a interromper o processamento do thread atual. A configuração de PriorityBoostEnabled afeta todos os threads existentes e qualquer threads criados posteriormente pelo processo. Para restaurar o comportamento normal, defina a propriedade de PriorityBoostEnabled como `false`.      > [!NOTE] > Aumentando demais a prioridade pode esgotar os recursos essenciais do sistema operacional e funções de rede, causando problemas com outras tarefas do sistema operacional."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o aumento dinâmico da prioridade do processo deve ocorrer para um processo quando ele é colocado fora do estado de espera; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível recuperar informações de aumento de prioridade do recurso para o processo associado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.       - ou - o identificador de processo ou o identificador de processo é zero. (O processo não foi iniciado.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade PriorityBoostEnabled para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a categoria geral de prioridade para o processo associado."
  remarks: "Uma classe de prioridade do processo abrange uma gama de níveis de prioridade de thread. Os threads com diferentes prioridades, que estão em execução no processo de executar em relação a classe de prioridade do processo. Win32 usa quatro classes de prioridade com sete níveis de prioridade básica por classe. Essas classes de prioridade de processo são capturados no <xref:System.Diagnostics.ProcessPriorityClass>enumeração, que permite que você defina a prioridade do processo <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, ou <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Com base no tempo decorrida ou outras aumenta, o nível de prioridade base pode ser alterada pelo sistema operacional quando um processo precisa ser colocado à frente de outros usuários para acesso ao processador. Além disso, você pode definir o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>para aumentar temporariamente o nível de prioridade de segmentos que foram executadas fora do estado de espera.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> A prioridade será redefinida quando o processo de volta para o estado de espera.       O <xref:System.Diagnostics.Process.BasePriority%2A>propriedade permite que você exiba a prioridade inicial que é atribuída a um processo.</xref:System.Diagnostics.Process.BasePriority%2A> No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A>propriedade para definir a prioridade de um processo.</xref:System.Diagnostics.Process.BasePriority%2A> Para alterar a prioridade, use a propriedade de classe de prioridade, que obtém ou define a categoria geral de prioridade para o processo.       A classe de prioridade não pode ser exibida usando o Monitor do sistema. A tabela a seguir mostra a relação entre o <xref:System.Diagnostics.Process.BasePriority%2A>e valores de classe de prioridade.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | Classe de prioridade |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "A categoria de prioridade para o processo associado, do qual o <xref:System.Diagnostics.Process.BasePriority*>do processo é calculada.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Informações de prioridade do processo não foi possível definir ou recuperar do recurso para o processo associado.       - ou - o identificador de processo ou o identificador de processo é zero. (O processo não foi iniciado.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade de classe de prioridade para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Você definiu a classe de prioridade para <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> ao usar o Windows 98 ou Windows Millennium Edition (Windows Me). Essas plataformas não dão suporte a esses valores para a classe de prioridade."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Classe de prioridade não pode ser definido porque ele não usa um valor válido, conforme definido no <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> enumeração."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória privada, em bytes, alocados para o processo associado."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "O número de bytes alocados pelo processo associado não pode ser compartilhado com outros processos."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória privada, em bytes, alocados para o processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual da memória usada pelo processo, em bytes, que não pode ser compartilhada com outros processos.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes particulares** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória, em bytes, alocado para o processo associado não pode ser compartilhado com outros processos."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo privilegiado do processador para este processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Um <xref:System.TimeSpan>que indica a quantidade de tempo que o processo gastou executando código dentro do núcleo do sistema operacional.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade PrivilegedProcessorTime para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do processo."
  remarks: "A propriedade ProcessName contém um nome de arquivo executável, como o Outlook, que não inclui a extensão .exe ou o caminho. É útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável.      > [!NOTE] > Em [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] sistemas operacionais, a propriedade ProcessName poderá ser truncada a 15 caracteres, se as informações do módulo de processo não podem ser obtidas.       Você pode chamar <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando um nome de arquivo executável, para recuperar uma matriz que contém todas as instâncias em execução no computador especificado.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Você pode usar essa matriz, por exemplo, para fechar todas as instâncias em execução do arquivo executável."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "O nome que o sistema usa para identificar o processo para o usuário."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem um identificador ou nenhum processo está associado a <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - ou - o processo associado foi encerrado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O processo não está neste computador."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define os processadores no qual os threads do processo podem ser agendados para execução."
  remarks: "No Windows 2000 e posterior, um thread em um processo pode migrar do processador, com cada migração recarregando o cache do processador. Sob cargas de sistema pesadas, especificar qual processador deve executar um thread específico pode melhorar o desempenho reduzindo o número de vezes que o cache de processador é recarregado. A associação entre um processador e um thread é chamada a afinidade do processador.       Cada processador é representado como um pouco. Bit 0 é o processador de um, o bit 1 é o processador de dois e assim por diante. Se você definir um bit para o valor 1, o processador correspondente é selecionado para atribuição de thread. Quando você define o valor ProcessorAffinity em zero, algoritmos de agendamento do sistema operacional definem a afinidade do thread. Quando o valor de ProcessorAffinity é definido como qualquer valor diferente de zero, o valor é interpretado como um bitmask que especifica esses processadores qualificados para seleção.       A tabela a seguir mostra uma seleção de valores de ProcessorAffinity para um sistema com oito processadores.      | Bitmask | Valor binário | Processadores qualificados |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 e 2 |   | 0x0007 | 00000000 00000111 | 1, 2 e 3 |   | 0x0009 | 00000000 00001001 | 1 e 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 e 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "Um bitmask representando os processadores que podem ser executados em threads no processo associado. O padrão depende do número de processadores no computador. O valor padrão é 2 <sup>n</sup> -1, onde n é o número de processadores."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "ProcessorAffinity informações não podem ser definidas ou recuperadas do recurso para o processo associado.       - ou - o identificador de processo ou o identificador de processo é zero. (O processo não foi iniciado.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade ProcessorAffinity para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo de <xref:System.Diagnostics.Process.Id*>não estava disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi encerrado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Descarta todas as informações sobre o processo associado foi armazenado em cache dentro do componente do processo."
  remarks: "Depois que a atualização é chamada, a primeira solicitação para obter informações sobre cada propriedade faz com que o componente do processo obter um novo valor do processo associado.       Quando um <xref:System.Diagnostics.Process>componente está associado um recurso de processo, os valores de propriedade de <xref:System.Diagnostics.Process>imediatamente são preenchidas de acordo com o status do processo associado.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Se as informações sobre o processo associado for alterado posteriormente, essas alterações não são refletidas no <xref:System.Diagnostics.Process>do componente armazenado em cache valores.</xref:System.Diagnostics.Process> O <xref:System.Diagnostics.Process>componente é um instantâneo do recurso de processo no momento em que eles estão associados.</xref:System.Diagnostics.Process> Para exibir os valores atuais para o processo associado, chame o método de atualização."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um valor que indica se a interface do usuário do processo está respondendo."
  remarks: "Se um processo tem uma interface do usuário, a propriedade respondendo entra em contato com a interface do usuário para determinar se o processo está respondendo à entrada do usuário. Se a interface não responder imediatamente, a propriedade retorna respondendo `false`. Use essa propriedade para determinar se a interface do processo associado parou de responder.       Se o processo não tem um <xref:System.Diagnostics.Process.MainWindowHandle%2A>, essa propriedade retornará `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a interface do usuário do processo associado está respondendo ao sistema; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade de resposta para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador nativo para este processo."
  remarks: "O identificador só estará disponível se o componente de discagem iniciou o processo."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "O identificador nativo para este processo."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador de sessão dos serviços de Terminal para o processo associado."
  remarks: "A propriedade SessionId identifica a sessão na qual o aplicativo está sendo executado."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "O identificador de sessão dos serviços de Terminal para o processo associado."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Não há nenhuma sessão associada a esse processo."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado com este identificador de sessão.       - ou - o processo associado não está nesta máquina."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A propriedade SessionId não é suportada no Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo usado para ler a saída de erro do aplicativo."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto para seu fluxo de erro padrão que o texto é exibido normalmente no console.</xref:System.Diagnostics.Process> Redirecionando o fluxo StandardError, você pode manipular ou suprimir a saída de erro de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.      > [!NOTE] > Para usar StandardError, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, a leitura do fluxo StandardError gera uma exceção.       O fluxo StandardError redirecionado pode ser lidos de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>executar operações de leitura síncronas no fluxo de saída de erro do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process>grava seu fluxo StandardError ou fecha o fluxo.</xref:System.Diagnostics.Process>       Por outro lado, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>inicia assíncrona operações de leitura no fluxo StandardError.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.       Operações de leitura síncronas apresentam uma dependência entre o chamador lendo de fluxo StandardError e o processo filho gravar no fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.       O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```O exemplo de código evita uma condição de deadlock chamando `p.StandardError.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho poderia esperar indefinidamente do pai sejam lidos do fluxo StandardError completo.       Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de deadlock pela execução assíncrona de operações de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar seu <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> O processo filho poderia esperar indefinidamente do pai sejam lidos do fluxo StandardError completo.       Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.      > [!NOTE] > Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não execute <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no fluxo StandardError, ou vice-versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para o fluxo StandardError.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "Um <xref:System.IO.StreamReader>que pode ser usado para ler o fluxo de erro padrão do aplicativo.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo usado para gravar a entrada do aplicativo."
  remarks: "Um <xref:System.Diagnostics.Process>pode ler o texto de entrada de seu fluxo de entrada padrão, normalmente o teclado.</xref:System.Diagnostics.Process> Redirecionando o fluxo de StandardInput, você pode especificar programaticamente a entrada. Por exemplo, em vez de usar a entrada do teclado, você pode fornecer o texto do conteúdo de um arquivo designado ou saída de outro aplicativo.      > [!NOTE] > Para usar StandardInput, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, o fluxo gravar o StandardInput lança uma exceção."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "Um <xref:System.IO.StreamWriter>que pode ser usado para gravar o fluxo de entrada padrão do aplicativo.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo de StandardInput não foi definido porque &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; é definido como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo usado para ler a saída textual do aplicativo."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto para seu fluxo padrão, que o texto é exibido normalmente no console.</xref:System.Diagnostics.Process> Redirecionando o fluxo StandardOutput, você pode manipular ou suprimir a saída de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.      > [!NOTE] > Para usar StandardOutput, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, a leitura do fluxo StandardOutput gera uma exceção.       O fluxo StandardOutput redirecionado pode ser lidos de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>executar operações de leitura síncronas no fluxo de saída do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process>grava o fluxo StandardOutput ou fecha o fluxo.</xref:System.Diagnostics.Process>       Por outro lado, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>inicia assíncrona operações de leitura no fluxo StandardOutput.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.       Operações de leitura síncronas apresentam uma dependência entre o chamador ler o fluxo StandardOutput e o processo filho gravar no fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.       O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita uma condição de deadlock chamando `p.StandardOutput.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardOutput.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho poderia esperar indefinidamente do pai sejam lidos do fluxo StandardOutput completo.       Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de deadlock executando operações de leitura assíncronas no fluxo StandardOutput. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar o fluxo StandardOutput. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.      > [!NOTE] > Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não execute <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no fluxo StandardOutput, ou vice-versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "Um <xref:System.IO.StreamReader>que pode ser usado para ler o fluxo de saída padrão do aplicativo.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "É iniciado (ou reutiliza) do recurso de processo especificado pelo <xref:System.Diagnostics.Process.StartInfo*>propriedade deste <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e o associa ao componente.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se um recurso do processo foi iniciado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se nenhum recurso novo do processo for iniciado (por exemplo, se um processo existente é reutilizado)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nenhum nome de arquivo foi especificado no <xref href=&quot;System.Diagnostics.Process&quot;> </xref> do componente <> </> *>.       - ou - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; membro o <> </> *> é de propriedade <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> enquanto &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, ou &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia o recurso de processo que é especificado pelo parâmetro que contém informações de início do processo (por exemplo, o nome do arquivo do processo para iniciar) e associa o recurso a um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "O <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> que contém as informações que são usadas para iniciar o processo, incluindo o nome do arquivo e os argumentos de linha de comando."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado com o recurso de processo, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso de processo é iniciado. Observe que um novo processo é iniciado junto com já executando instâncias do mesmo processo independente dos outros. Além disso, o início pode retornar um processo não nula com seu <xref:System.Diagnostics.Process.HasExited*>propriedade já está definida como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Nesse caso, o processo iniciado pode ter ativado uma instância existente do próprio e, em seguida, foi encerrado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nenhum nome de arquivo foi especificado no <code> startInfo </code> do parâmetro <> </> *> propriedade.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - ou - o <> </> *> propriedade o <code> startInfo </code> parâmetro é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> e o <> </> *> propriedade não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou está vazio ou o <> </> *> propriedade não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo especificado no <code> startInfo </code> do parâmetro <xref:System.Diagnostics.ProcessStartInfo.FileName*>não foi possível localizar a propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado.       - ou - a soma do tamanho dos argumentos e o comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser um dos seguintes: &quot;a área de dados passada para uma chamada do sistema é muito pequena.&quot; ou &quot;Acesso negado&quot;."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo, especificando o nome de um arquivo de documento ou aplicativo e associa o recurso a um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um arquivo de documento ou aplicativo para execução no processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado com o recurso de processo, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso de processo é iniciado. Observe que um novo processo é iniciado junto com já executando instâncias do mesmo processo independente dos outros. Além disso, o início pode retornar um processo não nula com seu <xref:System.Diagnostics.Process.HasExited*>propriedade já está definida como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Nesse caso, o processo iniciado pode ter ativado uma instância existente do próprio e, em seguida, foi encerrado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A variável de ambiente PATH tem uma cadeia de caracteres contendo aspas."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo, especificando o nome de um aplicativo e um conjunto de argumentos de linha de comando e associa o recurso a um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um arquivo de aplicativo para ser executado no processo."
    - id: arguments
      type: System.String
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado com o recurso de processo, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso de processo é iniciado. Observe que um novo processo é iniciado junto com já executando instâncias do mesmo processo independente dos outros. Além disso, o início pode retornar um processo não nula com seu <xref:System.Diagnostics.Process.HasExited*>propriedade já está definida como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Nesse caso, o processo iniciado pode ter ativado uma instância existente do próprio e, em seguida, foi encerrado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado.       - ou - a soma do tamanho dos argumentos e o comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser um dos seguintes: &quot;a área de dados passada para uma chamada do sistema é muito pequena.&quot; ou &quot;Acesso negado&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A variável de ambiente PATH tem uma cadeia de caracteres contendo aspas."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo, especificando o nome de um aplicativo, um nome de usuário, uma senha e um domínio e associa o recurso a um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome de arquivo, nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).      > [!NOTE] > Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.      > [!NOTE] > Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.       Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process>instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Propriedades do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar <xref:System.Diagnostics.Process.Start%2A>para a <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro &quot;Notepad.exe&quot; ou &quot;Notepad&quot;. Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.      > [!NOTE] > O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A>sobrecargas que têm `userName`, `password`, e `domain` parâmetros.</xref:System.Diagnostics.Process.Start%2A>       Sempre que você usar <xref:System.Diagnostics.Process.Start%2A>para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema.</xref:System.Diagnostics.Process.Start%2A> Feche os processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Você pode verificar se um processo já foi fechado por meio de sua <xref:System.Diagnostics.Process.HasExited%2A>propriedade...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um arquivo de aplicativo para ser executado no processo."
    - id: userName
      type: System.String
      description: "O nome de usuário a ser usado ao iniciar o processo."
    - id: password
      type: System.Security.SecureString
      description: "Um <xref href=&quot;System.Security.SecureString&quot;> </xref> que contém a senha para usar ao iniciar o processo."
    - id: domain
      type: System.String
      description: "O domínio a ser usado ao iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado com o recurso de processo, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso de processo é iniciado. Observe que um novo processo é iniciado junto com já executando instâncias do mesmo processo independente dos outros. Além disso, o início pode retornar um processo não nula com seu <xref:System.Diagnostics.Process.HasExited*>propriedade já está definida como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Nesse caso, o processo iniciado pode ter ativado uma instância existente do próprio e, em seguida, foi encerrado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nenhum nome de arquivo foi especificado."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo, especificando o nome de um aplicativo, um conjunto de argumentos de linha de comando, um nome de usuário, uma senha e um domínio e associa o recurso a um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome do arquivo, argumentos de linha de comando, o nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).      > [!NOTE] > Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.      > [!NOTE] > Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.       Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process>instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Propriedades do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar <xref:System.Diagnostics.Process.Start%2A>para a <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro &quot;Notepad.exe&quot; ou &quot;Notepad&quot;. Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.      > [!NOTE] > O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A>sobrecargas que têm `userName`, `password`, e `domain` parâmetros.</xref:System.Diagnostics.Process.Start%2A>       Sempre que você usar <xref:System.Diagnostics.Process.Start%2A>para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema.</xref:System.Diagnostics.Process.Start%2A> Feche os processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Você pode verificar se um processo já foi fechado por meio de sua <xref:System.Diagnostics.Process.HasExited%2A>propriedade...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um arquivo de aplicativo para ser executado no processo."
    - id: arguments
      type: System.String
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    - id: userName
      type: System.String
      description: "O nome de usuário a ser usado ao iniciar o processo."
    - id: password
      type: System.Security.SecureString
      description: "Um <xref href=&quot;System.Security.SecureString&quot;> </xref> que contém a senha para usar ao iniciar o processo."
    - id: domain
      type: System.String
      description: "O domínio a ser usado ao iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado com o recurso de processo, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso de processo é iniciado. Observe que um novo processo é iniciado junto com já executando instâncias do mesmo processo independente dos outros. Além disso, o início pode retornar um processo não nula com seu <xref:System.Diagnostics.Process.HasExited*>propriedade já está definida como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Nesse caso, o processo iniciado pode ter ativado uma instância existente do próprio e, em seguida, foi encerrado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nenhum nome de arquivo foi especificado."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o arquivo associado.       - ou - a soma do tamanho dos argumentos e o comprimento do caminho completo para o arquivo associado excede 2080. A mensagem de erro associada a essa exceção pode ser um dos seguintes: &quot;a área de dados passada para uma chamada do sistema é muito pequena.&quot; ou &quot;Acesso negado&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi descartado."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define as propriedades para passar para o <xref:System.Diagnostics.Process.Start*>método o <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo representa o conjunto de parâmetros a serem usados para iniciar um processo. Quando <xref:System.Diagnostics.Process.Start%2A>é chamado, o StartInfo é usado para especificar o processo iniciar.</xref:System.Diagnostics.Process.Start%2A> É o membro StartInfo somente necessário para definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Iniciar um processo, especificando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade assemelha-se de digitar as informações de **executar** caixa de diálogo do Windows **iniciar** menu.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Portanto, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade não precisam para representar um arquivo executável.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade como &quot;Notepad.exe&quot; ou &quot;Notepad&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Você pode iniciar um aplicativo ClickOnce, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.       Se o nome do arquivo envolve um arquivo não executável, como um arquivo. doc, você pode incluir um verbo especificando a ação que será executada no arquivo. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>para &quot;Print&quot; de um arquivo na extensão. doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> O nome de arquivo especificado no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade não é necessário ter uma extensão, se você inserir manualmente um valor para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> No entanto, se você usar o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>para determinar quais verbos disponíveis, você deve incluir a extensão.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Você pode alterar os parâmetros especificados na propriedade StartInfo até o momento em que você chamar o <xref:System.Diagnostics.Process.Start%2A>método sobre o processo.</xref:System.Diagnostics.Process.Start%2A> Depois de iniciar o processo, alterando os valores de StartInfo não afetam ou reiniciar o processo associado. Se você chamar o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>método com o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>conjunto de propriedades, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>valor da propriedade é <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Se você não usou o <xref:System.Diagnostics.Process.Start%2A>método para iniciar um processo, a propriedade StartInfo não reflete os parâmetros usados para iniciar o processo.</xref:System.Diagnostics.Process.Start%2A> Por exemplo, se você usar <xref:System.Diagnostics.Process.GetProcesses%2A>para obter uma matriz de processos em execução no computador, a propriedade StartInfo de cada <xref:System.Diagnostics.Process>não contém o nome do arquivo original ou os argumentos usados para iniciar o processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Quando o processo é iniciado, o nome do arquivo é o arquivo que preenche (somente leitura) <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> Se você quiser recuperar o arquivo executável que está associado com o processo depois que o processo foi iniciado, use o <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> Se você deseja definir o arquivo executável de um <xref:System.Diagnostics.Process>de instância para que um processo associado não foi iniciado, use a propriedade de StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Como os membros da propriedade StartInfo são argumentos que são passados para o <xref:System.Diagnostics.Process.Start%2A>método de um processo, alterando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade depois de iniciado o processo associado não será redefinido o <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Essas propriedades são usadas apenas para inicializar o processo associado."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "O <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> que representa os dados com o qual deseja iniciar o processo. Esses argumentos incluem o nome do arquivo executável ou documento usado para iniciar o processo."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "É o valor que especifica o StartInfo <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a hora em que o processo associado foi iniciado."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Um objeto que indica quando o processo foi iniciado. Uma exceção é gerada se o processo não está em execução."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade StartTime de um processo que está executando em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo foi encerrado.       - ou - o processo não foi iniciado."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro na chamada para a função do Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o objeto usado para empacotar as chamadas de manipulador de eventos emitidas como resultado de um evento de saída do processo."
  remarks: "Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>é `null`, métodos que manipulam o <xref:System.Diagnostics.Process.Exited>eventos são chamados em um thread do pool de threads do sistema.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando o <xref:System.Diagnostics.Process.Exited>evento é manipulado por um componente de Windows Forms visual, como um <xref:System.Windows.Forms.Button>, acessar o componente através do pool de threads de sistema pode não funcionar, ou pode resultar em uma exceção.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Evitar isso, definindo SynchronizingObject como um componente de Windows Forms, que faz com que os métodos de manipulação de <xref:System.Diagnostics.Process.Exited>evento seja chamado no mesmo thread em que o componente foi criado.</xref:System.Diagnostics.Process.Exited>       Se o <xref:System.Diagnostics.Process>é usado dentro de [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] em um designer de formulários do Windows, SynchronizingObject é definida automaticamente como o controle que contém o <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Por exemplo, se você colocar um <xref:System.Diagnostics.Process>em um designer para `Form1` (que herda de <xref:System.Windows.Forms.Form>) a propriedade SynchronizingObject <xref:System.Diagnostics.Process>está definido para a instância do `Form1`: [!code-cpp [Process_SynchronizingObject n º&2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject n º&2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject n º&2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] normalmente, essa propriedade é definida quando o componente é colocado dentro de um controle ou formulário, pois esses componentes estão associados a um segmento específico.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "O <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> usado para empacotar as chamadas do manipulador de eventos emitidas como resultado de uma <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> eventos do processo."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o conjunto de threads que estão em execução no processo associado."
  remarks: "Um thread pode executar código em um processo. Cada processo é iniciado com um único thread, o thread principal. Qualquer thread pode criar threads adicionais. Threads em um processo compartilham o espaço de endereço do processo.       Use <xref:System.Diagnostics.ProcessThread>para obter todos os threads associados ao processo atual.</xref:System.Diagnostics.ProcessThread> O thread principal não é necessariamente no índice zero na matriz."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> que representa o sistema operacional de threads atualmente em execução no processo associado."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "O processo não tem um <xref:System.Diagnostics.Process.Id*>, ou nenhum processo está associado a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância.</xref:System.Diagnostics.Process.Id*>       - ou - o processo associado foi encerrado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para acessar essa propriedade no Windows 98 e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formata o nome do processo como uma cadeia de caracteres, combinada com o tipo de componente do pai, se aplicável."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "O <> </> *>, combinado com o componente base <> </> *> valor de retorno."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString não é suportado no Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo total do processador para este processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Um <xref:System.TimeSpan>que indica a quantidade de tempo que o processo associado passou a utilização da CPU.</xref:System.TimeSpan> Esse valor é a soma da <> </> *> e <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade TotalProcessorTime para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo de processador do usuário para esse processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Um <xref:System.TimeSpan>que indica a quantidade de tempo que o processo associado gastou executando código dentro a parte do aplicativo do processo (não dentro do núcleo do sistema operacional).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Você está tentando acessar a propriedade UserProcessorTime para um processo que está em execução em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tamanho da memória virtual do processo em bytes."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória virtual, em bytes, que solicitou o processo associado."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória virtual, em bytes, alocados para o processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual de memória virtual usada pelo processo, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes virtuais** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória virtual, em bytes, alocado para o processo associado."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Instrui o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente aguardar indefinidamente para o processo associado sair."
  remarks: "WaitForExit faz com que o thread atual Aguarde até que encerra o processo associado.  Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited>       Esse método instrui o <xref:System.Diagnostics.Process>componente aguardar um período infinito para os processo e manipuladores de eventos sair.</xref:System.Diagnostics.Process> Isso pode causar um aplicativo pare de responder. Por exemplo, se você chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A>para um processo que tenha uma interface de usuário, a solicitação para o sistema operacional para encerrar o processo associado pode não ser manipulada se o processo é gravado nunca insira seu loop de mensagem.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > No [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versões anteriores, a sobrecarga de WaitForExit aguardou <xref:System.Int32.MaxValue>milissegundos (aproximadamente 24 dias), não indefinidamente.</xref:System.Int32.MaxValue> Além disso, as versões anteriores não aguardou os manipuladores de eventos sair se completa <xref:System.Int32.MaxValue>tempo foi atingido.</xref:System.Int32.MaxValue>       Essa sobrecarga garante que todo o processamento foi concluída, incluindo a manipulação de eventos assíncronos para a saída redirecionada do padrão. Você deve usar essa sobrecarga após uma chamada para o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono de sobrecargas.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Quando um processo associado existe (ou seja, quando está desligado, o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram WaitForExit. O <xref:System.Diagnostics.Process>componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A>ao processo encerrado.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A>propriedade do componente não aponta para um recurso existente do processo.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process>componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória até que o <xref:System.Diagnostics.Process>componente especificamente libera os recursos.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A>para uma <xref:System.Diagnostics.Process>instância, chamada <xref:System.Diagnostics.Process.Close%2A>quando o processo associado foi finalizado e você não precisa de qualquer informação administrativa sobre o proprietário.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>libera a memória alocada para o processo encerrado.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível acessar a configuração de espera."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nenhum processo <> </> *> tiver sido definido e uma <> </> *> do qual o <xref:System.Diagnostics.Process.Id*>pode ser determinada propriedade não existe.</xref:System.Diagnostics.Process.Id*>       - ou - não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto.       - ou - você está tentando chamar WaitForExit para um processo que está em execução em um computador remoto. Este método está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Instrui o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para aguardar o número especificado de milissegundos para o processo associado sair."
  remarks: "WaitForExit faz com que o thread atual Aguarde até que encerra o processo associado. Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o <xref:System.Diagnostics.Process.Exited>evento.</xref:System.Diagnostics.Process.Exited>       Esse método instrui o <xref:System.Diagnostics.Process>componente aguardar uma quantidade finita de tempo para o processo sair.</xref:System.Diagnostics.Process> Se o processo associado não sair no final do intervalo de porque a solicitação para encerrar for negada, `false` é retornado ao procedimento de chamada. Você pode especificar um número negativo (<xref:System.Threading.Timeout.Infinite>) para `milliseconds`, e WaitForExit irão se comportar o mesmo que o <xref:System.Diagnostics.Process.WaitForExit>sobrecarregar.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Se você passar 0 (zero) para o método, ele retorna `true` somente se o processo já terminou; caso contrário, ele retorna imediatamente `false`.      > [!NOTE] > No [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versões anteriores, se `milliseconds` foi -1, o WaitForExit sobrecarga aguardou <xref:System.Int32.MaxValue>milissegundos (aproximadamente 24 dias), não indefinidamente.</xref:System.Int32.MaxValue>       Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando este método retorna. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não utiliza nenhum parâmetro após o recebimento um `true` dessa sobrecarga.</xref:System.Diagnostics.Process.WaitForExit> Para ajudar a garantir que o <xref:System.Diagnostics.Process.Exited>evento é manipulado corretamente em aplicativos de formulários do Windows, defina o <xref:System.Diagnostics.Process.SynchronizingObject%2A>propriedade.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Quando um processo associado for encerrado (desligar o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram WaitForExit. O <xref:System.Diagnostics.Process>componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A>ao processo encerrado.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A>propriedade do componente não aponta para um recurso existente do processo.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process>componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória até que o <xref:System.Diagnostics.Process>componente especificamente libera os recursos.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A>para uma <xref:System.Diagnostics.Process>instância, chamada <xref:System.Diagnostics.Process.Close%2A>quando o processo associado foi finalizado e você não precisa de qualquer informação administrativa sobre o proprietário.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>libera a memória alocada para o processo encerrado.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "A quantidade de tempo, em milissegundos, para aguardar o processo associado sair. O máximo é o maior valor possível de um inteiro de 32 bits que representa o infinito para o sistema operacional."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado foi encerrado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível acessar a configuração de espera."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nenhum processo <> </> *> tiver sido definido e uma <> </> *> do qual o <xref:System.Diagnostics.Process.Id*>pode ser determinada propriedade não existe.</xref:System.Diagnostics.Process.Id*>       - ou - não há nenhum processo associado a esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto.       - ou - você está tentando chamar WaitForExit para um processo que está em execução em um computador remoto. Este método está disponível somente para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Faz com que o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente aguardar indefinidamente para o processo associado ao estado ocioso. Essa sobrecarga só se aplica a processos com uma interface do usuário e, portanto, um loop de mensagem."
  remarks: "Use WaitForInputIdle para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.       Se um processo não tem um loop de mensagem, WaitForInputIdle lança um <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A sobrecarga de WaitForInputIdle instrui o <xref:System.Diagnostics.Process>componente aguardar indefinidamente para o processo de ficar ocioso no loop de mensagem.</xref:System.Diagnostics.Process> Essa instrução pode fazer com que um aplicativo pare de responder. Por exemplo, se o processo for gravado sempre sair seu loop de mensagem imediatamente, como o fragmento de código `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado foi atingido um estado ocioso."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem uma interface gráfica.       - ou - ocorreu um erro desconhecido. O processo não pôde entrar em um estado ocioso.       - ou - o processo já foi encerrado.       - ou - nenhum processo está associado a essa <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Faz com que o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para aguardar o número especificado de milissegundos para o processo associado ao estado ocioso. Essa sobrecarga só se aplica a processos com uma interface do usuário e, portanto, um loop de mensagem."
  remarks: "Use WaitForInputIdle para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.       Se um processo não tem um loop de mensagem, WaitForInputIdle lança um <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A sobrecarga de WaitForInputIdle instrui o <xref:System.Diagnostics.Process>componente aguardar uma quantidade finita de tempo para o processo de ficar ocioso no loop de mensagem.</xref:System.Diagnostics.Process> Se o processo associado não ficou ocioso até o final do intervalo de porque o loop ainda está processando mensagens, `false` é retornado ao procedimento de chamada.       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Um valor de 1 a <xref:System.Int32>que especifica a quantidade de tempo, em milissegundos, para aguardar o processo associado para ficar ocioso.</xref:System.Int32> Um valor de 0 especifica um retorno imediato, e um valor de -1 especifica uma espera infinita."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado foi atingido um estado ocioso; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem uma interface gráfica.       - ou - ocorreu um erro desconhecido. O processo não pôde entrar em um estado ocioso.       - ou - o processo já foi encerrado.       - ou - nenhum processo está associado a essa <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o uso de memória física do processo associado, em bytes."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo os módulos de processo e as bibliotecas do sistema."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "A quantidade total de memória física o processo associado está usando, em bytes."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória física, em bytes, alocados para o processo associado."
  remarks: "O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.       O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções em módulos de processo e as bibliotecas do sistema.       Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **conjunto de trabalho** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória física, em bytes, alocado para o processo associado."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
