### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "O <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> módulo contém os procedimentos usados para executar operações de arquivo, diretório ou pasta e sistema. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho nas operações de e/s de arquivo que usar o <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> módulo. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Este módulo oferece suporte a palavras-chave de linguagem Visual Basic e membros da biblioteca em tempo de execução que acessam arquivos e pastas."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera o diretório atual ou a pasta. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que o <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>função. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "O `ChDir` função altera o diretório padrão, mas não a unidade padrão. Por exemplo, se a unidade padrão é C, a instrução a seguir altera o diretório padrão na unidade D, mas C permanece a unidade padrão: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] você pode tornar relativo alterações de diretório é, digitando dois pontos, da seguinte maneira: [!code-vb [40 VbVbalrCatRef](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > o `ChDir` função requer permissão de código não gerenciado, o que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> expressão que identifica o diretório ou pasta se torna o novo diretório padrão ou a pasta. `Path`pode incluir a unidade. Se nenhuma unidade for especificada, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> altera o diretório padrão ou uma pasta na unidade atual."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>está vazio."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Unidade inválida for especificada, ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera a unidade atual."
  remarks: "O `ChDrive` função requer permissão de código não gerenciado, o que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e [permissões de acesso do código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Obrigatório. Expressão de cadeia de caracteres que especifica uma unidade existente. Se você fornecer uma cadeia de caracteres de comprimento zero (&quot;&quot;), a unidade atual não é alterado. Se o `Drive` argumento é uma cadeia de caracteres de vários caracteres, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> usa somente a primeira letra."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Unidade inválida for especificada, ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera a unidade atual."
  remarks: "O `ChDrive` função requer permissão de código não gerenciado, o que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e [permissões de acesso do código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Obrigatório. Expressão de cadeia de caracteres que especifica uma unidade existente. Se você fornecer uma cadeia de caracteres de comprimento zero (&quot;&quot;), a unidade atual não é alterado. Se o `Drive` argumento é uma cadeia de caracteres de vários caracteres, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> usa somente a primeira letra."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Unidade inválida for especificada, ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna uma cadeia de caracteres que representa o caminho atual. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> proporciona maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia de caracteres que representa o caminho atual."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna uma cadeia de caracteres que representa o caminho atual. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> proporciona maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Opcional. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>expressão que especifica uma unidade existente. Se nenhuma unidade for especificada, ou se `Drive` é uma cadeia de caracteres de comprimento zero (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> retorna o caminho para a unidade atual."
    return:
      type: System.String
      description: "Uma cadeia de caracteres que representa o caminho atual."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna uma cadeia de caracteres que representa o nome de arquivo, diretório ou pasta que corresponde a um padrão específico ou atributo de arquivo ou o rótulo do volume de uma unidade. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> fornece melhor produtividade e desempenho em operações de e/s de arquivo que o <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "O `Dir` função oferece suporte ao uso de vários caracteres (`*`) e de caractere único (`?`) curingas para especificar vários arquivos.       `VbVolume`Retorna o rótulo do volume para a unidade em vez de um nome de arquivo específico.       Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função. Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.      > [!IMPORTANT] > Seja executado corretamente, o `Dir` função requer o <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida ao código em execução.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       O `Attributes` valores de enumeração de argumento são os seguintes: | | |   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbnormal`| O padrão. Especifica arquivos sem atributos. |   | `ReadOnly`|`vbReadOnly`| Especifica arquivos somente leitura e também arquivos sem atributos. |   | `Hidden`|`vbHidden`| Especifica arquivos ocultos e também arquivos sem atributos. |   | `System`|`vbSystem`| Especifica os arquivos do sistema e arquivos sem atributos. |   | `Volume`|`vbVolume`| Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado. |   | `Directory`|`vbDirectory`| Especifica diretórios ou pastas e também arquivos sem atributos. |   | `Archive`|`vbArchive`| Arquivo foi alterado desde o último backup. |   | `Alias`|`vbAlias`| Arquivo tem um nome diferente. |      > [!NOTE] > Essas enumerações são especificadas pela linguagem Visual Basic e pode ser usadas em qualquer lugar no seu código em vez dos valores reais."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia de caracteres que representa o nome de arquivo, diretório ou pasta que corresponde a um padrão específico ou atributo de arquivo ou o rótulo do volume de uma unidade."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna uma cadeia de caracteres que representa o nome de arquivo, diretório ou pasta que corresponde a um padrão específico ou atributo de arquivo ou o rótulo do volume de uma unidade. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> fornece melhor produtividade e desempenho em operações de e/s de arquivo que o <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "O `Dir` função oferece suporte ao uso de vários caracteres (`*`) e de caractere único (`?`) curingas para especificar vários arquivos.       `VbVolume`Retorna o rótulo do volume para a unidade em vez de um nome de arquivo específico.       Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função. Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.      > [!IMPORTANT] > Seja executado corretamente, o `Dir` função requer o <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida ao código em execução.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       O `Attributes` valores de enumeração de argumento são os seguintes: | | |   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbnormal`| O padrão. Especifica os arquivos que não apresentam atributos. |   | `ReadOnly`|`vbReadOnly`| Especifica arquivos somente leitura, além de arquivos que não apresentam atributos. |   | `Hidden`|`vbHidden`| Especifica arquivos ocultos, além de arquivos que não apresentam atributos. |   | `System`|`vbSystem`| Especifica os arquivos do sistema, além de arquivos que não apresentam atributos. |   | `Volume`|`vbVolume`| Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado. |   | `Directory`|`vbDirectory`| Especifica diretórios ou pastas, além de arquivos que não apresentam atributos. |   | `Archive`|`vbArchive`| Arquivo foi alterado desde o último backup. |   | `Alias`|`vbAlias`| Arquivo tem um nome diferente. |      > [!NOTE] > Essas enumerações são especificadas pela linguagem Visual Basic e pode ser usadas em qualquer lugar no seu código no lugar dos valores reais."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Opcional. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de arquivo, nome de diretório ou pasta ou rótulo de volume da unidade. Uma cadeia de caracteres de comprimento zero (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) será retornado se `PathName` não foi encontrado."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Opcional. Enumeração ou expressão numérica cujo valor Especifica atributos de arquivo. Se omitido, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> retorna arquivos que correspondem `PathName` mas não ter nenhum atributo."
    return:
      type: System.String
      description: "Uma cadeia de caracteres que representa o nome de arquivo, diretório ou pasta que corresponde a um padrão específico ou atributo de arquivo ou o rótulo do volume de uma unidade."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um valor booliano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando o final de um arquivo aberto para <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> sequenciais ou <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> foi atingido."
  remarks: "Use `EOF` para evitar o erro gerado pela tentativa de obter entrada passou do final de um arquivo.       O `EOF` função retorna `False` até o final do arquivo foi atingido. Com arquivos abertos para `Random` ou `Binary` acesso, `EOF` retorna `False` até que a última execução `FileGet` função é não é possível ler um registro inteiro.       Com arquivos abertos para `Binary` acesso, a tentativa de ler o arquivo usando o `Input` funcionar até `EOF` retorna `True` gera um erro. Use o `LOF` e `Loc` funções, em vez de `EOF` ao ler arquivos binários com `Input`, ou use `Get` ao usar o `EOF` função. Com arquivos abertos para `Output`, `EOF` sempre retorna `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém qualquer número de arquivo válido."
    return:
      type: System.Boolean
      description: "Retorna um valor booliano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando o final de um arquivo aberto para <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> sequenciais ou <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> foi atingido."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> fornece melhor produtividade e desempenho em operações de e/s de arquivo que o <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Essa função retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando o `FileOpen` função."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Qualquer número de arquivo válido."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "Os seguintes valores de enumeração indicam o modo de acesso do arquivo:       <table><tbody><tr><td> Valor       </td><td> Modo       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Conclui a entrada/saída (e/s) para um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>fornece maior produtividade e desempenho em operações de e/s de arquivo. Consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> para obter mais informações."
  remarks: "O `FileClose` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [como: ler texto de arquivos com um StreamReader](~/add/includes/ajax-current-ext-md.md),[como: gravar texto em arquivos com um StreamWriter](~/add/includes/ajax-current-ext-md.md), e [passo a passo: Manipulando arquivos e diretórios no Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se você omitir `FileNumbers`, todos os arquivos ativos abertos pelo `FileOpen` função estão fechados.       Quando você fechar arquivos que foram abertos para `Output` ou `Append`, o buffer final da saída é gravado no buffer de sistema operacional para esse arquivo. Todos os buffers espaço associado fechado arquivo seja liberado.       Quando o `FileClose` função é executada, a associação de um arquivo com o arquivo de número termina."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Opcional. Matriz de parâmetro de 0 ou mais canais a ser fechado."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Copia um arquivo. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> proporciona maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Se você tentar usar o `FileCopy` de função em um arquivo aberto, ocorrerá um erro.       `FileCopy`requer confiança total para trabalhar na unidade local."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o nome do arquivo a ser copiado. `Source`pode incluir o diretório ou a pasta e a unidade do arquivo de origem."
    - id: Destination
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o nome do arquivo de destino. `Destination`pode incluir o diretório ou a pasta e a unidade do arquivo de destino."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>ou <code>Destination</code> é inválido ou não especificado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Arquivo já está aberto."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Arquivo não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> valor que indica a data e hora de um arquivo foi gravado. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de arquivo. `PathName`pode incluir o diretório ou pasta e a unidade."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>valor que indica a data e a hora de um arquivo foi criado ou modificado pela última vez."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>é inválido ou contém caracteres curinga."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Arquivo de destino não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Boolean
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Byte
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Char
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.DateTime
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Decimal
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Double
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int16
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int32
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int64
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Single
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.ValueType
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.String
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o comprimento. O padrão é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Array
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao escrever uma matriz. Especifica se a matriz é deve ser tratada como dinâmica e se é necessário um descritor de matriz que descreve o tamanho e limites da matriz."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o comprimento. O padrão é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo de disco aberta em uma variável.  O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Object
      description: "Obrigatório. Nome de variável válido para o qual os dados são lidos."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica o comprimento de um arquivo em bytes. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Se o arquivo especificado estiver aberto quando o `FileLen` função é chamada, o valor retornado representa o tamanho do arquivo no momento em que ele foi aberto.      > [!NOTE] > Para obter o comprimento atual de um arquivo aberto, use o `LOF` função."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um arquivo. `PathName`pode incluir o diretório ou pasta e a unidade."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>valor que especifica o comprimento de um arquivo em bytes."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Arquivo não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Abre um arquivo de entrada ou saída. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `FileOpen` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Você deve abrir um arquivo antes de qualquer operação de e/s pode ser executada nela. `FileOpen`aloca um buffer de e/s para o arquivo e determina o modo de acesso para usar com o buffer.      > [!IMPORTANT] > Ao gravar um arquivo, um aplicativo pode ter que criar um arquivo, se o arquivo ao qual ele está tentando gravar não existe. Para fazer isso, ele precisa de permissão para o diretório no qual o arquivo será criado. No entanto, se o arquivo especificado por `FileName` existir, o aplicativo precisa `Write` permissão somente para o próprio arquivo. Sempre que possível, para ajudar a melhorar a segurança, crie o arquivo durante a implantação e conceder `Write` permissão para esse arquivo apenas, em vez de todo o diretório. Para ajudar a melhorar a segurança, grave dados em pastas de usuário em vez de para o diretório raiz ou o diretório de arquivos de programa.       Para abrir o canal pode ser encontrado usando o `FreeFile()` função.      > [!IMPORTANT] > O `FileOpen` função requer `Read` acessar a partir do `FileIOPermissionAccess` enumeração, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido. Use o <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> função para obter o próximo número de arquivos disponíveis."
    - id: FileName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de arquivo — pode incluir o diretório ou pasta e a unidade."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Obrigatório. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Opcional. Enumeração especificando as operações permitidas no arquivo aberto: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. O padrão será a <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Opcional. Enumeração especificando as operações não permitidas no arquivo aberto por outros processos: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, e <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. O padrão será a <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Opcional. Número menor ou igual a 32.767 (bytes). Para arquivos abertos para acesso aleatório, esse valor é o comprimento do registro. Para arquivos sequenciais, esse valor é o número de caracteres armazenados em buffer."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Comprimento do registro é negativo (e não é igual a -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>já está aberto, ou <code>FileName</code> é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen`função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Boolean
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Byte
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Char
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.DateTime
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Decimal
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Double
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o`VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int16
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int32
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int64
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen`função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Single
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no`RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.ValueType
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Object
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Object
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.String
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de comprimento de cadeia de caracteres de dois bytes para a cadeia de caracteres para o arquivo. O padrão é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePut` normalmente é lido de um arquivo usando `FileGet`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` de função ou apontado pela última `Seek` função é gravada.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePut`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você deve fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Porque a quantidade de dados não pode ser determinada com certeza, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz, você pode escolher se deseja ou não gravar um descritor para o tamanho e dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. Visual Basic 2005 tem como padrão não gravar o descritor. Para gravar o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, você precisa corresponder a maneira que a matriz será lida; Se ele será lida com o descritor, você precisa gravar o descritor. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessitará de 218 bytes quando a matriz é gravada no disco.           [!code-vb[VbVbalrCatRef º&43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava somente os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior ou igual ao comprimento dos dados que estão sendo gravados.      - `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto se não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres nas estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.          > [!NOTE] > Campos que têm mais bytes do que o especificado pela cadeia de caracteres de `VBFixedString` atributo são truncados quando gravados em disco, # # modo binário para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo diferem das regras do `Random` modo: - o `RecordLength` cláusula de `FileOpen` função não tem nenhum efeito. `FilePut`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros.      -Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava somente os dados. Nenhum descritor é escrito.      - `FilePut` grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados for igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir gravam 11 bytes no arquivo número 1: [!code-vb [VbVbalrCatRef º 44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - gravação para um arquivo usando o `FilePut` função requer `Write` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Array
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao escrever uma matriz. Especifica se a matriz deve ser tratada como dinâmica e se deve gravar um descritor de matriz para a cadeia de caracteres que descreve o comprimento."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de comprimento de cadeia de caracteres de dois bytes para a cadeia de caracteres para o arquivo. O padrão é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; não é igual a -1 e 1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados de uma variável para um arquivo de disco.  O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `FilePutObject` função é usada em vez de `FilePut` para evitar ambiguidades no tempo de compilação se tipo `Object` é transmitido em vez de outro tipo, como `Integer`, `Long`, `Short`e assim por diante.       `FilePutObject`gravações e leituras de descritores que descrevem o objeto. Se você pretende gravar o `Variant` tipo `FilePutObject` é necessária. Em caso de dúvida, se você estiver usando um objeto para o segundo parâmetro, é recomendável que você sempre use `FilePutObject` e `FileGetObject`.       `FilePutObject`só é válido em `Random` e `Binary` modo.       Dados gravados com `FilePutObject` normalmente é lido de um arquivo usando `FileGetObject`.       O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, `FilePutObject` grava o próximo registro ou byte após a última `FileGetObject` ou `FilePutObject` função (ou o registro ou byte apontado pela última `Seek` função).       O `StringIsFixedLength` argumento controla se a função interpreta cadeias de caracteres como comprimento fixo ou variável. `FilePutObject`grava o comprimento do descritor quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePutObject`, você deve fazer o mesmo com `FileGetObject`, e você deve também Certifique-se de que a cadeia de caracteres é inicializada com o tamanho esperado.      ## Aleatório para o modo de arquivos abertos no `Random` modo, as seguintes regras se aplicam: - se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função `FilePutObject` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. A quantidade de dados não pode ser determinada com precisão, geralmente é recomendável ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior do que o comprimento especificado no `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.      -Se a variável que está sendo gravada for um objeto que contém um tipo numérico, `FilePutObject` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePutObject` grava seis bytes: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.      -Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres, `FilePutObject` grava um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro o `FileOpen` função deve ser pelo menos quatro bytes maior do que o comprimento real da cadeia de caracteres. Se você quiser colocar uma cadeia de caracteres sem o descritor, deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o comprimento correto.      -Se a variável que está sendo gravada for uma matriz e, em seguida, o comprimento do registro especificado pelo `RecordLength` cláusula de `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para gravar os dados de matriz e o descritor de matriz. O descritor especifica a classificação de matriz, o tamanho e o limite inferior de cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions).      ## Arquivos binários para o modo aberto no `Binary` modo, todos os a `Random` aplicarem regras de modo, exceto: - o `RecordLength` cláusula o `FileOpen` função não tem nenhum efeito. `FilePutObject`grava todas as variáveis no disco continuamente, isto é, sem preenchimento entre os registros."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Object
      description: "Obrigatório. Nome de variável válido que contém os dados gravados no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registro (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> arquivos de modo) ou o número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> arquivos de modo) no qual a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Atribui um comprimento de linha de saída para um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: RecordWidth
      type: System.Int32
      description: "Obrigatório. Expressão numérica no intervalo 0 – 255, inclusive, que indica o número de caracteres são exibidos em uma linha antes de uma nova linha é iniciada. Se `RecordWidth` for igual a 0, não há nenhum limite para o comprimento de uma linha. O valor padrão para `RecordWidth` é 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valor que representa o próximo número de arquivo disponível para uso pelo <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  remarks: "Use `FreeFile` para fornecer um número de arquivos que já não está sendo usado."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Retorna um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valor que representa o próximo número de arquivo disponível para uso pelo <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Mais de 255 arquivos estão em uso."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> valor que representa os atributos de arquivo, diretório ou pasta. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Para determinar quais atributos estão definidos, use o `And` operador para executar uma comparação bit a bit do valor retornado pelo `GetAttr` função e o valor do atributo de arquivo individual desejado. Se o resultado não for zero, esse atributo é definido para o arquivo nomeado. Por exemplo, o valor de retorno dos seguintes `And` expressão é zero se o `Archive` atributo não está definido: ```vb#   Result = GetAttr(FName) And vbArchive   ``` um valor diferente de zero será retornado se o `Archive` atributo está definido."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de arquivo, diretório ou pasta. `PathName`pode incluir o diretório ou pasta e a unidade."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "O valor retornado por <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> é a soma dos valores de enumeração a seguir:       <table><tbody><tr><td> Valor       </td><td> Descrição das constantes       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normal.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Somente leitura.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Oculto.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Arquivo do sistema.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Diretório ou pasta.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Arquivo foi alterado desde o último backup.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>Arquivo tem um nome diferente.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Essas enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser usados em qualquer lugar no seu código no lugar dos valores reais.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>é inválido ou contém caracteres curinga."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Arquivo de destino não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Boolean
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Byte
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Char
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.DateTime
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Decimal
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Double
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int16
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, desde que a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int32
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Int64
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Object
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.Single
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` geralmente são gravados em um arquivo usando `Write`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic 2005.       Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Que delimita vírgula ou linha em branco | Vazio |   | NULL #| `DBNull`|   | # TRUE ou FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representada pela expressão |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se você atingir o final do arquivo enquanto você estiver inserindo um item de dados, a entrada é interrompida e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se você entrada 3,14159, ele retorna somente 3, como a vírgula é tratada como um separador variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Value
      type: System.String
      description: "Obrigatório. Variável que é atribuída aos valores lidos no arquivo — não pode ser uma variável de matriz ou objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valor que contém caracteres de um arquivo aberto no <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modo. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `InputString` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com o `InputString` função geralmente é gravada em um arquivo usando `Print` ou `FilePut`. Use esta função somente com arquivos abertos em `Input` ou `Binary` modo.       Ao contrário de `Input` função, o `InputString` função retorna todos os caracteres que lê. Isso inclui vírgulas, retornos de carro, alimentações de linha, as aspas e espaços à esquerda.       Com arquivos abertos para `Binary` acessar, uma tentativa de ler o arquivo usando o `InputString` funcionar até `EOF` retorna `True` gera um erro. Use o `LOF` e `Loc` funções, em vez de `EOF` ao ler arquivos binários usando `InputString`, ou use `FileGet` quando você usa o `EOF` função.      > [!NOTE] > Durante a leitura de arquivos, não faça decisões de segurança sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: CharCount
      type: System.Int32
      description: "Obrigatório. Qualquer expressão numérica válida que especifica o número de caracteres a serem lidos."
    return:
      type: System.String
      description: "Retorna <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valor que contém caracteres de um arquivo aberto no <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modo. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Exclui os arquivos de um disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`oferece suporte ao uso de vários caracteres (`*`) e de caractere único (`?`) curingas para especificar vários arquivos.       **Observação de segurança** para executar, o `Kill` função requer `Read` e `PathDiscovery` sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida ao código em execução.</xref:System.Security.Permissions.FileIOPermission> Para obter mais informações, consulte <xref:System.Security.SecurityException> [permissões de acesso do código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um ou mais nomes de arquivo a ser excluído. `PathName`pode incluir o diretório ou pasta e a unidade."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Abra o arquivo de destino (s)."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Arquivos de destino não encontrados."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Permissão negada."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê uma única linha de um arquivo sequencial aberto e atribui a um <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variável."
  remarks: "O `LineInput` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `LineInput` geralmente são gravados em um arquivo usando `Print`.      > [!IMPORTANT] > Durante a leitura de arquivos, não faça decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1. vb pode não ser um arquivo de origem do Visual Basic.       O `LineInput` função lê a partir de um caractere de um arquivo por vez até encontrar um retorno de carro (`Chr(`13`)`) ou retorno/alimentação de linha de carro (`Chr(`13`)` + `Chr(`10`)`) sequência. Sequências de feed de retorno de linha de carro são ignoradas em vez de acrescentado à cadeia de caracteres.      > [!IMPORTANT] > Ler de um arquivo usando o `LineInput` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    return:
      type: System.String
      description: "Lê uma única linha de um arquivo sequencial aberto e atribui a um <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variável."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Final do arquivo atingido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica a posição de leitura/gravação atual em um arquivo aberto."
  remarks: "O `Loc` função é baseado em zero; usá-la para recuperar o primeiro byte em um arquivo, retornará 0.       O `Loc` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       A seguir descreve o valor de retorno para cada modo de acesso do arquivo: | | |   |-|-|   | Modo | Valor de retorno |   | `Random`| Número do último registro lido ou gravado no arquivo. |   | `Sequential`| Posição atual de bytes no arquivo dividida por 128. No entanto, a informações retornadas por `Loc` para arquivos sequenciais não é usada nem requerida. |   | `Binary`| Posição do último byte lido ou gravado. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> número de arquivos."
    return:
      type: System.Int64
      description: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica a posição de leitura/gravação atual em um arquivo aberto."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Record
      type: System.Int64
      description: "Opcional. Número da única gravação ou byte para bloquear ou desbloquear"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: FromRecord
      type: System.Int64
      description: "Opcional. Número do primeiro registro ou byte para bloquear ou desbloquear."
    - id: ToRecord
      type: System.Int64
      description: "Opcional. Número do último registro ou byte para bloquear ou desbloquear."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> que representa o tamanho, em bytes, de um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Use o `FileLen` função para obter o comprimento de um arquivo que não está aberto."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de arquivo válido."
    return:
      type: System.Int64
      description: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> que representa o tamanho, em bytes, de um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Cria um novo diretório. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Esta função cria um novo diretório."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que identifica o diretório a ser criado. O `Path` pode incluir a unidade. Se nenhuma unidade for especificada, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> cria um novo diretório na unidade atual."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>não foi especificado ou está vazia."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Permissão negada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Já existe um diretório."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados formatados para exibição para um arquivo sequencial."
  remarks: "O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`não inclui uma alimentação de linha no final de uma linha; No entanto, `PrintLine` incluem uma alimentação de linha.       Dados gravados com `Print` normalmente é lido de um arquivo usando `LineInput` ou `Input`.       Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída. Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.       Para `Boolean` dados, `True` ou `False` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.       Dados de data são gravados para o arquivo usando o formato de data abreviada padrão reconhecido pelo seu sistema. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravado no arquivo.       Nada é gravado no arquivo se `Output` dados estão vazios. No entanto, se `Output` dados da lista são `DBNull`, `Null` é gravado no arquivo.       Para `Error` dados, a saída é exibida como `Error errorcode`. O `Error` palavra-chave não é traduzida, independentemente da localidade.       Todos os dados gravados no arquivo usando `Print` é de Conhecimento internacional; ou seja, os dados estão formatados corretamente usando o separador decimal adequado. Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.       Gravar em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Zero ou mais delimitada por vírgulas expressões para gravar em um arquivo.       O `Output` configurações de argumento são: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: modo de arquivo é inválido.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` não existe."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados formatados para exibição para um arquivo sequencial."
  remarks: "O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`não inclui uma alimentação de linha no final de uma linha; No entanto,`PrintLine` incluem uma alimentação de linha.       Dados gravados com `Print` normalmente é lido de um arquivo usando `LineInput` ou `Input`.       Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída. Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.       Para `Boolean` dados, `True` ou `False` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.       Dados de data são gravados para o arquivo usando o formato de data abreviada padrão reconhecido pelo sistema. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravado no arquivo.       Nada é gravado no arquivo se `Output` dados estão vazios. No entanto, se `Output` dados da lista são `DBNull`, `Null` é gravado no arquivo.       Para `Error` dados, a saída é exibida como `Error errorcode`. O `Error` palavra-chave não é traduzida, independentemente da localidade.       Todos os dados gravados no arquivo usando `Print` é de Conhecimento internacional; ou seja, os dados estão formatados corretamente usando o separador decimal adequado. Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.       Gravar em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Zero ou mais delimitada por vírgulas expressões para gravar em um arquivo.       O `Output` configurações de argumento são: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: modo de arquivo é inválido.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` não existe."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Renomeia um arquivo de disco ou diretório. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O`Rename` função renomeia um arquivo e a move para um diretório diferente, se necessário. O `Rename` função pode mover um arquivo em unidades, mas ele só pode renomear uma pasta existente quando ambos `NewPath` e `OldPath` estão localizados na mesma unidade. `Rename`não é possível criar um novo arquivo ou diretório.       Usando o `Rename` função em um arquivo aberto produz um erro. Você deve fechar um arquivo aberto antes de renomeá-lo. `Rename`argumentos não podem incluir caracteres curinga de caractere único (?) e de vários caracteres (*).      > [!IMPORTANT] > Ao usar `Rename` para copiar um arquivo de um local desprotegido para um local protegido, o arquivo manterá os direitos menos restritos. Verifique se você não está apresentando um possível risco de segurança."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o local e o nome de arquivo existente. `OldPath`pode incluir o diretório e unidade do arquivo."
    - id: NewPath
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o novo nome de arquivo e o local. `NewPath`pode incluir o diretório e a unidade de local de destino. O nome do arquivo especificado por `NewPath` não pode já existir."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Caminho é inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>arquivo não existe."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não é possível renomear com outro dispositivo."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Fecha todos os arquivos abertos com o uso do disco a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Reset` função fecha todos os arquivos ativos abertos pelo `FileOpen` de função e tem a mesma função `FileClose()` sem parâmetros."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Remove um diretório existente. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Ocorrerá um erro se você tentar usar `RmDir` em um diretório que contém os arquivos. Use o `Kill` função para excluir todos os arquivos antes de tentar remover um diretório."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que identifica o diretório ou a pasta a ser removido. `Path`pode incluir a unidade. Se nenhuma unidade for especificada, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> remove a pasta na unidade atual."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>não foi especificado ou está vazia."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Diretório de destino contém arquivos."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Diretório não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição de leitura/gravação atual em um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função, ou define a posição para a próxima operação de leitura/gravação em um arquivo aberta usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.       A seguir descreve os valores retornados para cada modo de acesso do arquivo: | | |   |-|-|   | Modo | Valor de retorno |   | `Random`| Número do próximo registro lido ou gravado |   | `Binary`, `Input`, `Output`, `Append`| Posição de byte em que a próxima operação ocorre. O primeiro byte em um arquivo está na posição 1, o segundo byte está na posição 2 e assim por diante. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de arquivo válido."
    return:
      type: System.Int64
      description: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição de leitura/gravação atual em um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função, ou define a posição para a próxima operação de leitura/gravação em um arquivo aberta usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retorna um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição de leitura/gravação atual em um arquivo aberto usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função, ou define a posição para a próxima operação de leitura/gravação em um arquivo aberta usando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.       A seguir descreve os valores retornados para cada modo de acesso do arquivo: | | |   |-|-|   | Modo | Valor de retorno |   | `Random`| Número do próximo registro lido ou gravado |   | `Binary`, `Input`, `Output`, `Append`| Posição de byte em que a próxima operação ocorre. O primeiro byte em um arquivo está na posição 1, o segundo byte está na posição 2 e assim por diante. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de arquivo válido."
    - id: Position
      type: System.Int64
      description: "Obrigatório. Número no intervalo de 1 a 2.147.483.647, inclusive, que indica onde a próxima operação leitura/escrita deve ocorrer."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Define informações de atributo para um arquivo. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Ocorrerá um erro de tempo de execução se você tentar definir os atributos de um arquivo aberto.       O `Attributes` valores de enumeração de argumento são os seguintes: | | |   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbNormal`| Normal (padrão). |   | `ReadOnly`|`vbReadOnly`| Somente leitura. |   | `Hidden`|`vbHidden`| Oculto. |   | `System`|`vbSystem`| Arquivo do sistema. |   | `Volume`|`vbVolume`| Rótulo do volume |   | `Directory`|`vbDirectory`| Diretório ou pasta. |   | `Archive`|`vbArchive`| Arquivo foi alterado desde o último backup. |   | `Alias`|`vbAlias`| Arquivo tem um nome diferente. |      > [!NOTE] > Essas enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser usados em qualquer lugar no seu código em vez dos valores reais."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Obrigatório. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de arquivo. `PathName`pode incluir o diretório ou pasta e a unidade."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Obrigatório. Constante ou expressão numérica, cuja soma especifica atributos de arquivo."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>tipo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> função para posicionar a saída."
  remarks: "Se `Count` é menor do que a largura da linha de saída, a próxima posição de impressão imediatamente após o número de espaços impressos. Se`Count` é maior do que a largura da linha de saída, `SPC` calculará a próxima posição de impressão usando a fórmula: `currentprintposition`(+ (`Count``Mod``width`)) por exemplo, se a posição de impressão atual for 24, a largura da linha de saída é 80 e você especificar `SPC(`90`)`, a próxima impressão iniciará na posição 34 (posição de impressão atual + o resto de 90/80). Se a diferença entre a posição de impressão atual e a largura da linha de saída for menor que `Count` (ou `Count` `Mod` *largura*), o `SPC` função vai para o início da próxima linha e gerará espaços iguais a `Count` – (*largura* – *currentprintposition*).      > [!NOTE] > Certificar-se de que as colunas da tabela são suficientes para permitir a amplas letras."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Obrigatório. O número de espaços a serem inseridos antes da exibição ou impressão da próxima expressão em uma lista."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> função para posicionar a saída."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para posicionar a saída."
  remarks: "Se a posição de impressão atual na linha atual é maior do que `Column`, `TAB` ignora para a coluna valor igual a `Column` na próxima linha de saída. Se `Column` é menor que 1, `TAB` move a posição de impressão para coluna 1. Se `Column` é maior do que a largura da linha de saída, `TAB` calculará a próxima posição de impressão usando a fórmula: largura de coluna Mod por exemplo, se *largura* é 80 e você especificar `TAB(`90`)`, a próxima impressão será iniciada na coluna 10 (o resto de 90/80). Se `Column` é menor do que a posição atual de impressão, impressão iniciado na próxima linha na posição de impressão calculada. Se a posição de impressão calculada for maior do que a posição atual de impressão, impressão inicia em calculada imprimir posição na mesma linha.       A posição de impressão mais à esquerda em uma linha de saída é sempre 1. Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.       O `TAB` função também pode ser usada com a `WriteLine` função. Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>ou <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Certificar-se de que as colunas da tabela são grande o suficiente para conter letras amplas."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para posicionar a saída."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para posicionar a saída."
  remarks: "Se a posição de impressão atual na linha atual for maior que `Column`, `TAB` ignora para a coluna valor igual a `Column` na próxima linha de saída. Se `Column` é menor que 1, `TAB` move a posição de impressão para coluna 1. Se `Column` é maior do que a largura da linha de saída, `TAB` calculará a próxima posição de impressão usando a fórmula: largura de coluna Mod por exemplo, se *largura* é 80 e você especificar `TAB(`90`)`, a próxima impressão será iniciada na coluna 10 (o resto de 90/80). Se `Column` é menor do que a posição atual de impressão, impressão iniciado na próxima linha na posição de impressão calculada. Se a posição de impressão calculada for maior que a posição atual de impressão, impressão inicia em calculada imprimir posição na mesma linha.       A posição de impressão mais à esquerda em uma linha de saída é sempre 1. Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.       O `TAB` função também pode ser usada com a `WriteLine` função. Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>ou <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Certificar-se de que as colunas da tabela são grande o suficiente para conter letras amplas."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Opcional. O número da coluna movido para antes da exibição ou impressão da próxima expressão em uma lista. Se omitido, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> move o ponto de inserção para o início da próxima zona de impressão."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Usado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para posicionar a saída."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: Record
      type: System.Int64
      description: "Opcional. Número da única gravação ou byte para bloquear ou desbloquear"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos para todo ou parte de um arquivo aberto usando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> recurso oferece maior produtividade e desempenho em operações de e/s de arquivo que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.       `Lock`e `Unlock` funções são sempre usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.       Se o arquivo foi aberto para entradas ou saídas, sequenciais `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado pelos `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Qualquer número de arquivo válido."
    - id: FromRecord
      type: System.Int64
      description: "Opcional. Número do primeiro registro ou byte para bloquear ou desbloquear."
    - id: ToRecord
      type: System.Int64
      description: "Opcional. Número do último registro ou byte para bloquear ou desbloquear."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados em um arquivo sequencial. Dados gravados com <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> normalmente é lido de um arquivo usando <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se você omitir `Output`, uma linha em branco é impressa no arquivo. Várias expressões podem ser separadas por vírgula.       Ao contrário de `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas, como eles são gravados no arquivo. Você não precisa colocar os delimitadores explícitas na lista. Quando `Write` é usado para gravar dados em um arquivo, somente numérico, `Boolean`, data, null, e `Error` há suporte para formatos de dados. As seguintes suposições universais são seguidas para que os dados podem ser lidos e corretamente interpretados usando `Input`, independentemente da localidade:-dados numéricos são sempre gravados usando o período como o separador decimal.      -Para `Boolean` dados, `#TRUE#` ou `#FALSE#` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.      -Data dados são gravados para o arquivo usando o formato de data universal. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravado no arquivo.      -Nada é gravado no arquivo se `Output` dados estão vazios. No entanto, para dados nulos, `#NULL#` é gravado.      -Para `Error` dados, a saída é exibida como `#ERROR errorcode#`. O `Error` palavra-chave não é convertido, independentemente da localidade.       `WriteLine`Insere um caractere de nova linha (ou seja, um retorno de carro/linha feed, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.       Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou &quot;&quot;. Por exemplo, [!code-vb [VbVbalrCatRef º&63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] retorna uma cadeia de caracteres com o valor de `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Gravar em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressão que contém qualquer número de arquivo válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Uma ou mais delimitada por vírgulas expressões para gravar em um arquivo."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de arquivo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Grava dados em um arquivo sequencial. Dados gravados com <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> normalmente é lido de um arquivo usando <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos legados não, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se você omitir `Output`, uma linha em branco é impressa no arquivo. Várias expressões podem ser separadas por vírgula.       Ao contrário de `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas, como eles são gravados no arquivo. Você não precisa colocar os delimitadores explícitas na lista. Quando `Write` é usado para gravar dados em um arquivo, somente numérico, `Boolean`, data, null, e `Error` há suporte para formatos de dados. As seguintes suposições universais são seguidas para que os dados podem ser lidos e corretamente interpretados usando `Input`, independentemente da localidade:-dados numéricos são sempre gravados usando o período como o separador decimal.      -Para `Boolean` dados, `#TRUE#` ou `#FALSE#` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.      -Data dados são gravados para o arquivo usando o formato de data universal. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravado no arquivo.      -Nada é gravado no arquivo se `Output` dados estão vazios. No entanto, para dados nulos, `#NULL#` é gravado.      -Para `Error` dados, a saída é exibida como `#ERROR errorcode#`. O `Error` palavra-chave não é convertido, independentemente da localidade.       `WriteLine`Insere um caractere de nova linha (ou seja, um retorno de carro/linha feed, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.       Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou &quot;&quot;. Por exemplo, [!code-vb [VbVbalrCatRef º&63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] retorna uma cadeia de caracteres com o valor de `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Gravar em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obrigatório. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressão que contém qualquer número de arquivo válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Uma ou mais delimitada por vírgulas expressões para gravar em um arquivo."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
