### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "Fornece serviços para gerenciar a fila de itens de trabalho para um thread."
  remarks: "O Dispatcher mantém uma fila com prioridade de itens de trabalho para um segmento específico.       Quando um Dispatcher é criado em um thread, ele se torna o Dispatcher único que pode ser associado ao thread, mesmo se o distribuidor é desligado.       Se você tentar obter o <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>para o thread atual e um distribuidor não está associado com o segmento, será criado um Dispatcher.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Um Dispatcher também é criado quando você cria um <xref:System.Windows.Threading.DispatcherObject>.</xref:System.Windows.Threading.DispatcherObject> Se você criar um distribuidor em um thread em segundo plano, certifique-se de desligar o distribuidor antes de encerrar o thread.       Se um Dispatcher está desligado, ele não pode ser reiniciado.       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], um <xref:System.Windows.Threading.DispatcherObject>só pode ser acessado pelo Dispatcher está associado.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que está associado com o distribuidor no [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar o <xref:System.Windows.Controls.ContentControl.Content%2A>propriedade o <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o distribuidor associado a [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila do Dispatcher em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um Dispatcher que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Todos os métodos no distribuidor, com exceção do <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, são free-thread.</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       Objetos que derivam de <xref:System.Windows.Threading.DispatcherObject>têm afinidade de thread.</xref:System.Windows.Threading.DispatcherObject>       Objetos que derivam de <xref:System.Windows.Freezable>são free-thread quando eles estão congelados.</xref:System.Windows.Freezable>  Para obter mais informações, consulte [visão geral de objetos Freezable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado assincronamente com os argumentos especificados no thread que o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "O <xref:System.Windows.Threading.DispatcherOperation>objeto retornado por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser usado de várias maneiras para interagir com o delegado especificado, tais como: - alteração de <xref:System.Windows.Threading.DispatcherPriority>do representante que está pendente execução na fila de eventos.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Removendo o representante da fila de eventos.      -Aguardando o representante retornar.      -Obtendo o valor que retorna o representante após ele é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrono; Portanto, o controle retorna imediatamente para o objeto de chamada depois que ele é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um <xref:System.Windows.Threading.Dispatcher>que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "O representante para um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>é chamado, que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado assíncrona na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Se várias chamadas BeginInvoke são feitas no mesmo <xref:System.Windows.Threading.DispatcherPriority>, elas serão executadas na ordem em que as chamadas feitas.</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Retorna um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser usado para interagir com o delegado quando o representante de eventos é fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objeto retornado por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser usado de várias maneiras para interagir com o delegado especificado, tais como: - alteração de <xref:System.Windows.Threading.DispatcherPriority>do representante que está pendente execução na fila de eventos.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Removendo o representante da fila de eventos.      -Aguardando o representante retornar.      -Obtendo o valor que retorna o representante após ele é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrono; Portanto, o controle retorna imediatamente para o objeto de chamada depois que ele é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um <xref:System.Windows.Threading.Dispatcher>que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "O representante para um método que não requer argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>é chamado, que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é válido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado assincronamente com os argumentos especificados, com a prioridade especificada, no thread que o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "O <xref:System.Windows.Threading.DispatcherOperation>objeto retornado por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser usado de várias maneiras para interagir com o delegado especificado, tais como: - alteração de <xref:System.Windows.Threading.DispatcherPriority>do representante que está pendente execução na fila de eventos.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Removendo o representante da fila de eventos.      -Aguardando o representante retornar.      -Obtendo o valor que retorna o representante após ele é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrono; Portanto, o controle retorna imediatamente para o objeto de chamada depois que ele é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um <xref:System.Windows.Threading.Dispatcher>que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "O representante para um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>é chamado, que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado assíncrona na prioridade especificada e com o argumento especificado no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se nenhum argumento é necessário.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Retorna um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser usado para interagir com o delegado quando o representante de eventos é fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objeto retornado por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser usado de várias maneiras para interagir com o delegado especificado, tais como: - alteração de <xref:System.Windows.Threading.DispatcherPriority>do representante que está pendente execução na fila de eventos.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Removendo o representante da fila de eventos.      -Aguardando o representante retornar.      -Obtendo o valor que retorna o representante após ele é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrono; Portanto, o controle retorna imediatamente para o objeto de chamada depois que ele é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se vários <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>as chamadas são feitas no mesmo <xref:System.Windows.Threading.DispatcherPriority>, elas serão executadas na ordem em que as chamadas feitas.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um <xref:System.Windows.Threading.Dispatcher>que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que usa um argumento, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "O objeto a ser passado como um argumento para o método especificado."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>é chamado, que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é válido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado assíncrona na prioridade especificada e com a matriz de argumentos especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "O `arg` parâmetro pode ser `null` se nenhum argumento é necessário.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Retorna um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser usado para interagir com o delegado quando o representante de eventos é fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objeto retornado por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser usado de várias maneiras para interagir com o delegado especificado, tais como: - alteração de <xref:System.Windows.Threading.DispatcherPriority>do representante que está pendente execução na fila de eventos.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Removendo o representante da fila de eventos.      -Aguardando o representante retornar.      -Obtendo o valor que retorna o representante após ele é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrono; Portanto, o controle retorna imediatamente para o objeto de chamada depois que ele é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Se vários <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>as chamadas são feitas no mesmo <xref:System.Windows.Threading.DispatcherPriority>, elas serão executadas na ordem em que as chamadas feitas.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>for chamado em um <xref:System.Windows.Threading.Dispatcher>que foi desligado, a propriedade status da retornado <xref:System.Windows.Threading.DispatcherOperation>é definida como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa vários argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "O objeto a ser passado como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos a serem passados como argumentos para o método especificado."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>é chamado, que pode ser usado para interagir com o delegado como está aguardando a execução no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>não é uma prioridade válida."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Inicia o desligamento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> assincronamente."
  remarks: "BeginInvokeShutdown exige permissões irrestritas de interface do usuário.       Quando o <xref:System.Windows.Threading.Dispatcher>começa a ser desligada, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>é definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não desligar completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade no qual começar a desligar o dispatcher."
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o thread de chamada é o thread associado a esta <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Somente o <xref:System.Windows.Threading.Dispatcher>que um <xref:System.Windows.Threading.DispatcherObject>é criado na pode acessar o objeto.</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  Use <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>para acessar o objeto de um thread diferente.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       CheckAccess pode ser chamado de qualquer thread.       A diferença entre CheckAccess e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>é CheckAccess retorna um valor booleano que indica se o thread de chamada tem acesso para o <xref:System.Windows.Threading.Dispatcher>e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>lança uma exceção.</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread de chamada é o thread associado a esta <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> para o thread em execução no momento e cria um novo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> se um não estiver associado ao thread."
  remarks: "Se um <xref:System.Windows.Threading.Dispatcher>não está associado com o segmento atual, um novo <xref:System.Windows.Threading.Dispatcher>será criado.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  Isso não é o caso com o <xref:System.Windows.Threading.Dispatcher.FromThread%2A>método.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>retornará `null` se não houver um dispatcher associado ao segmento especificado.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "O distribuidor associado ao segmento atual."
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Desabilita o processamento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila."
  remarks: "Desabilitar o processamento do dispatcher é um método avançado que é destinado para eliminar a chance de reentrância não relacionada.       Os efeitos de desabilitar o processamento são os seguintes:- [!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)] bloqueios não bomba mensagens internamente.      - <xref:System.Windows.Threading.DispatcherFrame>objetos não podem ser enviados por push.</xref:System.Windows.Threading.DispatcherFrame>      -Processamento de mensagens não é permitido.       O <xref:System.Windows.Threading.DispatcherProcessingDisabled>estrutura DisableProcessing retorna quando ele é chamado pode ser usada para reabilitar o processamento do dispatcher.</xref:System.Windows.Threading.DispatcherProcessingDisabled>  Chamando <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>no <xref:System.Windows.Threading.DispatcherProcessingDisabled>estrutura habilita novamente o processamento.</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       DisableProcessing só pode ser chamado no thread de <xref:System.Windows.Threading.Dispatcher>está associado.</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "Uma estrutura usada para habilitar novamente o processamento do dispatcher."
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Solicitações que sair de todos os quadros, incluindo quadros aninhados."
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> para o segmento especificado."
  remarks: "Se um distribuidor não está disponível para o segmento especificado, `null` será retornado.       FromThread não criar um <xref:System.Windows.Threading.Dispatcher>em um thread que não tem um <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>   Um novo <xref:System.Windows.Threading.Dispatcher>é criado em um thread que ainda não tiver um <xref:System.Windows.Threading.Dispatcher>ao tentar obter o <xref:System.Windows.Threading.Dispatcher>usando o <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>propriedade.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "O thread para obter o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> do."
    return:
      type: System.Windows.Threading.Dispatcher
      description: "O dispatcher para <code> thread </code>."
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> terminou de desligar."
  remarks: "Quando o <xref:System.Windows.Threading.Dispatcher>começa a ser desligada, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>é definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerra completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>é gerado e a propriedade HasShutdownFinished está definida como `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o dispatcher concluiu a desligar; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está sendo desligado."
  remarks: "Quando o <xref:System.Windows.Threading.Dispatcher>começa a ser desligada, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>é gerado e HasShutdownStarted é definido como `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não desligar completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> iniciou sendo inativo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém a coleção de conexões que fornecem informações de evento adicionais sobre o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "O <xref:System.Windows.Threading.DispatcherHooks>classe fornece informações de evento adicionais sobre o <xref:System.Windows.Threading.Dispatcher>, como quando o <xref:System.Windows.Threading.Dispatcher>está inativo ou quando uma operação ser concluída.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "Ganchos de associado a esta <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>modo síncrono no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>sincronicamente na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade determina em qual ordem o retorno de chamada especificado é invocado em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado sincronicamente na prioridade especificada no thread no qual o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que não requer argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>sincronicamente na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade determina em qual ordem o retorno de chamada especificado é invocado em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado dentro do período de tempo designado na prioridade especificada com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade máxima de tempo de espera para a operação ser concluída."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado na prioridade especificada com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado na prioridade especificada com o argumento especificado de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que usa um argumento, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado sincronicamente na prioridade especificada e com o valor de tempo limite especificado no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "O representante para um método que não requer argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>sincronicamente na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade determina em qual ordem o retorno de chamada especificado é invocado em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade mínima de tempo de espera para iniciar a operação."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado dentro do período de tempo designado na prioridade especificada com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button> Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa os parâmetros especificados na `args`, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade máxima de tempo de espera para a operação ser concluída."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado na prioridade especificada com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa vários argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado na prioridade especificada com o argumento especificado de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa vários argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado. Isso pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum argumento é necessário."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado na prioridade especificada com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não for necessária.       Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], somente o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode acessar esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread em segundo plano que é será levado do thread da interface do usuário principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado no thread da interface do usuário.</xref:System.Windows.Controls.Button>  Para que o thread em segundo plano acessar a propriedade Content a <xref:System.Windows.Controls.Button>, thread em segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associado ao thread de interface do usuário.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isso é feito por meio de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos de <xref:System.Windows.Threading.Dispatcher>em especificado <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Portanto, controle não retornará para o objeto de chamada até que depois retorna o retorno de chamada.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que usa vários argumentos, que é passado para o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto a ser passado como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos a serem passados como argumentos para o método especificado."
    return:
      type: System.Object
      description: "O valor de retorno de representante que está sendo invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o representante não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual a <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é válido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    return:
      type: TResult
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A ser adicionado."
    return:
      type: TResult
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A ser adicionado."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A ser adicionado."
    return:
      type: TResult
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A ser adicionado."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A ser adicionado."
    - id: timeout
      type: System.TimeSpan
      description: "A ser adicionado."
    return:
      type: TResult
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assincronamente no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após InvokeAsync é chamado, o que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assíncrona na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade determina em qual ordem o retorno de chamada especificado é invocado em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após InvokeAsync é chamado, o que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assíncrona na prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado a ser invocado pelo dispatcher."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade determina em qual ordem o retorno de chamada especificado é invocado em relação a outras operações pendentes no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é retornado imediatamente após InvokeAsync é chamado, o que pode ser usado para interagir com o delegado como está aguardando a execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A ser adicionado."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A ser adicionado."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A ser adicionado."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A ser adicionado."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A ser adicionado."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Inicia o processo de desligamento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> sincronicamente."
  remarks: "InvokeShutdown exige permissões irrestritas de interface do usuário.       Quando o <xref:System.Windows.Threading.Dispatcher>começa a ser desligada, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>é definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não desligar completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Insere um loop de execução."
  remarks: "Um <xref:System.Windows.Threading.DispatcherFrame>representa um loop que processa os itens de trabalho pendentes.</xref:System.Windows.Threading.DispatcherFrame>       O Dispatcher processa a fila de itens de trabalho em um loop.  O loop é conhecido como um quadro.  O loop inicial é iniciado normalmente pelo aplicativo chamando <xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>       PushFrame inserirá um loop representado pelo parâmetro `frame`.  Em cada iteração do loop, o <xref:System.Windows.Threading.Dispatcher>verificará o <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>propriedade o <xref:System.Windows.Threading.DispatcherFrame>classe para determinar se o loop deve continuar ou se deve parar.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>permite que a <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>propriedade a ser definida explicitamente e respeita a <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>propriedade em <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  Isso significa que, quando o <xref:System.Windows.Threading.Dispatcher>começa a fechar, quadros que usam o padrão <xref:System.Windows.Threading.DispatcherFrame>implementação será fechado, que permite aninhados todos os quadros sair.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "O quadro para o distribuidor processar."
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       - ou - processamento do Dispatcher foi desabilitado."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Envia o quadro de execução principal na fila de eventos de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "O <xref:System.Windows.Threading.Dispatcher>processa a fila de eventos em um loop.</xref:System.Windows.Threading.Dispatcher>  O loop é conhecido como um quadro.  O loop inicial é iniciado normalmente pelo aplicativo chamando a execução.       O quadro de execução principal continuará até que o <xref:System.Windows.Threading.Dispatcher>é desligado.</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> termina sendo desligado."
  remarks: "Quando o processo de desligamento de um <xref:System.Windows.Threading.Dispatcher>é iniciado, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>é definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerra completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o evento ShutdownFinished é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> começa a fechar."
  remarks: "Quando o processo de desligamento de um <xref:System.Windows.Threading.Dispatcher>é iniciado, o evento ShutdownStarted é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>é definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerra completamente até que a fila de eventos esvazia.</xref:System.Windows.Threading.Dispatcher>       Quando o Dispatcher termina sendo desligado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Quando começar o processo de desligamento, trabalho pendente itens na fila de anulação."
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o segmento isso <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "O thread."
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando uma exceção de thread é gerada e não capturada durante a execução de um delegado por meio de <> </> *> ou <> </> *>."
  remarks: "Esse evento é gerado quando uma exceção foi lançada durante a execução de um delegado por meio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é não percebida.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Um manipulador pode marcar a exceção tratados, que impedirá que o manipulador de exceção interna do que está sendo chamado.       Manipuladores de eventos para esse evento devem ser escritos com cuidado para evitar criar exceções secundárias e identificar os que ocorrem. É recomendável para evitar a alocação de memória ou fazer qualquer recurso operações intensivas no manipulador.       O <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>evento fornece um meio para não gerar o evento UnhandledException.</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  O <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>é gerado pela primeira vez e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>no <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>é definido como `false`, o evento UnhandledException não será gerado.</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando uma exceção de thread é gerada e não capturada durante a execução de um delegado por meio de <> </> *> ou <> </> *> quando no estágio de filtro."
  remarks: "Esse evento é gerado durante o estágio de filtro para uma exceção gerada durante a execução de um delegado por meio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>e não detectadas.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       A pilha de chamadas não é organizada neste momento (exceção de primeira chance).       Manipuladores de eventos para esse evento devem ser escritos com cuidado para evitar criar exceções secundárias e identificar os que ocorrem.  É recomendável para evitar a alocação de memória ou fazer qualquer recurso operações intensivas no manipulador.       O evento UnhandledExceptionFilter fornece um meio para não gerar o <xref:System.Windows.Threading.Dispatcher.UnhandledException>evento.</xref:System.Windows.Threading.Dispatcher.UnhandledException>  O evento UnhandledExceptionFilter é gerado pela primeira vez e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>no <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>é definido como `false`, o <xref:System.Windows.Threading.Dispatcher.UnhandledException>evento não será gerado.</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o especificado <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref> é uma prioridade válida."
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade para verificar."
    - id: parameterName
      type: System.String
      description: "Uma cadeia de caracteres que será retornada pela exceção que ocorre se a prioridade é inválida."
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>não é válido <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o thread de chamada tem acesso a esse <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Somente o thread de <xref:System.Windows.Threading.Dispatcher>é criado na pode acessar <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       Esse método é público; Portanto, qualquer thread pode verificar se ele tem acesso a <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       A diferença entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>e VerifyAccess é <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>retorna um valor booleano, se o thread de chamada não tem acesso para o <xref:System.Windows.Threading.Dispatcher>e VerifyAccess lança uma exceção.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O thread de chamada não tem acesso a esse <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Cria um objeto aguardável que produz o controle volta para o dispatcher atual e fornece uma oportunidade para o distribuidor processar outros eventos de forma assíncrona."
  remarks: "Esse método fornece uma maneira para que você libere temporariamente o controle de execução para o dispatcher atual para que ele possa fazer outro trabalho, como processar outros eventos. Use o `await`, ou `Await` no Visual Basic, o operador em que o valor de retorno para retornar o controle para o dispatcher atual. Use este método se quiser que seu aplicativo tenha a oportunidade de processar eventos enquanto o aplicativo está fazendo uma grande parte do trabalho no thread da interface do usuário. Por exemplo, você pode usar esse método em um loop de execução longa que atualiza um controle.       Esse método é equivalente a chamar o <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>método e passando <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Um objeto aguardável que produz o controle volta para o dispatcher atual e fornece uma oportunidade para o distribuidor processar outros eventos de forma assíncrona."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Cria um objeto aguardável que produz o controle volta para o dispatcher atual e fornece uma oportunidade para o distribuidor processar outros eventos de forma assíncrona.  O trabalho que ocorre quando o controle retorna para o código aguardando o resultado deste método é agendado com a prioridade especificada."
  remarks: "Esse método fornece uma maneira para que você libere temporariamente o controle de execução para o dispatcher atual para que ele possa fazer outro trabalho, como processar outros eventos. Use o `await`, ou `Await` no Visual Basic, o operador em que o valor de retorno para retornar o controle para o dispatcher atual. Use este método se quiser que seu aplicativo tenha a oportunidade de processar eventos enquanto o aplicativo está fazendo uma grande parte do trabalho no thread da interface do usuário. Por exemplo, você pode usar esse método em um loop de execução longa que atualiza um controle."
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade de agendamento de continuação."
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Um objeto aguardável que produz o controle volta para o dispatcher atual e fornece uma oportunidade para o distribuidor processar outros eventos de forma assíncrona."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
