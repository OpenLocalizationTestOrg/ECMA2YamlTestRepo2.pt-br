### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkElement
  id: FrameworkElement
  children:
  - System.Windows.FrameworkElement.#ctor
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.LogicalChildren
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  langs:
  - csharp
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
  type: Class
  summary: "Fornece um conjunto de nível de framework WPF de propriedades, eventos e métodos para [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] elementos. Essa classe representa a implementação de nível de framework WPF fornecida que se baseia em nível de núcleo do WPF [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] que são definidos pelo <xref href=&quot;System.Windows.UIElement&quot;> </xref>."
  remarks: "FrameworkElement é o ponto de conexão entre classes de elemento de nível de framework do WPF e o conjunto de nível de núcleo do WPF de <xref:System.Windows.UIElement>Serviços de apresentação.</xref:System.Windows.UIElement> Para obter mais informações sobre esses conceitos, consulte [arquitetura WPF](~/add/includes/ajax-current-ext-md.md).       Estende o FrameworkElement <xref:System.Windows.UIElement>e adiciona os seguintes recursos:- **definição de Layout do sistema**: FrameworkElement fornece implementações de nível de framework WPF específicas para determinados métodos que foram definidos como membros virtuais em <xref:System.Windows.UIElement>.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement> Notadamente, FrameworkElement lacra determinadas substituições de layout de nível de núcleo do WPF e fornece um equivalente em nível de framework WPF que classes derivadas deve substituir em vez disso. Por exemplo, FrameworkElement lacra <xref:System.Windows.UIElement.ArrangeCore%2A>, mas fornece <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.UIElement.ArrangeCore%2A> Essas alterações refletem o fato de que em nível de framework WPF há um sistema completo de layout que pode processar qualquer FrameworkElement a classe derivada. No WPF principal níveis, determinados membros que serão estrutura geral [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] solução de layout com base estão em vigor, mas o mecanismo real do sistema de layout não está definido. Para obter mais informações, consulte [Layout](~/add/includes/ajax-current-ext-md.md).      - **Árvore lógica:** geral [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] modelo de programação geralmente é expressa em termos de sendo uma árvore de elementos. Suporte para expressar a árvore de elementos como uma árvore lógica e que acompanha o suporte para a definição de árvore na marcação é implementado no nível de FrameworkElement. No entanto observe FrameworkElement deliberadamente não define um modelo de conteúdo e deixa essa responsabilidade para classes derivadas. Para obter mais informações, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).      - **Eventos de tempo de vida do objeto:** geralmente é útil saber quando um elemento é inicializado (o construtor seja chamado) ou quando o elemento é carregado pela primeira vez em uma árvore lógica. FrameworkElement define vários eventos relacionados a vida útil do objeto que fornecem ganchos útil para operações de lógica que envolvem elementos, como a adição de mais elementos filho. Para obter mais informações, consulte [eventos de tempo de vida do objeto](~/add/includes/ajax-current-ext-md.md).      - **Suporte para associação de dados e referências a recursos dinâmicos:** o suporte de nível de propriedade para associação de dados e recursos é implementado pelo <xref:System.Windows.DependencyProperty>classe e incorporada no sistema de propriedade, mas a capacidade de resolver um valor do membro que é armazenado como um <xref:System.Windows.Expression>(a construção de programação que dá suporte a associação de dados e recursos dinâmicos) é implementada por FrameworkElement.</xref:System.Windows.Expression> </xref:System.Windows.DependencyProperty> Para obter mais informações, consulte [visão geral de associação de dados](~/add/includes/ajax-current-ext-md.md) e [recursos XAML](~/add/includes/ajax-current-ext-md.md).      - **Estilos:** FrameworkElement define o <xref:System.Windows.FrameworkElement.Style%2A>propriedade.</xref:System.Windows.FrameworkElement.Style%2A> No entanto, FrameworkElement ainda não definir o suporte para modelos ou suporte decoradores. Esses recursos são apresentados pelas classes de controle como <xref:System.Windows.Controls.Control>e <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control>      - **Mais suporte de animação:** algum suporte de animação já foi definido no nível de núcleo do WPF, mas FrameworkElement estende isso Implementando <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>e relacionadas a membros.</xref:System.Windows.FrameworkElement.BeginStoryboard%2A>       Como pode ser deduzido da hierarquia de classe, muitos [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] classes derivam de FrameworkElement, diretamente ou por meio de classes de base intermediárias como <xref:System.Windows.Controls.Panel>ou <xref:System.Windows.Controls.Control>.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Panel>       Se você pretende usar FrameworkElement como uma classe base, convém primeiro examinar as classes derivadas existentes. FrameworkElement fornece suporte para vários cenários básicos, mas também não tem um número de recursos que são desejáveis para um &quot;element&quot; no sentido de um bloco de construção que você usa para criar [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] em [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. Por exemplo, um FrameworkElement não define qualquer modelo de conteúdo true; FrameworkElement como uma classe base não define uma propriedade que pode criar [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementos filho. Em particular, talvez você queira examinar <xref:System.Windows.Controls.Control>e <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.FrameworkElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> classe."
  syntax:
    content: public FrameworkElement ();
    parameters: []
  overload: System.Windows.FrameworkElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeight
  id: ActualHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a altura renderizada deste elemento."
  remarks: "Esta propriedade é um valor calculado com base nas outras entradas de altura e o sistema de layout. O valor é definido pelo sistema de layout em si, com base em uma passagem de renderização e pode, portanto, ficar um pouco diferente do valor de conjunto de propriedades, como <xref:System.Windows.FrameworkElement.Height%2A>que são a base das alterações de entrada.</xref:System.Windows.FrameworkElement.Height%2A>       Como ActualHeight é um valor calculado, você deve estar ciente de que podem haver várias ou alterações incrementais a ele como resultado de várias operações pelo sistema de layout. O sistema de layout pode estar Calculando o espaço necessário medidas para elementos filho, as restrições do elemento pai e assim por diante.       Embora você não pode definir essa propriedade da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], você pode basear um <xref:System.Windows.Trigger>em seu valor em um estilo.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualHeight&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ActualHeightProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ActualHeightProperty>"
  example:
  - "The following example displays various height properties.  \n  \n [!code-cs[HeightMinHeightMaxHeight#3](~/add/codesnippet/csharp/Height_MinHeight_MaxHeight_CSharp/Window1.xaml.cs#3)]\n [!code-vb[HeightMinHeightMaxHeight#3](~/add/codesnippet/visualbasic/Height_MinHeight_MaxHeight/Window1.xaml.vb#3)]"
  syntax:
    content: public double ActualHeight { get; }
    return:
      type: System.Double
      description: "Altura do elemento, como um valor em [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é 0 (zero)."
  overload: System.Windows.FrameworkElement.ActualHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  id: ActualHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ActualHeight*>DependencyProperty.</xref:System.Windows.FrameworkElement.ActualHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidth
  id: ActualWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a largura renderizada deste elemento."
  remarks: "Esta propriedade é um valor calculado com base nas outras entradas de largura e o sistema de layout. O valor é definido pelo sistema de layout em si, com base em uma passagem de renderização e pode, portanto, ficar um pouco diferente do valor de conjunto de propriedades, como <xref:System.Windows.FrameworkElement.Width%2A>que são a base das alterações de entrada.</xref:System.Windows.FrameworkElement.Width%2A>       Como ActualWidth é um valor calculado, você deve estar ciente de que podem haver várias ou alterações incrementais a ele como resultado de várias operações pelo sistema de layout. O sistema de layout pode estar Calculando o espaço necessário medidas para elementos filho, as restrições do elemento pai e assim por diante.       Embora você não pode definir essa propriedade da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], você pode basear um <xref:System.Windows.Trigger>em seu valor em um estilo.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualWidth&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ActualWidthProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ActualWidthProperty>"
  example:
  - "The following example displays various width properties.  \n  \n [!code-vb[WidthMinWidthMaxWidth#3](~/add/codesnippet/visualbasic/Width_MinWidth_MaxWidth/Window1.xaml.vb#3)]\n [!code-cs[WidthMinWidthMaxWidth#3](~/add/codesnippet/csharp/Width_MinWidth_MaxWidth_CSharp/Window1.xaml.cs#3)]"
  syntax:
    content: public double ActualWidth { get; }
    return:
      type: System.Double
      description: "Largura do elemento, como um valor em [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é 0 (zero)."
  overload: System.Windows.FrameworkElement.ActualWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  id: ActualWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ActualWidth*>DependencyProperty.</xref:System.Windows.FrameworkElement.ActualWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Adiciona o objeto fornecido para a árvore lógica desse elemento."
  remarks: "Use esse método para a implementação de coleções de objetos que representam os elementos filho de um elemento. Manutenção de coleção para coleções de elementos filho pode ser feita em getters de propriedade ou setters, manipulação de eventos Changed, construtores, ou se os tipos de coleção de classe.       Para autores de controle, manipulando a árvore lógica esse nível não é a prática recomendada, a menos que nenhum dos modelos de conteúdo para classes de controle base disponíveis são apropriados para seu cenário de controle. Considere subclassificação no nível de <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>e <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> Essas classes fornecem um modelo de conteúdo com a imposição de específico de elementos filho de árvore lógica por meio de dedicado [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)], bem como suporte para outros recursos normalmente desejáveis em um [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controle como estilo por meio de modelos. Para obter mais informações sobre como usar <xref:System.Windows.FrameworkElement.LogicalChildren%2A>e AddLogicalChild, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.LogicalChildren%2A>       AddLogicalChild pode lançar uma exceção se for chamado em um momento quando a árvore lógica está sendo iterada por outro processo."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Elemento filho a ser adicionado."
  overload: System.Windows.FrameworkElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ApplyTemplate
  id: ApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Cria a árvore de visual do modelo atual se necessário e retorna um valor que indica se a árvore visual foi reconstruída por esta chamada."
  remarks: "Aplicativos podem chamar este método para garantir que a árvore visual de um elemento está concluída. Essa etapa de garantia pode ser necessária se o código verificar os elementos filho na árvore. Elemento típico para lógica de aplicativos, ApplyTemplate não é necessário chamar, porque os modelos serão aplicados a elementos em um momento apropriado em suas vidas úteis automaticamente.       ApplyTemplate é chamado em cada medida passar pelo sistema de layout de nível de framework do WPF.       <xref:System.Windows.FrameworkElement>classes derivadas podem usar o <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>manipulador da classe a ser notificado de casos em que esse método foi chamado explicitamente ou pelo sistema de layout.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A></xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>é chamado depois que o modelo é gerado e anexado à árvore de lógica de completamente.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>"
  syntax:
    content: public bool ApplyTemplate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os elementos visuais que foram adicionados à árvore; Retorna <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> caso contrário."
  overload: System.Windows.FrameworkElement.ApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Implementa <xref:System.Windows.UIElement.ArrangeCore*>(definido como virtual na <xref href=&quot;System.Windows.UIElement&quot;> </xref>) e lacra a implementação.</xref:System.Windows.UIElement.ArrangeCore*>"
  remarks: "Esse método está lacrado. Para substituir a lógica em seu elemento personalizado especificamente para a etapa de organização de layout do elemento, sua <xref:System.Windows.FrameworkElement>classe derivada deve substituir <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: protected override sealed void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "A área final dentro do pai que esse elemento deve usar para organizar a próprio e seus filhos."
  overload: System.Windows.FrameworkElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituído em uma classe derivada, posiciona elementos filho e determina um tamanho para um <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> classe derivada."
  syntax:
    content: protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);
    parameters:
    - id: finalSize
      type: System.Windows.Size
      description: "A área final dentro do pai que esse elemento deve usar para organizar a próprio e seus filhos."
    return:
      type: System.Windows.Size
      description: "O tamanho real usado."
  overload: System.Windows.FrameworkElement.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia o processo de inicialização para este elemento."
  remarks: "Você pode chamar esse método em elementos individuais se você está ajustando-los de maneiras que ainda não expor ou conectar-se o elemento de qualquer árvore de elementos. Por exemplo, talvez você tenha criado um novo <xref:System.Windows.FrameworkElement>, mas não tiver ainda conectado-lo para qualquer árvore lógica.</xref:System.Windows.FrameworkElement> Ou, a árvore lógica em que o elemento é um elemento filho dentro dele pode não estar conectada a uma janela ou página do aplicativo."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia a sequência de ações que estão contidos no storyboard fornecido."
  remarks: "Cenários mais comuns de animação não usam esse método. Normalmente, você cria o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento na marcação e, em seguida, colocá-los como o <xref:System.Windows.EventTrigger>conteúdo em um elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando disparado pelo evento, em seguida, a animação é executado. A maioria dos aspectos de controle de um <xref:System.Windows.Media.Animation.Storyboard>pode ser solucionado com propriedades que são expostas na marcação.</xref:System.Windows.Media.Animation.Storyboard>       Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha de tempo que estão associados com a animação são removidos assim que a animação atingir o período de &quot;Preenchimento&quot;. Portanto, a animação não pode ser reiniciada após a execução de uma vez. Controlar uma animação também requer que o storyboard um [diretiva X:Name](~/add/includes/ajax-current-ext-md.md) ou ser acessado por referência no código."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia a sequência de ações contidas no storyboard fornecido, com as opções especificadas para o que deve acontecer se a propriedade já é animada."
  remarks: "Cenários mais comuns de animação não usam esse método. Normalmente, você cria o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento na marcação e, em seguida, colocá-los como o <xref:System.Windows.EventTrigger>conteúdo em um elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando disparado pelo evento, em seguida, a animação é executado. A maioria dos aspectos de controle de um <xref:System.Windows.Media.Animation.Storyboard>pode ser solucionado com propriedades que são expostas na marcação.</xref:System.Windows.Media.Animation.Storyboard>       Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha de tempo que estão associados com a animação são removidos assim que a animação atingir o período de &quot;Preenchimento&quot;. Portanto, a animação não pode ser reiniciada após a execução de uma vez. Controlar uma animação também requer que o storyboard um [diretiva X:Name](~/add/includes/ajax-current-ext-md.md) ou ser acessado por referência no código.       Comportamento de entrega pode ser especificado como um atributo de <xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>      ## Usando a compor HandoffBehavior quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock>a uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock>objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de temporização não remove automaticamente os relógios.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Para evitar problemas de desempenho quando você aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior>, você deve remover relógios de composição da propriedade animada após a conclusão.</xref:System.Windows.Media.Animation.HandoffBehavior> Para remover um relógio de várias maneiras: - para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>método do objeto animado.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.      -Para remover um específico <xref:System.Windows.Media.Animation.AnimationClock>em uma lista de relógios, use a <xref:System.Windows.Media.Animation.Clock.Controller%2A>propriedade a <xref:System.Windows.Media.Animation.AnimationClock>recuperar um <xref:System.Windows.Media.Animation.ClockController>em seguida, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A>método de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Isso é feito normalmente o <xref:System.Windows.Media.Animation.Clock.Completed>manipulador de eventos para um clock.</xref:System.Windows.Media.Animation.Clock.Completed> Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A>retorna a propriedade de um relógio filho `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed>evento não será gerado se a duração efetiva do relógio for indefinida.</xref:System.Windows.Media.Animation.Clock.Completed>  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Isso é basicamente um problema para animações em objetos que têm uma vida útil longa.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.       Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Um valor de enumeração que descreve o comportamento a ser usado se uma propriedade descrita no storyboard já é animado."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia a sequência de ações contidas no storyboard fornecido, com um estado especificado para o controle de animação depois que ele for iniciado."
  remarks: "Cenários mais comuns de animação não usam esse método. Normalmente, você cria o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento na marcação e, em seguida, colocá-los como o <xref:System.Windows.EventTrigger>conteúdo em um elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando disparado pelo evento, em seguida, a animação é executado. A maioria dos aspectos de controle de um <xref:System.Windows.Media.Animation.Storyboard>pode ser solucionado com propriedades que são expostas na marcação.</xref:System.Windows.Media.Animation.Storyboard>       Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha de tempo que estão associados com a animação são removidos assim que a animação atingir o período de &quot;Preenchimento&quot;. Portanto, a animação não pode ser reiniciada após a execução de uma vez. Controlar uma animação também requer que o storyboard um [diretiva X:Name](~/add/includes/ajax-current-ext-md.md) ou ser acessado por referência no código.       Comportamento de entrega pode ser especificado como um atributo de <xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>      ## Usando a compor HandoffBehavior quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock>a uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock>objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de temporização não remove automaticamente os relógios.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Para evitar problemas de desempenho quando você aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior>, você deve remover relógios de composição da propriedade animada após a conclusão.</xref:System.Windows.Media.Animation.HandoffBehavior> Para remover um relógio de várias maneiras: - para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>método do objeto animado.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.      -Para remover um específico <xref:System.Windows.Media.Animation.AnimationClock>em uma lista de relógios, use a <xref:System.Windows.Media.Animation.Clock.Controller%2A>propriedade a <xref:System.Windows.Media.Animation.AnimationClock>recuperar um <xref:System.Windows.Media.Animation.ClockController>em seguida, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A>método de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Isso é feito normalmente o <xref:System.Windows.Media.Animation.Clock.Completed>manipulador de eventos para um clock.</xref:System.Windows.Media.Animation.Clock.Completed> Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A>retorna a propriedade de um relógio filho `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed>evento não será gerado se a duração efetiva do relógio for indefinida.</xref:System.Windows.Media.Animation.Clock.Completed>  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Isso é basicamente um problema para animações em objetos que têm uma vida útil longa.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.       Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Um valor de enumeração que descreve o comportamento a ser usado se uma propriedade descrita no storyboard já é animado."
    - id: isControllable
      type: System.Boolean
      description: "Declara se a animação é controlável (pode ser pausado) depois que ele for iniciado."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> que é usado para o elemento."
  remarks: "Um <xref:System.Windows.Data.BindingGroup>pode ser usado para validar os valores de várias propriedades de um objeto.</xref:System.Windows.Data.BindingGroup> Por exemplo, suponha que um aplicativo solicita que o usuário insira um endereço e, em seguida, popula um objeto do tipo `Address`, que tem as propriedades `Street`, `City`, `ZipCode`, e `Country`, com os valores fornecidos pelo usuário. O aplicativo tem um painel que contém quatro <xref:System.Windows.Controls.TextBox>controles, cada um deles está associada a uma das propriedades do objeto.</xref:System.Windows.Controls.TextBox> Você pode usar um <xref:System.Windows.Controls.ValidationRule>em um <xref:System.Windows.Data.BindingGroup>para validar o `Address` objeto.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Por exemplo, o <xref:System.Windows.Controls.ValidationRule>pode garantir que o código postal seja válido para o país do endereço.</xref:System.Windows.Controls.ValidationRule>       Elementos filho herdam o <xref:System.Windows.Data.BindingGroup>de seus elementos-pai, assim como com qualquer outra propriedade herdáveis.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.BindingGroupProperty>|   | Definir propriedades de metadados **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.BindingGroupProperty>"
  example:
  - "The following examples are part of an application that checks whether the user has set the properties of two objects to equal values. The first example creates two <xref:System.Windows.Controls.TextBox> controls, each of which is bound to a different data source. The <xref:System.Windows.Controls.StackPanel> has a <xref:System.Windows.Data.BindingGroup> that contains a <xref:System.Windows.Controls.ValidationRule> that checks that the two strings are equal.  \n  \n [!code-xml[BindingGroupSnippets#BindingGroupComplete](~/add/codesnippet/xaml/BindingGroupSnippets/Window3.xaml#bindinggroupcomplete)]  \n  \n The following example shows the <xref:System.Windows.Controls.ValidationRule> that the previous example uses.  In the <xref:System.Windows.Controls.ValidationRule.Validate%2A> method override, the example gets each source object from the <xref:System.Windows.Data.BindingGroup> and checks whether the properties of the objects are equal.  \n  \n [!code-cs[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#bindinggroupnamevalidationrule)]\n [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#bindinggroupnamevalidationrule)]  \n  \n To invoke the <xref:System.Windows.Controls.ValidationRule>, call the <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> method.  The following example calls <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> when the click event of the button occurs.  \n  \n [!code-cs[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#updatesourcesclick)]\n [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#updatesourcesclick)]"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "O <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> que é usado para o elemento."
  overload: System.Windows.FrameworkElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.BindingGroup*>DependencyProperty.</xref:System.Windows.FrameworkElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "As tentativas de trazer esse elemento para exibição, dentro de qualquer está contido dentro de regiões roláveis."
  remarks: "Ao chamar esse método, você deve gerar um <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos originados do elemento atual.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Esse evento é gerado para que ela possa ser tratada por um <xref:System.Windows.Controls.ScrollViewer>, ou uma classe derivada ou similar</xref:System.Windows.Controls.ScrollViewer> O comportamento esperado é que o evento é manipulado pelo elemento pai, marcado como tratado nos dados do evento, e a origem do evento é colocada em modo de exibição através de lógica de inserida no <xref:System.Windows.Controls.ScrollViewer>controle.</xref:System.Windows.Controls.ScrollViewer> Nem o <xref:System.Windows.FrameworkElement.RequestBringIntoView>evento nem o método BringIntoView transmitir qualquer informação sobre êxito ou falha, que o evento normalmente é marcado como manipulado no êxito.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Motivos da falha podem incluir as definições de elemento, como <xref:System.Windows.UIElement.Visibility%2A>sendo um valor diferente de <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>       Se você usar a assinatura que não especificam um `targetRectangle`, em seguida, o tamanho de todo o elemento (seu <xref:System.Windows.UIElement.RenderSize%2A>) ficará visível.</xref:System.Windows.UIElement.RenderSize%2A>       Ao chamar esse método, você possivelmente chamará <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>em qualquer área rolável pai que contém o elemento.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Se esse elemento não está contido em uma área rolável, o <xref:System.Windows.FrameworkElement.RequestBringIntoView>ainda é gerado, mas não haverá nenhum efeito porque não há nenhum ouvintes de evento.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example implements a handler for an application navigation event that responds whenever the [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] being navigated to includes a fragment. The fragment is named in the [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)] following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame. BringIntoView and <xref:System.Windows.FrameworkElement.RequestBringIntoView> request that scrolling behavior in the example.  \n  \n [!code-vb[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/visualbasic/FragmentNavigationSampleVisualBasic/MainWindow.xaml.vb#febringintoview)]\n [!code-cs[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/csharp/FragmentNavigationSample/MainWindow.xaml.cs#febringintoview)]"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  id: BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "As tentativas de trazer o tamanho da região fornecido desse elemento para exibição, dentro de qualquer está contido dentro de regiões roláveis."
  remarks: "Ao chamar esse método, você deve gerar um <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos originados do elemento atual.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Esse evento é gerado para que ela possa ser tratada por um <xref:System.Windows.Controls.ScrollViewer>, ou uma classe derivada ou similar</xref:System.Windows.Controls.ScrollViewer> O comportamento esperado é que o evento é manipulado pelo elemento pai, marcado como tratado nos dados do evento, e a origem do evento é colocada em modo de exibição através de lógica de inserida no <xref:System.Windows.Controls.ScrollViewer>controle.</xref:System.Windows.Controls.ScrollViewer> Nem o <xref:System.Windows.FrameworkElement.RequestBringIntoView>evento nem o <xref:System.Windows.FrameworkElement.BringIntoView%2A>método transmitir qualquer informação sobre êxito ou falha, que o evento normalmente é marcado como manipulado no êxito.</xref:System.Windows.FrameworkElement.BringIntoView%2A> </xref:System.Windows.FrameworkElement.RequestBringIntoView> Motivos da falha podem incluir as definições de elemento, como <xref:System.Windows.UIElement.Visibility%2A>sendo um valor diferente de <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>       Se você usar a assinatura que não especificam um `targetRectangle`, em seguida, o tamanho de todo o elemento (seu <xref:System.Windows.UIElement.RenderSize%2A>) ficará visível.</xref:System.Windows.UIElement.RenderSize%2A>       Ao chamar esse método, você possivelmente chamará <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>em qualquer área rolável pai que contém o elemento.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Se esse elemento não está contido em uma área rolável, o <xref:System.Windows.FrameworkElement.RequestBringIntoView>ainda é gerado, mas não haverá nenhum efeito porque não há nenhum ouvintes de evento.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example has a large graphic in a constrained scrolling region. A button on the page has a handler that scrolls the view to a particular region of the large graphic.  \n  \n [!code-xml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/add/codesnippet/xaml/BaseElementsSmorgasbord/Page1.xaml#bringintoviewrectmarkup)]  \n  \n [!code-cs[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#bringintoviewrectcode)]\n [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#bringintoviewrectcode)]"
  syntax:
    content: public void BringIntoView (System.Windows.Rect targetRectangle);
    parameters:
    - id: targetRectangle
      type: System.Windows.Rect
      description: "Tamanho especificado para o elemento que também deve ser colocado no modo de exibição."
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o elemento de menu de contexto que deve aparecer sempre que o menu de contexto é solicitado por meio de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] de dentro do elemento."
  remarks: "<xref:System.Windows.Controls.ContextMenu>em si é um <xref:System.Windows.FrameworkElement>classe derivada, e é tecnicamente possível <xref:System.Windows.Controls.ContextMenu>para ter uma propriedade ContextMenu.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> No entanto, isso cria uma experiência de menu de contexto confuso para o usuário e essa prática não é recomendada.      <a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ContextMenuProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ContextMenuProperty>"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "O menu de contexto atribuído a esse elemento."
  overload: System.Windows.FrameworkElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre pouco antes do fechamento de qualquer menu de contexto no elemento."
  remarks: "Para suprimir o fechamento menus de contexto, manipuladores de evento devem marcá-la como manipulado.       Para usar esse evento como um <xref:System.Windows.EventTrigger>em um estilo, você deve fazer referência a definição do serviço subjacente do evento: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (esse uso é necessário porque a implementação de evento em <xref:System.Windows.FrameworkElement>que expõe subjacente eventos de serviço não mapear o identificador de ContextMenuClosing, de modo que você pode usá-lo como um disparador).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>Se for um <xref:System.Windows.FrameworkElement>classe derivada, mas o evento ContextMenuClosing não será gerado por um menu de contexto diretamente.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> Em vez disso, o evento é gerado do elemento que o menu de contexto, como uma propriedade é &quot;dono&quot; e só é gerado quando um usuário tenta fechar um menu de contexto na interface de usuário. No entanto é possível <xref:System.Windows.Controls.ContextMenu>para ter um <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade (um menu de contexto aninhados).</xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu> Nesse caso o <xref:System.Windows.Controls.ContextMenu>realmente possui aninhada <xref:System.Windows.Controls.ContextMenu>e pode gerar o evento, com a origem do evento que está sendo o menu de contexto aninhados.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.Controls.ContextMenu>       O <xref:System.Windows.Controls.ContextMenu>classe em si também tem um evento semelhante (<xref:System.Windows.Controls.ContextMenu.Closed>), mas o <xref:System.Windows.Controls.ContextMenu.Closed>evento não oferece a oportunidade de cancelar a ação do usuário.</xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|   | Estratégia de roteamento | Bolha |   | Delegado | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -Substituir <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>para implementar a manipulação de classe para esse evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando qualquer menu de contexto no elemento é aberta."
  remarks: "Para abrir manualmente os menus de contexto, manipuladores de eventos devem marcar o evento relevante como manipulado. Caso contrário, o valor existente da <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade será usada para automaticamente abrir um menu de contexto.</xref:System.Windows.FrameworkElement.ContextMenu%2A> Marcar o evento manipulado efetivamente cancelará a ação padrão e pode ser uma oportunidade para redefinir o valor da <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade e, em seguida, abra o novo <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement.ContextMenu%2A> No entanto, há um problema de sincronização que deve estar atento. Para substituir completamente o menu de contexto por meio de um manipulador de ContextMenuOpening, o menu de contexto inicial não deve ser nulo / vazio. Como alternativa, você precisará manipular o evento e, em seguida, abra manualmente um novo menu de contexto. Para obter detalhes, consulte [como: manipular o evento ContextMenuOpening](~/add/includes/ajax-current-ext-md.md).       Para usar esse evento como um <xref:System.Windows.EventTrigger>em um estilo, você deve referenciar o evento anexado subjacente: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (esse uso é necessário porque a implementação de evento em <xref:System.Windows.FrameworkElement>que expõe subjacente eventos de serviço não mapear o identificador de ContextMenuOpening, de modo que você pode usá-lo em gatilhos).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>Se for um <xref:System.Windows.FrameworkElement>classe derivada, mas esse evento não será gerado no menu de contexto que está sendo aberto como uma fonte.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> O evento é gerado do elemento que o menu de contexto, como uma propriedade é &quot;dono&quot; e só é gerado quando um usuário tenta abrir um menu de contexto na interface de usuário. É possível <xref:System.Windows.Controls.ContextMenu>para ter um <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade, mas você deve evitar este cenário (para obter detalhes, consulte <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName>).</xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu>       O <xref:System.Windows.Controls.ContextMenu>classe em si também tem um evento semelhante (<xref:System.Windows.Controls.ContextMenu.Opened>), mas <xref:System.Windows.Controls.ContextMenu.Opened>não oferece a oportunidade de cancelar a ação do usuário.</xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|   | Estratégia de roteamento | Bolha |   | Delegado | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -Substituir <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>para implementar a manipulação de classe para esse evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ContextMenu*>DependencyProperty.</xref:System.Windows.FrameworkElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o cursor exibido quando o ponteiro do mouse está sobre este elemento."
  remarks: "Quando você definir essa propriedade [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador depende de conversão de tipo para o <xref:System.Windows.Input.Cursor>classe para avaliar a cadeia de caracteres.</xref:System.Windows.Input.Cursor> A cadeia de caracteres fornecida deve ser avaliada como um <xref:System.Windows.Input.CursorType>valor.</xref:System.Windows.Input.CursorType> Consulte <xref:System.Windows.Input.Cursor>para obter detalhes.</xref:System.Windows.Input.Cursor>       Se o cursor como definido por essa propriedade será ou não será exibida quando o ponteiro do mouse está sobre este elemento também é dependente do valor da <xref:System.Windows.FrameworkElement.ForceCursor%2A>propriedade.</xref:System.Windows.FrameworkElement.ForceCursor%2A> Além disso, considerações relacionadas, como um ativo arrastar, captura do mouse, modos dentro de controles e assim por diante, de edição de texto também afeta o cursor com prioridade maior do que o valor especificado nesta propriedade.       Para reverter o comportamento de definir esta propriedade para o padrão eventual, defina-a como `null` novamente.       O `null` padrão realmente significa que a determinação do valor prático de cursor é adiada aqui e deve ser obtida a partir de outro local. Se for exibida sem valores programáticos de qualquer fonte, o cursor padrão que é visualmente em uma [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] aplicativo será uma seta. No entanto, as alterações de cursor transitório não estão definidas para os valores de Cursor dos elementos quando eles são passados. O Cursor propriedade relatará apenas valores não nulos em casos onde ele foi de fato definidas, por exemplo por meio de código ou um estilo. Cada movimento do mouse sobre um [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] aplicativo gera um <xref:System.Windows.UIElement.QueryCursor>evento.</xref:System.Windows.UIElement.QueryCursor> As bolhas de evento e qualquer elemento na rota tem a oportunidade para manipular o evento e definir o valor do cursor pelos argumentos desse evento. Esse é o mecanismo que produz o cursor visualmente aparente na maioria dos casos. Se um <xref:System.Windows.UIElement.QueryCursor>manipulador retorna um resultado de cursor e, em seguida, o fato de que o evento é manipulado e tem um valor alterado nos argumentos tem precedência sobre o valor da propriedade Cursor em qualquer nível, a menos que <xref:System.Windows.FrameworkElement.ForceCursor%2A>está definido.</xref:System.Windows.FrameworkElement.ForceCursor%2A> </xref:System.Windows.UIElement.QueryCursor>       Se não estiver criando um cursor personalizado, normalmente você define essa propriedade como um valor de propriedade estática de <xref:System.Windows.Input.Cursors>classe.</xref:System.Windows.Input.Cursors> A definição do Cursor no código requer um dos seguintes:-chamar o <xref:System.Windows.Input.Cursor>construtor para obter um <xref:System.Windows.Input.Cursor>instância.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor> Ambas as assinaturas do <xref:System.Windows.Input.Cursor>construtor use fluxos ou arquivos, antes que você está criando o <xref:System.Windows.Input.Cursor>objeto para um cursor personalizado.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor>      -Usar o <xref:System.Windows.Input.CursorConverter>classe e seu <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>método para especificar um cursor pelo <xref:System.Windows.Input.CursorType>, ou uma cadeia de caracteres que pode ser avaliada como um <xref:System.Windows.Input.CursorType>e converter retornar ao <xref:System.Windows.Input.Cursor>.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> </xref:System.Windows.Input.CursorConverter>       Definindo o <xref:System.Windows.Input.Cursor>para um valor personalizado não está habilitado em confiança parcial.</xref:System.Windows.Input.Cursor> Para obter mais informações sobre cursores personalizados, consulte [visão geral de entrada](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.CursorProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.CursorProperty>"
  example:
  - "The following example shows how to deliberately set the cursor graphic.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "O cursor a ser exibido. O valor padrão é definido como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> por essa propriedade de dependência. No entanto, o prático padrão em tempo de execução virão de uma variedade de fatores."
  overload: System.Windows.FrameworkElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Cursor*>DependencyProperty.</xref:System.Windows.FrameworkElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o contexto de dados para um elemento quando este participa na associação de dados."
  remarks: "*Contexto de dados* é um conceito que permite aos elementos herdar informações de seus elementos pais sobre a fonte de dados que é usado para associação, bem como outras características de associação, como o caminho.       Contexto de dados pode ser definido diretamente para um [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] objeto, com as associações de avaliação de propriedades desse objeto. Como alternativa, você pode definir o contexto de dados para um <xref:System.Windows.Data.DataSourceProvider>objeto.</xref:System.Windows.Data.DataSourceProvider>       Essa propriedade de dependência herda valores da propriedade. Se houver elementos filho sem outros valores para DataContext estabelecida por meio de estilos ou valores locais, o sistema de propriedade definirá o valor a ser o valor de DataContext do elemento pai mais próximo com esse valor atribuído.       Como alternativa, você pode usar uma das seguintes propriedades de <xref:System.Windows.Data.Binding>classe para especificar a origem de associação explicitamente: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, ou <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Para obter mais informações, consulte [como: especificar a origem da associação](~/add/includes/ajax-current-ext-md.md).       Em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext geralmente é definido como um <xref:System.Windows.Data.Binding>declaração.</xref:System.Windows.Data.Binding> Você pode usar a sintaxe de elemento de propriedade ou sintaxe de atributo. Sintaxe de atributo é mostrado no exemplo nesta página. Você também pode usar código para definir o DataContext.       DataContext é uma propriedade ligável, para facilitar cenários onde um contexto pode ser vinculado a outro. No entanto, se você associar ao DataContext, tenha cuidado para não criar referências de associação circular (não vincular um DataContext para si mesmo, que é possível fazer devido à natureza de herança do valor de propriedade da propriedade DataContext).      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a># # Uso do elemento de propriedade de XAML ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> # # uso do atributo XAML ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> # # XAML valores *dataContextObject* um objeto diretamente incorporado que serve como o contexto de dados para associações dentro do elemento pai.             Normalmente, esse objeto é um <xref:System.Windows.Data.Binding>ou outro <xref:System.Windows.Data.BindingBase>derivado da classe.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> Como alternativa, os dados brutos de qualquer [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] destinado para associação pode ser colocada aqui, com as associações reais definidas posteriormente do tipo de objeto.       *bindingUsage* um uso de associação que é avaliada para um contexto de dados apropriado. Para obter detalhes, consulte [associação de extensão de marcação](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* um dos seguintes: ou. Esse uso é usado ao fazer referência a dados brutos definidos como um objeto de recursos. Consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* o identificador de chave para o objeto que está sendo solicitado de dentro de um <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.DataContextProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.DataContextProperty>"
  example:
  - "The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.  \n  \n [!code-xml[MasterDetail#DataContextProperty](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty)]  \n[!code-xml[MasterDetail#DataContextProperty2](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty2)]  \n[!code-xml[MasterDetail#DataContextProperty3](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty3)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "O objeto a ser usada como contexto de dados."
  overload: System.Windows.FrameworkElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o contexto de dados para este elemento é alterado."
  remarks: "Para obter uma explicação de contextos de dados e a associação de dados, consulte [visão geral de associação de dados](~/add/includes/ajax-current-ext-md.md).      > [!IMPORTANT] > Quando o <xref:System.Windows.FrameworkElement.DataContext%2A>para alterações de um elemento, todas as propriedades de associação de dados neste elemento potencialmente são afetadas.</xref:System.Windows.FrameworkElement.DataContext%2A> Isso se aplica a elementos que são elementos filho do elemento atual na árvore lógica, que herdam o contexto de dados, e também o elemento atual. Todas as associações existentes novamente devem interpretar o novo <xref:System.Windows.FrameworkElement.DataContext%2A>e irá reavaliar os resultados de associação.</xref:System.Windows.FrameworkElement.DataContext%2A> O mecanismo de associação de dados não é determinístico sobre a ordem desses reavaliações, relativo ao aumento de evento DataContextChanged. As reavaliações podem ocorrer antes do evento após o evento, ou em qualquer combinação."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.DataContext*>DependencyProperty.</xref:System.Windows.FrameworkElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a chave a ser usado para referenciar o estilo para este controle quando os estilos de temas são usados ou definidos."
  remarks: "Normalmente, essa propriedade não é definida por meio de qualquer um de seus acessadores de propriedade direta. Em vez disso, você substituir os metadados específicos do tipo dessa propriedade de dependência toda vez que você criar um novo <xref:System.Windows.FrameworkElement>derivado da classe.</xref:System.Windows.FrameworkElement> Quando você derivar um controle, chame o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>método em relação a <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>identificador dentro do construtor estático do controle derivado classe (ou classe equivalente de inicialização).</xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Um controle normalmente substitui o valor padrão dessa propriedade para ser seu próprio tipo, mas em alguns casos pode usar também um tipo base para o qual exista um estilo de dicionário de tema. Isso só é prático se os modelos de controle do controle base inteiramente definem a representação visual do controle derivado, e se qualquer expõem os tipos derivados de membros adicionais não exigem elementos adicionais como parte do modelo de controle.       Se você quiser que o elemento ou o controle não usar estilos de temas, defina o <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>propriedade `true`.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>"
  example:
  - "The following example illustrates the dependency property metadata override usage discussed in Remarks. This code defines a custom control class `NumericUpDown` intended to be used from a dedicated control library assembly. The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see [Marking Routed Events as Handled, and Class Handling](~/add/includes/ajax-current-ext-md.md)) and finally overrides the DefaultStyleKey dependency property metadata on the `NumericUpDown` class. DefaultStyleKey always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control. The complete sample also defines the actual control's theme style that is referenced by that key; see [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025).  \n  \n [!code-cs[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]\n [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  \n[!code-cs[CustomControlNumericUpDown#Close](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#close)]\n[!code-vb[CustomControlNumericUpDown#Close](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#close)]"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "A chave de estilo. Para funcionar corretamente como parte da pesquisa de estilo de tema, esse valor deve ser o <xref:System.Type>do controle que está sendo estilizado.</xref:System.Type>"
  overload: System.Windows.FrameworkElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.DefaultStyleKey*>DependencyProperty.</xref:System.Windows.FrameworkElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Indica que o processo de inicialização para o elemento foi concluído."
  remarks: "Se <xref:System.Windows.FrameworkElement.BeginInit%2A>foi chamado anteriormente, a base de implementação irá gerar o <xref:System.Windows.FrameworkElement.Initialized>evento.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> Caso contrário, se <xref:System.Windows.FrameworkElement.BeginInit%2A>não foi chamado ou não pôde ser determinado se <xref:System.Windows.FrameworkElement.BeginInit%2A>foi chamado, <xref:System.Windows.FrameworkElement.Initialized>não será gerado e uma exceção será lançada em vez disso.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.EndInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndInit foi chamado sem <xref:System.Windows.FrameworkElement.BeginInit*>ter sido chamado anteriormente no elemento.</xref:System.Windows.FrameworkElement.BeginInit*>"
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Localiza um elemento que tem o nome do identificador fornecido."
  remarks: "Se o elemento tem elementos filho, esses elementos filho são todos recursivamente pesquisada para o elemento nomeado solicitado.       FindName funciona namescope do elemento atual. Para obter detalhes, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome do elemento solicitado."
    return:
      type: System.Object
      description: "O elemento solicitado. Isso pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum elemento correspondente foi encontrado."
  overload: System.Windows.FrameworkElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um recurso com a chave especificada e gera uma exceção se o recurso solicitado não foi encontrado."
  remarks: "> [!IMPORTANT]> Se você chamar esse método para uma chave que não pode ser encontrada, uma exceção é lançada. Se você não deseja tratar exceções resultantes da chamada FindResource, chamada <xref:System.Windows.FrameworkElement.TryFindResource%2A>em vez disso.</xref:System.Windows.FrameworkElement.TryFindResource%2A> <xref:System.Windows.FrameworkElement.TryFindResource%2A>Retorna `null` quando um recurso solicitado não foi encontrado e não gerará uma exceção.</xref:System.Windows.FrameworkElement.TryFindResource%2A>       Se o recurso não foi encontrado no elemento de chamada, o elemento pai na árvore lógica é pesquisada em seguida, em seguida, o aplicativo, e em seguida, temas e finalmente recursos do sistema. A metodologia de pesquisa é idêntica a como a árvore é pesquisada se um recurso foi solicitado por uma referência de recurso dinâmico na marcação. Para obter mais informações sobre o recurso de pesquisa, consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md).       Normalmente, você imediatamente converter um valor de retorno para o tipo da propriedade que você configuração com o valor de recurso retornado de FindResource.       Chaves de recurso não são necessariamente cadeias de caracteres. Por exemplo, estilos de controles no nível de tema deliberadamente são mapeados para o <xref:System.Type>do controle e estilos de aplicativo ou página para controles normalmente usam essa mesma chave convenção.</xref:System.Type> Para obter detalhes, consulte [estilos e modelagem](~/add/includes/ajax-current-ext-md.md) ou [recursos XAML](../Topic/XAML%20Resources.md)."
  example:
  - "The following example obtains a named resource and casts it to an appropriate type to fill a property.  \n  \n [!code-cs[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/csharp/PropertiesOvwSupport/page3.xaml.cs#resourceproceduralget)]\n [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/visualbasic/propertiesovwsupport/page3.xaml.vb#resourceproceduralget)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O identificador de chave para o recurso solicitado."
    return:
      type: System.Object
      description: "O recurso solicitado. Se nenhum recurso com a chave fornecida foi encontrado, uma exceção será lançada. Um <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref> valor também pode ser retornado no caso de exceção."
  overload: System.Windows.FrameworkElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "<code>resourceKey</code>não foi encontrado e não existe um manipulador de eventos para o <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> eventos.       - ou - <code>resourceKey</code> não foi encontrado e o <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled*> é de propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> no <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> eventos."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirection
  id: FlowDirection
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a direção do texto e outros [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] elementos de fluxo em qualquer elemento pai que controlem seu layout."
  remarks: "The dependency property usage sets the FlowDirection on this element. Because of property value inheritance, setting FlowDirection on an element can potentially set FlowDirection on all child elements that did not set FlowDirection locally or though other means such as styles.  \n  \n This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information. For more information on globalization considerations, see [Globalization for WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n This property has a defined [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] property accessor, so it functions as a dependency property. However, it is also registered as attached, so it can also function as an attached property. The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property. The attached property usage is only relevant if the object you intend to set the flow direction on has a <xref:System.Windows.FrameworkElement> parent element that performs layout upon it, is itself not a <xref:System.Windows.FrameworkElement>, and does not already have a more directly defined `FlowDirection` property. (Some of the flow document classes such as <xref:System.Windows.Documents.Block> and <xref:System.Windows.Documents.Inline> define their own `FlowDirection`, and this property can also set the flow direction. The property value is then read by the eventual content host without requiring attached property usage.)  \n  \n<a name=\"xamlAttributeUsage_FlowDirection\"></a>   \n## XAML Attribute Usage  \n \\<*object* **FlowDirection**=\"<xref:System.Windows.FlowDirection>\"/>  \n  \n<a name=\"xamlTextUsage_FlowDirection\"></a>   \n## XAML Text Usage  \n This property can also be set on classes that are not <xref:System.Windows.FrameworkElement> derived classes, by the following [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] attached property usage:  \n  \n `<` *object* `FrameworkElement.`**FlowDirection**=\"<xref:System.Windows.FlowDirection>`\"/>`  \n  \n<a name=\"dependencyPropertyInfo_FlowDirection\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  \n|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  \n  \n This property is both a dependency property and an attached property; see Remarks."
  syntax:
    content: public System.Windows.FlowDirection FlowDirection { get; set; }
    return:
      type: System.Windows.FlowDirection
      description: "A direção do texto e outros [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] elementos de fluxo de dentro de seu elemento pai, como um valor da enumeração. O valor padrão é <xref href=&quot;System.Windows.FlowDirection&quot;> </xref>."
  overload: System.Windows.FrameworkElement.FlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  id: FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.FlowDirection*>DependencyProperty.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FlowDirectionProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma propriedade que permite a personalização da aparência, efeitos ou outras características de estilo que se aplicam a este elemento quando ele captura o foco do teclado."
  remarks: "Essa propriedade afeta a aparência visual, mas não relata <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>nos metadados.</xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> Isso ocorre porque a alteração da aparência visual é controlada por evento não pode ser aplicadas em todos os momentos e, portanto, não geralmente Relate quaisquer informações de layout ou de visual nos metadados.       Conceitualmente, o comportamento visual de foco aplicado a um controle deve ser coerente de controle para controle. É a maneira mais adequada para impor a coerência alterar o estilo visual de foco apenas se você estiver compondo um tema inteiro. Definir esta propriedade nos estilos de controle individual e não como parte de um tema não é o uso pretendido dessa propriedade, porque isso pode resultar em uma experiência de usuário confuso sobre o foco do teclado. Se você estiver pretendendo comportamento específico do controle que é deliberadamente não coerente em um tema, uma abordagem muito melhor é usar disparadores em estilos para propriedades de estado de entrada individual, como <xref:System.Windows.UIElement.IsFocused%2A>ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>e fazer isso de forma que não interfere em nenhum estilo visual de foco existente visualmente.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Para obter mais informações sobre a intenção de design de FocusVisualStyle e propriedades de foco alternativos, consulte [estilo de foco em controles e FocusVisualStyle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a># # Uso do atributo XAML ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> # # uso do elemento de propriedade XAML <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> # # XAML valores *resourceExtension* um dos seguintes:, ou.       Consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* a chave que identifica o estilo que está sendo solicitado. A chave refere-se a um recurso existente em <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Sintaxe de elemento de propriedade é tecnicamente possível, mas não é recomendado. Consulte [modelos e estilos in-line](~/add/includes/ajax-current-ext-md.md). Uma referência de associação usando ou <xref:System.Windows.Data.Binding>também é possível, mas raro.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "O estilo desejado para aplicar em foco. O valor padrão como declarado na propriedade de dependência é uma estática vazia <xref href=&quot;System.Windows.Style&quot;> </xref>. No entanto, o valor efetivo em tempo de execução é normalmente (mas nem sempre) um estilo fornecido pelo suporte de tema para controles."
  overload: System.Windows.FrameworkElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.FocusVisualStyle*>DependencyProperty.</xref:System.Windows.FrameworkElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se este <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> deve forçar o [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] para renderizar o cursor como declarado pelo <xref:System.Windows.FrameworkElement.Cursor*>propriedade.</xref:System.Windows.FrameworkElement.Cursor*>"
  remarks: "Se você definir essa propriedade como `true` substituirão as preferências de cursor estabelecidas por elementos filho. Fazer assim em geral aplicativo [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] pode ser confuso para o usuário, especialmente se os elementos filho são tentar especificar cursores. Configuração ForceCursor é mais adequada em cenários de subclassificação ou composição de controle.      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ForceCursorProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor value.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a apresentação do cursor enquanto está sobre este elemento será forçada a usar atual <xref:System.Windows.FrameworkElement.Cursor*>configurações para o cursor (inclusive em todos os elementos filho); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Cursor*> O valor padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ForceCursor*>DependencyProperty.</xref:System.Windows.FrameworkElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna o <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> que representa a associação na propriedade especificada."
  remarks: "Verificando o valor de retorno para `null` é uma técnica que você pode usar para determinar se uma propriedade tem uma associação ativa.       Esse método é apenas um wrapper de conveniência para o <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>método.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName> GetBindingExpression passa a instância atual e o `dp` parâmetro para <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O destino <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> para obter a associação do."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Um <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> se a propriedade de destino tem uma associação ativa; caso contrário, retornará <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  id: GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o valor da <xref:System.Windows.FrameworkElement.FlowDirection*>propriedade especificado anexada <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "O objetivo principal deste método é dar suporte a sintaxe da propriedade anexada para o <xref:System.Windows.FrameworkElement.FlowDirection%2A>propriedade, portanto, permitindo que o filho elementos de um fornecido <xref:System.Windows.FrameworkElement>para especificar a direção de fluxo para a organização em seu elemento pai.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> Para obter o valor no atual <xref:System.Windows.FrameworkElement>, use o direct [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] acessador <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "O elemento para retornar um <xref:System.Windows.FrameworkElement.FlowDirection*>loop for</xref:System.Windows.FrameworkElement.FlowDirection*>"
    return:
      type: System.Windows.FlowDirection
      description: "A direção do fluxo solicitado, como um valor da enumeração."
  overload: System.Windows.FrameworkElement.GetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna uma geometria de uma máscara de corte. A máscara se aplica se o sistema de layout tentativas organizar um elemento que é maior que o espaço de exibição disponíveis."
  remarks: "Margens serão subtraídas de `layoutSlotSize` como parte do comportamento do sistema de layout.       Uma referência nula retornada indica que nenhum recorte ocorrerá. A implementação padrão sempre retorna `null` quando <xref:System.Windows.UIElement.ClipToBounds%2A>é `false`.</xref:System.Windows.UIElement.ClipToBounds%2A> Esse método substitui <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName> O <xref:System.Windows.FrameworkElement>implementação usa <xref:System.Windows.FrameworkElement.MaxHeight%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>em seus cálculos.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement> Várias subclasses de <xref:System.Windows.FrameworkElement>substituir esse método novamente.</xref:System.Windows.FrameworkElement> <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName>, substituições para sempre retornar `null` como adornos são geralmente deliberadamente fora dos limites comuns.</xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>and <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName> return `null` if <xref:System.Windows.UIElement.ClipToBounds%2A> is `false`.</xref:System.Windows.UIElement.ClipToBounds%2A></xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName></xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>"
  syntax:
    content: protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "O tamanho da parte do elemento que faz a apresentação visual."
    return:
      type: System.Windows.Media.Geometry
      description: "A geometria de recorte."
  overload: System.Windows.FrameworkElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  id: GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna o elemento nomeado na árvore visual de um instanciado <xref href=&quot;System.Windows.Controls.ControlTemplate&quot;> </xref>."
  remarks: "Modelos de [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] têm um namescope autossuficiente. Isso ocorre porque os modelos são reutilizados e qualquer nome definido em um modelo não pode permanecer exclusivo quando várias instâncias de um controle instanciar seu modelo. Chame o método GetTemplateChild para retornar as referências a objetos que vêm do modelo após ele ser instanciado. Não é possível usar o <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>método para localizar itens de modelos porque <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>age em um mais geral escopo, e não há nenhuma conexão entre o <xref:System.Windows.Controls.ControlTemplate>depois que ela é aplicada de classe em si e o modelo instanciado.</xref:System.Windows.Controls.ControlTemplate> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>       <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>fornece a mesma função que esse método.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>é pública em vez de protegida e usa corretas considerações de nome de escopo que lhe permitem acessar o modelo em um elemento e localizar itens dentro dela nomeados.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> Use <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>quando você precisa obter um elemento fora de seu controle pai.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>"
  syntax:
    content: protected System.Windows.DependencyObject GetTemplateChild (string childName);
    parameters:
    - id: childName
      type: System.String
      description: "Nome do filho para localizar."
    return:
      type: System.Windows.DependencyObject
      description: "O elemento solicitado. Pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se não existe nenhum elemento do nome solicitado."
  overload: System.Windows.FrameworkElement.GetTemplateChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna um pai lógico alternativo para esse elemento se não houver nenhum pai visual."
  remarks: "Esse método substitui <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName> O padrão <xref:System.Windows.FrameworkElement>implementação retorna esperado único visual pai, que é o mesmo resultado que obtendo o <xref:System.Windows.FrameworkElement.Parent%2A>valor.</xref:System.Windows.FrameworkElement.Parent%2A> </xref:System.Windows.FrameworkElement> Implementações de classe derivada podem retornar relações pai alternativo."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Retorna algo diferente de <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> sempre que uma implementação de nível de framework WPF desse método tem uma conexão não visual pai."
  overload: System.Windows.FrameworkElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  id: GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Substitui &lt;xref:System.Windows.Media.Visual.GetVisualChild%2A?displayProperty=fullName&gt;e retorna um filho no índice especificado de uma coleção de elementos filho."
  remarks: "No <xref:System.Windows.FrameworkElement>implementação, o índice só é válida é zero.</xref:System.Windows.FrameworkElement> O modelo de conteúdo para GetVisualChild dá suporte a elementos de filho de zero ou um, não é uma coleção."
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children. These values are reported through overrides of <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> and GetVisualChild.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override System.Windows.Media.Visual GetVisualChild (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "O índice de base zero do elemento filho solicitado na coleção."
    return:
      type: System.Windows.Media.Visual
      description: "O elemento filho solicitada. Isso não deve retornar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; se o índice fornecido está fora do intervalo, uma exceção será lançada."
  overload: System.Windows.FrameworkElement.GetVisualChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Height
  id: Height
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a altura sugerida do elemento."
  remarks: "Altura é uma das três propriedades graváveis na <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinHeight%2A>e <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> Se houver um conflito entre esses valores, a ordem do aplicativo para a determinação de altura real é que o primeiro <xref:System.Windows.FrameworkElement.MinHeight%2A>devem ser cumprido, em seguida, <xref:System.Windows.FrameworkElement.MaxHeight%2A>e, finalmente, se ele está dentro dos limites, altura.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       Se este é um elemento filho dentro de algum outro elemento, em seguida, definir essa propriedade como um valor é realmente apenas um valor sugerido. O sistema de layout, bem como a lógica de layout específico do elemento pai usará o valor como uma entrada nonbinding durante o processo de layout. Em termos práticos, uma mensagem <xref:System.Windows.FrameworkElement>é quase sempre o elemento filho de algo mais; mesmo quando você define a altura em <xref:System.Windows.Window>.</xref:System.Windows.Window> </xref:System.Windows.FrameworkElement> (Para <xref:System.Windows.Window>, esse valor será usado quando o modelo de aplicativo subjacente estabelece as suposições de renderização básica que cria o Hwnd que hospeda o aplicativo.)</xref:System.Windows.Window>       Além de aceitável <xref:System.Double>valores, essa propriedade também podem ser <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> Isso é como você especifica o comportamento de dimensionamento automático no código. Em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] você definir o valor para a cadeia de caracteres &quot;Automática&quot; (não diferencia maiusculas de minúsculas) para habilitar o comportamento de dimensionamento de auto. Comportamento de dimensionamento de auto implica que o elemento preencher a altura disponível para ele. No entanto, observe que os controles específicos frequentemente fornecem valores padrão por meio de seus estilos de tema padrão que irá desabilitar o auto comportamento de dimensionamento, a menos que ela seja reativada especificamente.       O valor de retorno dessa propriedade é sempre igual a qualquer valor que foi definido para ele. Em contraste, o valor de <xref:System.Windows.FrameworkElement.ActualHeight%2A>podem variar.</xref:System.Windows.FrameworkElement.ActualHeight%2A> Isso pode acontecer em estaticamente, porque o layout rejeitou o tamanho sugerido por algum motivo, ou momentaneamente. O sistema de layout funciona de forma assíncrona em relação ao conjunto do sistema de propriedade de altura e não pode ter processadas específico dimensionamento de alteração de propriedade ainda.       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se você tentar definir um valor inválido, uma exceção de tempo de execução é gerada.       Além de verificação de validação, há um valor superior não determinístico vinculado a altura é imposta pelo sistema de layout (Este é um número muito grande, maior do que <xref:System.Single.MaxValue?displayProperty=fullName>mas menor do que <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> Se você exceder esse associado, o elemento não será processada e nenhuma exceção é lançada. Não defina a altura como um valor que é significativamente maior do que o tamanho máximo de qualquer exibição visual possíveis, ou pode exceder esse limite superior não determinístico.      <a name=&quot;xamlAttributeUsage_Height&quot;></a># # Uso do atributo XAML ```   <object Height=&quot;double&quot;/>   - or -   <object Height=&quot;qualifiedDouble&quot;/>   - or -   <object Height=&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Height&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Consulte comentários para obter informações de limite superior. Esse valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px **automática** habilita o comportamento de dimensionamento automático.        Consulte comentários.      <a name=&quot;dependencyPropertyInfo_Height&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.HeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.HeightProperty>"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "A altura do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é &lt;xref:System.Double?displayProperty=fullName&gt;. Esse valor deve ser igual ou maior que 0.0. Consulte comentários para obter informações de limite superior."
  overload: System.Windows.FrameworkElement.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HeightProperty
  id: HeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Height*>DependencyProperty.</xref:System.Windows.FrameworkElement.Height*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  id: HorizontalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define as características de alinhamento horizontal aplicadas a este elemento quando ele é composto de um elemento pai, como um painel ou controle de itens."
  remarks: "Quando <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.Width%2A>propriedades são definidas explicitamente em um elemento, essas medidas levar a precedência mais alta durante o layout e cancelará os efeitos típica de configuração HorizontalAlignment para <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> </xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>       É HorizontalAlignment o [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] acessador de propriedade para o que é na verdade uma propriedade de dependência. Essa propriedade de dependência particular com bastante frequência tem seu valor aparente &quot;padrão&quot; definido em elementos de subclasse, particularmente os controles de modo diferente. Isso geralmente ocorre em uma das duas maneiras: a propriedade de dependência é registrada novamente para uma determinada subclasse, mas com diferentes metadados para a configuração de seus padrões; ou há um estilo de padrão que está sendo aplicado que define esse valor de propriedade de dependência de maneira diferente. Por exemplo, o aparente &quot;padrão&quot; de HorizontalAlignment para um <xref:System.Windows.Controls.Label>controle será <xref:System.Windows.HorizontalAlignment>, mesmo que <xref:System.Windows.Controls.Label>herda direta HorizontalAlignment de <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.Label> </xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> Isso ocorre porque esse valor foi redefinida no estilo padrão de <xref:System.Windows.Controls.Label>, no modelo de controle de style.</xref:System.Windows.Controls.Label>       <xref:System.Windows.Controls.Canvas>não usar HorizontalAlignment ao compor o layout, pois <xref:System.Windows.Controls.Canvas>baseia-se no posicionamento absoluto.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       Quando herdada por <xref:System.Windows.Controls.Label>classes derivadas, <xref:System.Windows.Controls.Label>redefine o valor padrão dessa propriedade de dependência para ser <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> ou</xref:System.Windows.Controls.Label>      <a name=&quot;dependencyPropertyInfo_HorizontalAlignment&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>"
  syntax:
    content: public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }
    return:
      type: System.Windows.HorizontalAlignment
      description: "Uma configuração de alinhamento horizontal, como um valor da enumeração. O padrão é <xref href=&quot;System.Windows.HorizontalAlignment&quot;> </xref>."
  overload: System.Windows.FrameworkElement.HorizontalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  id: HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.HorizontalAlignment*>DependencyProperty.</xref:System.Windows.FrameworkElement.HorizontalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  id: InheritanceBehavior
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define os limites de escopo de herança de valor de propriedade, a pesquisa de chave de recurso e a pesquisa de RelativeSource FindAncestor."
  remarks: "Certos limites na árvore de elementos Defina InheritanceBehavior deliberadamente limitar o escopo de comportamento de herança, para um recurso de força de pesquisa para verificar os recursos de aplicativo ou para impedir que uma pesquisa RelativeSource FindAncestor consultando o elemento atual ou qualquer adicional. RelativeSource FindAncestor pesquisa ocorre quando uma associação usa um <xref:System.Windows.Data.RelativeSource>que tem seu <xref:System.Windows.Data.RelativeSource.Mode%2A>propriedade definida como o <xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName>valor.</xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName> </xref:System.Windows.Data.RelativeSource.Mode%2A> </xref:System.Windows.Data.RelativeSource>       Se você deseja que a classe derivada para definir essa propriedade, você deve fazer isso em um construtor estático ou em outras rotinas de inicialização."
  syntax:
    content: protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }
    return:
      type: System.Windows.InheritanceBehavior
      description: "Um valor da enumeração. O padrão é <xref href=&quot;System.Windows.InheritanceBehavior&quot;> </xref>."
  overload: System.Windows.FrameworkElement.InheritanceBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando este <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> é inicializado. Esse evento coincide com casos em que o valor da <xref:System.Windows.FrameworkElement.IsInitialized*>propriedade muda de <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (ou indefinido) a <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "Esse evento será gerado sempre que o <xref:System.Windows.FrameworkElement.EndInit%2A>ou <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>métodos são chamados.</xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> </xref:System.Windows.FrameworkElement.EndInit%2A> Chamadas para o método podem ter vindo do código do aplicativo ou por meio de [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] comportamento do processador quando um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] página é processada.       Se você optar por tratar <xref:System.Windows.FrameworkElement.Loaded>ou inicializado depende de seus requisitos.</xref:System.Windows.FrameworkElement.Loaded> Se você não precisa ler as propriedades de elemento, pretende redefinir propriedades e não é necessário qualquer informação de layout, inicializado pode ser o melhor evento qual agir. Se você precisa de todas as propriedades do elemento para estar disponível e você definirá as propriedades que têm probabilidade de redefinir o layout, <xref:System.Windows.FrameworkElement.Loaded>poderia ser o evento melhor qual agir.</xref:System.Windows.FrameworkElement.Loaded> Tenha cuidado de reentrância se o manipulador redefine todas as propriedades que são interpretadas pelo sistema de layout para indicar que uma nova passagem de layout é necessária. (Talvez seja necessário verificar o <xref:System.Windows.FrameworkPropertyMetadata>valores na propriedade se você não tiver certeza de quais propriedades podem exigir um novo layout passam se eles forem alterados.)</xref:System.Windows.FrameworkPropertyMetadata>       Para obter mais informações sobre a sequência de eventos de objeto para um <xref:System.Windows.FrameworkElement>e também para vários relacionados ao aplicativo e classes de elemento, consulte [eventos de tempo de vida do objeto](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o contexto de entrada usado por este <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  remarks: "Essa propriedade de dependência herda valores da propriedade. Se houver elementos filho sem outros valores para InputScope estabelecida por meio de estilos ou valores locais, o sistema de propriedade definirá o valor a ser o valor de InputScope de elemento ancestral mais próximo com esse valor atribuído.       Embora um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] uso de sintaxe é listado e sintaticamente é permitido, a definição dessa propriedade [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] não é comum.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.InputScopeProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "O escopo de entrada, que modifica como entrada de métodos alternativos de entrada é interpretada. O valor padrão é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (o que resulta em uma manipulação de padrão de comandos)."
  overload: System.Windows.FrameworkElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.InputScope*>DependencyProperty.</xref:System.Windows.FrameworkElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se esse elemento foi inicializado, durante o processamento por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador, fazendo explicitamente seu <xref:System.Windows.FrameworkElement.EndInit*>método chamado.</xref:System.Windows.FrameworkElement.EndInit*>"
  remarks: "Essa propriedade também pode ser `true` se esse elemento foi movido dentro da árvore lógica, de modo que ele tem um novo elemento pai e, portanto, torna-se recarregar novamente.       Essa propriedade é útil se você também estiver usando <xref:System.Windows.FrameworkElement.BeginInit%2A>e <xref:System.Windows.FrameworkElement.EndInit%2A>.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A> Elementos na árvore lógica que é carregado por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] tem a certeza de processador a ser inicializado. Elementos não na árvore lógica são inicializados quando <xref:System.Windows.FrameworkElement.EndInit%2A>é chamado.</xref:System.Windows.FrameworkElement.EndInit%2A> Na ausência de qualquer manipulação específica de <xref:System.Windows.FrameworkElement.BeginInit%2A>e <xref:System.Windows.FrameworkElement.EndInit%2A>, isso acontecerá assim que o construtor retorna o resultado foi inicializado.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o elemento é inicializado pela mencionada anteriormente [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] chamadas de método ou processamento; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se esse elemento foi carregado para apresentação."
  remarks: "De recentemente construído <xref:System.Windows.FrameworkElement>, essa propriedade começa `false`e permanece `true` depois que ele é definido como `true`, mesmo se o elemento subsequentemente é removido de uma árvore lógica conectada por código.</xref:System.Windows.FrameworkElement> `true`estado é definido pela lógica de apresentação geral quando os elementos são carregados no mecanismo de apresentação.       Normalmente, os elementos carregados são renderizados, mas nem todos os <xref:System.Windows.FrameworkElement>classes derivadas têm uma apresentação e outras propriedades, como <xref:System.Windows.UIElement.Visibility%2A>pode influenciar a apresentação.</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.FrameworkElement>"
  example:
  - "The following example implements two handlers: one is handling the <xref:System.Windows.FrameworkElement.Loaded> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event. The other handler is hooked to a user control, and calls IsLoaded to assure that the root element is loaded completely. Both handlers call the same function (not shown) that will populate child elements with fresh data.  \n  \n [!code-cs[GroupBoxExample#FEIsLoaded](~/add/codesnippet/csharp/GroupBoxExample/Page1.xaml.cs#feisloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o elemento atual for anexado a uma árvore de elementos; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o elemento nunca foi anexado a uma árvore de elementos carregados."
  overload: System.Windows.FrameworkElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Language
  id: Language
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define as informações de idioma de localização/globalização que se aplica a um elemento."
  remarks: "Os formatos de cadeia de caracteres seguem o padrão de RFC 3066. Por exemplo, EUA Inglês é &quot;en-US&quot;. Para obter mais informações sobre os valores e o formato, consulte <xref:System.Windows.Markup.XmlLanguage>.</xref:System.Windows.Markup.XmlLanguage>       Essa propriedade de dependência herda valores da propriedade. Se houver elementos filho sem outros valores para idiomas estabelecida por meio de valores locais ou estilos, o sistema de propriedade definirá o valor a ser o valor de idioma do elemento ancestral mais próximo com esse valor atribuído.       [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]Define o significado geral de `xml:lang` atributo. Essencialmente, o idioma expõe o significado deste atributo como uma propriedade de dependência. Idioma podem ser ajustado por meio de programação e pode participar de herança de valor de sistema de propriedade de forma paralela como o `xml:lang` atributo pode herdar de escopo do elemento filho no [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]. Se você definir idioma, esse valor se torna o `xml:lang` e substitui qualquer valor anterior. Para obter mais informações, consulte [XML: lang em XAML de tratamento](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.LanguageProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "As informações de idioma para esse elemento. O valor padrão é um <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> com seus <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>valor definido para a cadeia de caracteres &quot;en-US&quot;.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Language*>DependencyProperty.</xref:System.Windows.FrameworkElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransform
  id: LayoutTransform
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma transformação de gráficos que deve ser aplicados a este elemento quando o layout é executado."
  remarks: "Em comparação com <xref:System.Windows.UIElement.RenderTransform%2A>, LayoutTransform afetará os resultados do layout.</xref:System.Windows.UIElement.RenderTransform%2A>       Configurar uma transformação fornece recursos avançados de dimensionamento e rotação. No entanto, o LayoutTransform ignora <xref:System.Windows.Media.TranslateTransform>operações.</xref:System.Windows.Media.TranslateTransform> Isso ocorre porque o comportamento do sistema de layout de elementos filho de um <xref:System.Windows.FrameworkElement>autocorrige qualquer deslocamentos para a posição de um elemento em escala ou girada no layout e o sistema de coordenadas do elemento pai.</xref:System.Windows.FrameworkElement>       LayoutTransform pode resultar em desempenho ruim do aplicativo se invocá-lo em um cenário que não requer uma passagem completa pelo sistema de layout. Quando você aplica um LayoutTransform para o <xref:System.Windows.Controls.Panel.Children%2A>coleção do <xref:System.Windows.Controls.Panel>, ele dispara uma nova passagem pelo sistema de layout e força todos os na tela objetos a serem re-medidos e reorganizados.</xref:System.Windows.Controls.Panel> </xref:System.Windows.Controls.Panel.Children%2A> Se você estiver atualizando o aplicativo completo [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)], essa funcionalidade pode ser exatamente o que você precisa. No entanto, se você não precisa de uma passagem completa de layout, use o <xref:System.Windows.UIElement.RenderTransform%2A>propriedade, que não chama o sistema de layout e, portanto, é normalmente uma opção melhor para esse cenário.</xref:System.Windows.UIElement.RenderTransform%2A>       Cenários de exemplo em que o LayoutTransform seria útil incluem: girando elementos, como componentes de menu da horizontal para vertical ou vice-versa, dimensionamento elementos (zoom) em foco, fornecendo o comportamento de edição, etc.      <a name=&quot;dependencyPropertyInfo_LayoutTransform&quot;> </a> # # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.LayoutTransformProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.LayoutTransformProperty>"
  example:
  - "The following example shows how to apply a LayoutTransform to an element. The example creates an instance of <xref:System.Windows.Controls.Button> and hosts it within a parent <xref:System.Windows.Controls.Grid>. It also uses the LayoutTransform property to apply a <xref:System.Windows.Media.RotateTransform> to the <xref:System.Windows.Controls.Button>.  \n  \n [!code-vb[LayoutTransform#1](~/add/codesnippet/visualbasic/LayoutTransformVB/LayoutTransform.vb#1)]\n [!code-cpp[LayoutTransform#1](~/add/codesnippet/cpp/layouttransform/LayoutTransform.cpp#1)]\n [!code-xml[LayoutTransform#1](~/add/codesnippet/xaml/LayoutTransform/default.xaml#1)]\n [!code-cs[LayoutTransform#1](~/add/codesnippet/csharp/LayoutTransformCsharp/LayoutTransform.cs#1)]"
  syntax:
    content: public System.Windows.Media.Transform LayoutTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "A transformação que deve usar esse elemento. O padrão é <xref:System.Windows.Media.Transform.Identity*>.</xref:System.Windows.Media.Transform.Identity*>"
  overload: System.Windows.FrameworkElement.LayoutTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  id: LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.LayoutTransform*>DependencyProperty.</xref:System.Windows.FrameworkElement.LayoutTransform*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LayoutTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o elemento é apresentado, processado e está pronto para interação."
  remarks: "Carregado é geralmente o último evento gerado em uma sequência de inicialização do elemento. Sempre será gerado após <xref:System.Windows.FrameworkElement.Initialized>.</xref:System.Windows.FrameworkElement.Initialized> Se você optar por tratar carregado ou <xref:System.Windows.FrameworkElement.Initialized>depende dos seus requisitos.</xref:System.Windows.FrameworkElement.Initialized> Se você não precisa ler as propriedades de elemento, pretende redefinir propriedades e não é necessário qualquer informação de layout, <xref:System.Windows.FrameworkElement.Initialized>poderia ser o evento melhor qual agir.</xref:System.Windows.FrameworkElement.Initialized> Se você precisar de todas as propriedades do elemento esteja disponível e você definirá as propriedades que têm probabilidade de redefinir o layout, carregado pode ser o evento melhor para agir. Tenha cuidado de reentrância se o manipulador redefine todas as propriedades que são interpretadas pelo sistema de layout para indicar que uma nova passagem de layout é necessária. (Talvez seja necessário verificar o <xref:System.Windows.FrameworkPropertyMetadata>valores na propriedade se você não tiver certeza de quais propriedades podem exigir um novo layout passam se eles forem alterados.)</xref:System.Windows.FrameworkPropertyMetadata>       Para obter mais informações sobre a sequência de eventos de objeto para um <xref:System.Windows.FrameworkElement>e também para vários relacionados ao aplicativo e classes de elemento, consulte [eventos de tempo de vida do objeto](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>       Os eventos roteados diretos não seguem uma rota, somente são tratados dentro do mesmo elemento no qual eles são gerados. Eventos roteados diretos suportam outro comportamento eventos roteados: eles dão suporte a uma coleção de manipuladores acessível e pode ser usados como um <xref:System.Windows.EventTrigger>em um estilo.</xref:System.Windows.EventTrigger>       Carregar e <xref:System.Windows.FrameworkElement.Unloaded>podem ser gerados em controles como resultado das alterações de tema do sistema iniciada pelo usuário.</xref:System.Windows.FrameworkElement.Unloaded> Uma alteração de tema faz com que um invalidação do modelo de controle e a árvore visual independente, que por sua vez faz com que todo o controle descarregar e recarregar. Portanto carregado não pode considerado como ocorrem somente quando uma página for carregada pela primeira vez por meio de navegação para a página.      <a name=&quot;routedEventInfo_Loaded&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.LoadedEvent>|   | Estratégia de roteamento | Direct |   | Delegado | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.Loaded&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um enumerador para elementos filho desse elemento."
  remarks: "LogicalChildren permite iterar os elementos filho. Isso é útil para elementos que podem não tem uma coleção dedicada definida, mas ainda contêm mais de um elemento filho, particularmente <xref:System.Windows.FrameworkContentElement>elementos filho.</xref:System.Windows.FrameworkContentElement>       Para obter mais informações sobre como usar LogicalChildren e <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "Um enumerador para elementos filho desse elemento."
  overload: System.Windows.FrameworkElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Margin
  id: Margin
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a margem externa de um elemento."
  remarks: "A margem é o espaço entre este elemento e outros elementos que estarão adjacentes quando layout cria o [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Elementos compartilhados podem ser elementos de ponto a ponto (como outros elementos da coleção de um controle pai comum) ou também podem ser o pai do elemento.       Margem está definida como um <xref:System.Windows.Thickness>estrutura em vez de como um número para que a margem pode ser definida assimetricamente.</xref:System.Windows.Thickness> O <xref:System.Windows.Thickness>estrutura em si oferece suporte à conversão de tipo de cadeia de caracteres para que você pode especificar uma margem assimétrica em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sintaxe de atributo também.</xref:System.Windows.Thickness>       Uma margem diferente de zero aplica espaço fora do layout do elemento <xref:System.Windows.FrameworkElement.ActualWidth%2A>e <xref:System.Windows.FrameworkElement.ActualHeight%2A>.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>       As margens são aditivas para elementos irmãos em um layout; Por exemplo, dois elementos adjacentes que com uma margem de 30 definidos na borda adjacente teria 60 unidades de espaço entre eles.       Os elementos que tenham margens definido não restringe normalmente o tamanho da margem especificada se o espaço alocado do retângulo não é grande o suficiente para a margem e área de conteúdo do elemento. A área de conteúdo do elemento será limitada em vez disso, quando o layout é calculado. O único caso onde margens deve ser restrita é também se o conteúdo já está restrita para zero.      <a name=&quot;xamlAttributeUsage_Margin&quot;></a># # Uso do atributo XAML ```   <object Margin=&quot;left,top,right,bottom&quot;/>   - or -   <object Margin=&quot;left,top&quot;/>   - or -   <object Margin=&quot;thicknessReference&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Margin&quot;> </a> # # uso do elemento de propriedade XAML ```   <object>     <object.Margin>       <Thickness Left=&quot;left&quot; Top=&quot;top&quot; Right=&quot;right&quot; Bottom=&quot;bottom&quot;/>     </object.Margin>   </object>   ``` <a name=&quot;xamlValues_Margin&quot;> </a> # # XAML valores *à esquerda, superior, direita, inferior* número de valores entre 0 e <xref:System.Double.PositiveInfinity>que especificam as quatro propriedades de dimensão possíveis de um <xref:System.Windows.Thickness>estrutura.</xref:System.Windows.Thickness> </xref:System.Double.PositiveInfinity>                   O uso de atributo também aceitará abreviados valores que se aplicam na ordem fornecida, simetricamente e logicamente. Por exemplo, `Margin=&quot;20&quot;` será interpretado como um <xref:System.Windows.Thickness>com todas as propriedades definidas para 20.</xref:System.Windows.Thickness> `Margin=&quot;20,50&quot;`será interpretado como um <xref:System.Windows.Thickness>com <xref:System.Windows.Thickness.Left%2A>e <xref:System.Windows.Thickness.Right%2A>definido como 20, e <xref:System.Windows.Thickness.Top%2A>e <xref:System.Windows.Thickness.Bottom%2A>definido como 50.</xref:System.Windows.Thickness.Bottom%2A> </xref:System.Windows.Thickness.Top%2A> </xref:System.Windows.Thickness.Right%2A> </xref:System.Windows.Thickness.Left%2A> </xref:System.Windows.Thickness>       A unidade padrão para um <xref:System.Windows.Thickness>medida é [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)].</xref:System.Windows.Thickness> Você também pode especificar outras unidades acrescentando as cadeias de caracteres de tipo de unidade `cm`, `in`, ou `pt` a qualquer medida.       Número de valores fornecidos como [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] atributos não é necessário especificar pontos decimais (0 é aceitável, não precisa ser fornecido como 0.0). Para obter mais informações sobre [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] uso, consulte <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>       *thicknessReference* uma referência de objeto para um <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness> existente Isso pode ser um `}`, a, ou `}` referência. Para obter mais informações sobre [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] uso, consulte <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>      <a name=&quot;dependencyPropertyInfo_Margin&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.MarginProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MarginProperty>"
  syntax:
    content: public System.Windows.Thickness Margin { get; set; }
    return:
      type: System.Windows.Thickness
      description: "Fornece valores de margem para o elemento. O valor padrão é um <xref href=&quot;System.Windows.Thickness&quot;> </xref> com todas as propriedades iguais a 0 (zero)."
  overload: System.Windows.FrameworkElement.Margin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MarginProperty
  id: MarginProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Margin*>DependencyProperty.</xref:System.Windows.FrameworkElement.Margin*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MarginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeight
  id: MaxHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de altura máxima do elemento."
  remarks: "Esta é uma das três propriedades em <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinHeight%2A>e <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>  Se houver um conflito entre esses valores, a ordem do aplicativo para a determinação de altura real é primeiro <xref:System.Windows.FrameworkElement.MinHeight%2A>devem ser consideradas, em seguida, MaxHeight e, finalmente, se cada um deles está dentro dos limites, <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se você tentar definir um valor inválido é gerada uma exceção de tempo de execução.      <a name=&quot;xamlAttributeUsage_MaxHeight&quot;></a># # Uso do atributo XAML ```   <object MaxHeight=&quot;double&quot;/>   - or –   <object MaxHeight =&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxHeight&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Isso é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo conforme mencionado na seção do valor da propriedade, exceto que você deve usar [extensão de marcação X:Static](~/add/includes/ajax-current-ext-md.md) se você precisa definir explicitamente o valor a ser <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxHeight&quot;> </a> # # informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.MaxHeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxHeightProperty>       "
  syntax:
    content: public double MaxHeight { get; set; }
    return:
      type: System.Double
      description: "A altura máxima do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é <xref:System.Double>.</xref:System.Double> Esse valor pode ser qualquer valor igual ou maior que 0.0. <xref:System.Double>também é válido.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  id: MaxHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MaxHeight*>DependencyProperty.</xref:System.Windows.FrameworkElement.MaxHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidth
  id: MaxWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de largura máxima do elemento."
  remarks: "Esta é uma das três propriedades em <xref:System.Windows.FrameworkElement>que especificam as informações de largura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinWidth%2A>e <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> Se houver um conflito entre esses valores, a ordem do aplicativo para a determinação de largura real é primeiro <xref:System.Windows.FrameworkElement.MinWidth%2A>devem ser consideradas, em seguida, MaxWidth e, finalmente, se cada um deles está dentro dos limites, <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se você tentar definir um valor inválido, uma exceção de tempo de execução é gerada.      <a name=&quot;xamlAttributeUsage_MaxWidth&quot;></a># # Uso do atributo XAML ```   <object MaxWidth=&quot;double&quot;/>   - or -   <object MaxWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxWidth&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Isso é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo conforme mencionado na seção do valor da propriedade, exceto que você deve usar [extensão de marcação X:Static](~/add/includes/ajax-current-ext-md.md) para definir o valor a ser <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxWidth&quot;> </a> # # informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.MaxWidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxWidthProperty>       "
  syntax:
    content: public double MaxWidth { get; set; }
    return:
      type: System.Double
      description: "A largura máxima do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é <xref:System.Double>.</xref:System.Double> Esse valor pode ser qualquer valor igual ou maior que 0.0. <xref:System.Double>também é válido.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  id: MaxWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MaxWidth*>DependencyProperty.</xref:System.Windows.FrameworkElement.MaxWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Basic implementa medidas passa comportamento do sistema de layout <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  remarks: "Esse método substitui <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>para conectar o nível de núcleo do WPF e implementações de medida de layout de nível de framework WPF.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> O <xref:System.Windows.FrameworkElement>implementação lacra o método.</xref:System.Windows.FrameworkElement> Para ajustar o comportamento de qualquer elemento que se baseia no nível de framework do WPF do layout de passagem de medida, substituir <xref:System.Windows.FrameworkElement.MeasureOverride%2A>em vez disso.</xref:System.Windows.FrameworkElement.MeasureOverride%2A> Para ajustar o comportamento de layout de passagem de medidas de um elemento que deliberadamente não criar no nível de framework do WPF ou usar <xref:System.Windows.FrameworkElement>, substitua <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "O tamanho disponível que o elemento pai pode dar aos elementos filho."
    return:
      type: System.Windows.Size
      description: "O tamanho desejado desse elemento no layout."
  overload: System.Windows.FrameworkElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituído em uma classe derivada, mede o tamanho em layout necessário para elementos filho e determina um tamanho para o <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>-classe derivada."
  remarks: "Substituir MeasureOverride para implementar o comportamento de dimensionamento de layout personalizado para o elemento que participa de [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] sistema de layout. Sua implementação deve fazer o seguinte: 1.  Iterar a coleção específica do elemento de filhos que fazem parte do layout, chamada <xref:System.Windows.UIElement.Measure%2A>em cada elemento filho.</xref:System.Windows.UIElement.Measure%2A>      2.  Obter imediatamente <xref:System.Windows.UIElement.DesiredSize%2A>no filho (Isso é definido como uma propriedade após <xref:System.Windows.UIElement.Measure%2A>é chamado).</xref:System.Windows.UIElement.Measure%2A> </xref:System.Windows.UIElement.DesiredSize%2A>      3.  Calcule o tamanho desejado net do pai com base na medida dos elementos filho.       O valor de retorno de MeasureOverride deve ser o tamanho do elemento próprio desejado, o que torna-se a entrada de medida para o elemento pai do elemento atual. Este mesmo processo continua por meio do sistema de layout até que o elemento raiz da página seja atingido.       Durante esse processo, os elementos filho podem retornar uma maior <xref:System.Windows.UIElement.DesiredSize%2A>tamanho que o inicial `availableSize` para indicar que o elemento filho deseja mais espaço.</xref:System.Windows.UIElement.DesiredSize%2A> Isso pode ser manipulado em sua própria implementação introduzindo uma região de rolagem, redimensionando o controle pai, estabelecendo alguma maneira de ordem empilhada ou qualquer número de soluções para medir ou organizando conteúdo.      > [!IMPORTANT] > Elementos devem chamar <xref:System.Windows.UIElement.Measure%2A>em cada filho durante esse processo, caso contrário, os elementos filho não serão corretamente o tamanho ou organizados.</xref:System.Windows.UIElement.Measure%2A>"
  syntax:
    content: protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "O tamanho disponível que esse elemento pode dar a elementos filho. Infinito pode ser especificado como um valor para indicar que o elemento será dimensionado para qualquer conteúdo que está disponível."
    return:
      type: System.Windows.Size
      description: "O tamanho que esse elemento determina que ele precisa durante o layout, com base em seus cálculos de tamanhos de elemento filho."
  overload: System.Windows.FrameworkElement.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeight
  id: MinHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de altura mínima do elemento."
  remarks: "Esta é uma das três propriedades em <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Height%2A> Se houver um conflito entre esses valores, a ordem de aplicativo para determinação de altura real é MinHeight primeiro deve ser respeitada, em seguida, <xref:System.Windows.FrameworkElement.MaxHeight%2A>e, finalmente, se cada um deles está dentro dos limites, <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se você tentar definir um valor inválido, uma exceção de tempo de execução é gerada.      <a name=&quot;xamlAttributeUsage_MinHeight&quot;></a># # Uso do atributo XAML ```   <object MinHeight=&quot;double&quot;/>   - or -   <object MinHeight=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinHeight&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Isso é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo conforme mencionado na seção do valor da propriedade.</xref:System.Double>       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinHeight&quot;> </a> # # informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.MinHeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinHeightProperty>       "
  syntax:
    content: public double MinHeight { get; set; }
    return:
      type: System.Double
      description: "A altura mínima do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é 0.0. Esse valor pode ser qualquer valor igual ou maior que 0.0. No entanto, <xref:System.Double>não é válido, nem &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeightProperty
  id: MinHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MinHeight*>DependencyProperty.</xref:System.Windows.FrameworkElement.MinHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidth
  id: MinWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de largura mínima do elemento."
  remarks: "Esta é uma das três propriedades em <xref:System.Windows.FrameworkElement>que especificam as informações de largura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.Width%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.Width%2A>  Se houver um conflito entre esses valores, a ordem de aplicativo para determinação de largura real é MinWidth primeiro deve ser respeitada, em seguida, <xref:System.Windows.FrameworkElement.MaxWidth%2A>e, finalmente, se cada um deles está dentro dos limites, <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MaxWidth%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se você tentar definir um valor inválido, uma exceção de tempo de execução é gerada.      <a name=&quot;xamlAttributeUsage_MinWidth&quot;></a># # Uso do atributo XAML ```   <object MinWidth=&quot;double&quot;/>   - or -   <object MinWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Isso é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo conforme mencionado na seção do valor da propriedade.</xref:System.Double>       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinWidth&quot;> </a> # # informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.MinWidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinWidthProperty>       "
  syntax:
    content: public double MinWidth { get; set; }
    return:
      type: System.Double
      description: "A largura mínima do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é 0.0. Esse valor pode ser qualquer valor igual ou maior que 0.0. No entanto, <xref:System.Double>não é válido, nem &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidthProperty
  id: MinWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MinWidth*>DependencyProperty.</xref:System.Windows.FrameworkElement.MinWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Move o foco do teclado para esse elemento e a outro elemento em uma direção de passagem fornecido."
  remarks: "Essa implementação substitui <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>e lacra o método.</xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>"
  example:
  - "The following example implements a handler that handles several possible button inputs. Each button represents a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls MoveFocus on that element, by specifying the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided.  \n  \n [!code-cs[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#focussamplemovefocus)]\n [!code-vb[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#focussamplemovefocus)]"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "A direção em que o foco é movido, como um valor da enumeração."
    return:
      type: System.Boolean
      description: "Retorna <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se o foco é movido com êxito; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o elemento de destino na direção especificada não existe ou pode não ser teclado focalizado."
  overload: System.Windows.FrameworkElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Name
  id: Name
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o nome de identificação do elemento. O nome fornece uma referência para que o code-behind, como o código de manipulador de eventos, pode fazer referência a um elemento de marcação depois que ela é construída durante o processamento por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador."
  remarks: "O uso mais comum dessa propriedade é especificar um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] nome do elemento como um atributo na marcação.       Esta propriedade fornece essencialmente uma propriedade de conveniência de nível de framework do WPF para definir o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [diretiva X:Name](~/add/includes/ajax-current-ext-md.md).       Nomes devem ser exclusivos dentro de um namescope. Para obter mais informações, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Obter um nome se você estiver criando elementos em código não é comum. Se você já a referência apropriada no código, você pode simplesmente chamar métodos e propriedades no elemento de referem e geralmente não serão necessário o nome. Uma exceção a isso é se a cadeia de caracteres de nome tem algumas sobrecarregados que significa que, por exemplo se é útil exibir esse nome no [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Um nome da lógica se o nome original foi definido da marcação também não é recomendado de configuração e alteração da propriedade após o carregamento de [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] não alterará a referência de objeto original. As referências de objeto são criadas apenas quando os namescopes subjacentes são explicitamente criados durante a análise. Você deverá chamar especificamente <xref:System.Windows.FrameworkElement.RegisterName%2A>para fazer uma alteração efetiva para a propriedade de nome de um elemento já carregada.</xref:System.Windows.FrameworkElement.RegisterName%2A>       Uma ocorrência notável em que é importante definir o nome do código é quando o registro de nomes de elementos storyboards serão executado, para que eles podem ser referenciados em tempo de execução. Antes de registrar um nome, também precisará criar uma instância e atribuir um <xref:System.Windows.NameScope>instância.</xref:System.Windows.NameScope> Consulte a seção de exemplo ou [Storyboards Overview](~/add/includes/ajax-current-ext-md.md).       Nome da configuração do código limitou os aplicativos, mas a obtenção de um elemento por nome é mais comum. Um cenário em particular está se seu aplicativo dá suporte a um modelo de navegação onde páginas Recarregar no aplicativo, e o código de tempo de execução não é necessariamente lógica definida para a página. O método de utilitário <xref:System.Windows.FrameworkElement.FindName%2A>, que está disponível em qualquer <xref:System.Windows.FrameworkElement>, pode encontrar qualquer elemento por nome na árvore lógica para esse elemento, pesquisa recursivamente a árvore conforme necessário.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FindName%2A> Ou você pode usar o <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>método estático de <xref:System.Windows.LogicalTreeHelper>, que também usa uma cadeia de caracteres de nome como um argumento.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Normalmente usado elementos raiz (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>por exemplo) implementa a interface <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Implementações dessa interface devem impor que os nomes sejam ambíguos no seu escopo. Os elementos raiz que definem essa interface também definem os limites de comportamento namescope para todos os relacionado [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)].       A propriedade Name também serve como um identificador para outros processos. Por exemplo, o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] modelo de automação usará nome como o AutomationId para clientes e fornecedores.       Os valores de cadeia de caracteres usados para nome têm algumas restrições, conforme imposto pelo subjacente [diretiva X:Name](../Topic/x:Name%20Directive.md) definido pelo [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] especificação. Notadamente, um nome deve começar com uma letra ou o caractere de sublinhado (_) e deve conter apenas letras, dígitos ou sublinhados. Para obter mais informações, consulte [WPF XAML Namescopes](../Topic/WPF%20XAML%20Namescopes.md).       Nome é uma das poucas propriedades de dependência que não podem ser animadas (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> é `true` nos metadados), pois o próprio nome é vital para atingir uma animação.</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Um nome de associação de dados é tecnicamente possíveis, mas é um cenário muito comum porque um nome de associação de dados não pode servir a finalidade principal da propriedade: para fornecer um ponto de conexão do identificador para code-behind.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.NameProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkElement.NameProperty>"
  example:
  - "The following example sets the Name property in code, and then registers the name into the newly created <xref:System.Windows.NameScope> by calling <xref:System.Windows.FrameworkElement.RegisterName%2A>. The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the Name, and cannot be targeted by object reference.  \n  \n [!code-vb[animateHeight_procedural#FEName](~/add/codesnippet/visualbasic/animateheight/animatedheightexample.vb#fename)]\n [!code-cs[animateHeight_procedural#FEName](~/add/codesnippet/csharp/animateheight_csharp/AnimatedHeightExample.cs#fename)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "O nome do elemento. O padrão é uma cadeia de caracteres vazia."
  overload: System.Windows.FrameworkElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Name*>DependencyProperty.</xref:System.Windows.FrameworkElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  id: OnApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituído em uma classe derivada, é chamado sempre que o código do aplicativo ou processos internos chamada <xref:System.Windows.FrameworkElement.ApplyTemplate*>.</xref:System.Windows.FrameworkElement.ApplyTemplate*>"
  remarks: "Esse método não tem nenhuma implementação padrão.       Os modelos são a seção de concluído árvore visual um elemento que vêm com a propriedade de modelo de um <xref:System.Windows.Style>que é aplicada para o elemento.</xref:System.Windows.Style> Para obter mais informações, consulte [estilos e modelagem](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public virtual void OnApplyTemplate ();
    parameters: []
  overload: System.Windows.FrameworkElement.OnApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que um sem tratamento <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> eventos roteados atingir essa classe em sua rota. Implemente esse método para adicionar a manipulação de classe para esse evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que um sem tratamento <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> eventos roteados atingir essa classe em sua rota. Implemente esse método para adicionar a manipulação de classe para esse evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.FrameworkElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que um sem tratamento <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref> evento atinge esse elemento em sua rota."
  remarks: "Ao contrário de alguns outros * métodos expostos pelos elementos base, AoReceberFoco tem uma implementação padrão. Especificamente, ele tem uma implementação que substitui a implementação nulo no próximo nível do elemento base para baixo, <xref:System.Windows.UIElement.OnGotFocus%2A>.</xref:System.Windows.UIElement.OnGotFocus%2A> Quando chamado, AoReceberFoco define o comportamento de foco apropriado neste elemento em casos onde o evento foi originado do elemento atual devido ao foco do teclado. O manipulador AoReceberFoco não marcar os argumentos do evento como tratado, mesmo quando o foco está definido para o elemento atual. Se a origem do evento foi outro elemento na árvore de (não o elemento atual), o manipulador não fará nada.       Você pode substituir esse método para alterar o comportamento de foco padrão em seu elemento, mas lembre-se de que alterar o comportamento de foco dessa maneira pode ser melhor executada não permitindo que o elemento seja Focusable é nenhum (consulte <xref:System.Windows.UIElement.Focusable%2A>).</xref:System.Windows.UIElement.Focusable%2A>"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.FrameworkElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.FrameworkElement.Initialized&quot;> </xref> eventos. Esse método é chamado sempre que <xref:System.Windows.FrameworkElement.IsInitialized*>é definido como <xref uid=&quot;langword_csharp_true &quot; name=&quot;true &quot; href=&quot;&quot;> </xref>internamente.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "This particular On* method is not a class handler hook. Nor does it exactly follow the established [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] On\\* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.  \n  \n Note that the <xref:System.Windows.FrameworkElement.IsInitialized%2A> property is read-only, so you cannot set <xref:System.Windows.FrameworkElement.IsInitialized%2A> to force initialization behavior. Setting the initialization state is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.FrameworkElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que o valor efetivo de qualquer propriedade de dependência sobre isso <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> foi atualizado. A propriedade de dependência específicas alterada é relatada no parâmetro de argumentos. Substituições <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Esse método não deve detectar geralmente invalidações ou alterações de propriedade. Em vez disso destina para modificações do padrão de invalidação geral se for conhecidas certas informações sobre classificações de largura de propriedades.       Esse método é potencialmente chamado várias vezes durante a vida de um objeto. Portanto, você pode obter um melhor desempenho se você substituir os metadados de propriedades específicas e, em seguida, anexa <xref:System.Windows.CoerceValueCallback>ou <xref:System.Windows.PropertyChangedCallback>funções de propriedades individuais.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> No entanto, você usaria esse método se um <xref:System.Windows.FrameworkElement>inclui um número significativo de propriedades de dependência inter-relacionados de valor, ou se ele inclui lógica, como o comportamento de renderização que deve ser executado novamente para vários casos de invalidações de propriedade de relacionados.</xref:System.Windows.FrameworkElement>       Observe que há um nome idêntico `OnPropertyChanged` método com uma assinatura diferente (o tipo de parâmetro é <xref:System.ComponentModel.PropertyChangedEventArgs>) que podem aparecer em um número de classes.</xref:System.ComponentModel.PropertyChangedEventArgs> Que `OnPropertyChanged` é usado para notificações do objeto de dados e faz parte do contrato de <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "Os dados de evento que descreve a propriedade alterada, bem como valores novos e antigos."
  overload: System.Windows.FrameworkElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> evento, usando as informações especificadas como parte dos dados do evento eventual."
  remarks: "Esse método substitui <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>.</xref:System.Windows.UIElement.OnRenderSizeChanged%2A> Se você chamar este método redefinirá o <xref:System.Windows.FrameworkElement.ActualWidth%2A>propriedade, o <xref:System.Windows.FrameworkElement.ActualHeight%2A>propriedade, ou ambos, dependendo do que é especificado como alterados nos argumentos fornecidos, e você sempre gera o evento.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>"
  syntax:
    content: protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);
    parameters:
    - id: sizeInfo
      type: System.Windows.SizeChangedInfo
      description: "Detalhes do tamanho do antigo e novo envolvido na alteração."
  overload: System.Windows.FrameworkElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Chamado quando o estilo em uso neste elemento é alterado, qual invalidará o layout."
  remarks: "Esse método tem uma implementação padrão que define um sinalizador interno que indica a condição de estilo alterado."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "O estilo antigo."
    - id: newStyle
      type: System.Windows.Style
      description: "O novo estilo."
  overload: System.Windows.FrameworkElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que um sem tratamento <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> eventos roteados atingir essa classe em sua rota. Implemente esse método para adicionar a manipulação de classe para esse evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocado sempre que o <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> eventos roteados atingir essa classe em sua rota. Implemente esse método para adicionar a manipulação de classe para esse evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Chamado quando o pai deste elemento na árvore visual é alterado. Substituições <xref:System.Windows.UIElement.OnVisualParentChanged*>.</xref:System.Windows.UIElement.OnVisualParentChanged*>"
  remarks: "A árvore visual é potencialmente diferente da árvore lógica porque ele omite os elementos que não processam visualmente, como coleções e expande alguns elementos com base em sua composição de tema e um estilo. Para obter mais informações, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "O elemento pai antigo. Pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para indicar que o elemento não tem um pai visual anteriormente."
  overload: System.Windows.FrameworkElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se este elemento incorpora propriedades de estilo dos estilos de tema."
  remarks: "O uso mais comum dessa propriedade é um uso indireto em setter de um estilo que está fornecendo um estilo com tema.      > [!IMPORTANT] > Se você definir OverridesDefaultStyle como `true` em um controle, você irá suprimir o modelo de controle padrão fornecido pelos estilos de tema. Esse modelo de controle normalmente inclui conteúdo apresentador e outros elementos compostos que fornecem básico [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] funcionalidade e visualização para o controle. Se você desejar que o controle para continuar a oferecer suporte os mesmos recursos como os estilos de tema padrão, você deve fornecer um estilo alternativo com um modelo de controle que replica a mesma estrutura. Para obter mais informações, consulte [visão geral de criação do controle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esse elemento não usar propriedades de estilo do tema; todas as propriedades de estilo de origem vêm de estilos de aplicativo local, e não se aplicam a propriedades de estilo do tema. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Se os estilos de aplicativo são aplicados primeiro e aplicam estilos de tema para propriedades que não foram especificamente definidas em estilos de aplicativo. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>DependencyProperty.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Parent
  id: Parent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o elemento pai lógico desse elemento."
  remarks: "Pai poderá ser `null` em casos em que um elemento foi instanciado, mas não está associado a qualquer árvore lógica que eventualmente se conecta ao elemento raiz de nível de página ou o objeto de aplicativo.       Observe que o pai lógico de um elemento poderá alterar dependendo da funcionalidade do aplicativo e manter o valor dessa propriedade não refletirá essa alteração. Normalmente, você deve obter o valor imediatamente antes de você precisa dele.       Consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md) para obter mais informações sobre a passagem da árvore lógica e os cenários em que o uso de pai como uma técnica de descoberta do elemento pai é apropriado.       O mecanismo de propriedade potencialmente recalculará todos os valores de propriedade de um elemento quando ele é alterado o nível superior, porque algumas propriedades herdam valores por meio da árvore lógica. O <xref:System.Windows.FrameworkElement.DataContext%2A>que se aplica para associações também podem alterar quando os elementos de seus pais são modificados.</xref:System.Windows.FrameworkElement.DataContext%2A>       Alterando o pai de um elemento é normalmente feito somente por meio de manipulação de coleções, usando dedicado adicionar ou remover métodos, ou por meio de propriedades do conteúdo dos elementos de configuração.       O cenário mais comum para usar a propriedade pai é obter uma referência e, em seguida, obter vários <xref:System.Windows.FrameworkElement>valores de propriedade do pai.</xref:System.Windows.FrameworkElement> Para modelos, o pai do modelo eventualmente será `null`. Para obter após esse ponto e estender a árvore lógica em que o modelo é aplicado na verdade, usar <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkElement.TemplatedParent%2A>       Observe que essa propriedade não relata pais da árvore visual em casos onde eles variam de pais árvore lógica. Pais da árvore visual não são normalmente importantes para casos gerais do aplicativo, mas podem ser elementos pai desejado em certos casos de nível visual. Consulte <xref:System.Windows.Media.VisualTreeHelper>.</xref:System.Windows.Media.VisualTreeHelper>"
  example:
  - "The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match. In this case these are properties that affect the rendering size.  \n  \n [!code-vb[GeometryDesigner#FEParentProperty](~/add/codesnippet/visualbasic/geometrydesigner/window1.xaml.vb#feparentproperty)]\n [!code-cs[GeometryDesigner#FEParentProperty](~/add/codesnippet/csharp/GeometryDesigner/Window1.xaml.cs#feparentproperty)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Pai lógico do elemento."
  overload: System.Windows.FrameworkElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  id: ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Dá suporte a implementações de layout incremental em subclasses especializadas de <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>. ParentLayoutInvalidated é chamado quando um elemento filho invalidou uma propriedade que é marcada nos metadados como afetar a medida do pai ou organizar passa durante o layout."
  remarks: "Se este elemento tem um elemento filho no qual foi invalidada, algumas propriedades e a propriedade foi marcada como <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>ou <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>nos metadados da propriedade durante o registro, esse método é invocado.</xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> </xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> A invocação de método notifica o elemento pai qual elemento filho específico deve ser medido novamente se esse elemento oferece suporte à atualização (incremental) parcial do layout.       Por padrão, <xref:System.Windows.FrameworkElement>não oferece suporte a layout incremental e de <xref:System.Windows.FrameworkElement>classe este método não tem nenhuma implementação padrão.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement> O cenário em que substituir esse método seria necessário não é comum, porque você deve modificar o comportamento padrão do sistema de layout.       Um cenário de implementação de exemplo pode ser se uma classe tem limitações de tipo de possíveis elementos filho que são significativamente mais restritivos do que o sistema de layout de nível de framework do WPF. Devido à natureza desses elementos personalizados, as alterações de propriedade podem ser adiadas deliberadamente ao implementar alguns comportamentos de layout personalizado. Por exemplo, substituições de método/organizar medidas, que tentam otimizar o elemento filho renderizar passagem, poderiam ser adiadas para determinados tipos de alterações que normalmente resultaria em outra passagem de layout."
  syntax:
    content: protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "O elemento filho a alteração de emissão de relatórios."
  overload: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Determina o próximo elemento que deve receber o foco em relação a esse elemento para uma direção de movimento foco fornecido, mas não move o foco na verdade."
  remarks: "<xref:System.Windows.FrameworkElement.MoveFocus%2A>é o método relacionado que, na verdade, move o foco.</xref:System.Windows.FrameworkElement.MoveFocus%2A>"
  example:
  - "The following example implements a handler that handles several possible button inputs, each button representing a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls PredictFocus on that element, and specifies the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided. Instead of moving to that element as <xref:System.Windows.FrameworkElement.MoveFocus%2A> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.  \n  \n [!code-cs[FocusSample#FEPredictFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#fepredictfocus)]\n [!code-vb[FocusSample#FEPredictFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#fepredictfocus)]"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "A direção para a qual uma alteração potencial foco deve ser determinada."
    return:
      type: System.Windows.DependencyObject
      description: "O próximo elemento concentrar-se moverá para se foco realmente foram percorrido. Pode retornar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o foco não pode ser movido em relação a esse elemento para a direção fornecida."
  overload: System.Windows.FrameworkElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. Estas instruções não são válidas para PredictFocus (mas eles são válidos para <xref:System.Windows.FrameworkElement.MoveFocus*>).</xref:System.Windows.FrameworkElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Fornece um acessador que simplifica o acesso para o <xref:System.Windows.NameScope>método de registro.</xref:System.Windows.NameScope>"
  remarks: "Esse método é um método conveniente para chamar <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> A implementação verificará sucessivos elementos pais até encontrar a <xref:System.Windows.NameScope>implementação, que é encontrada por localizar um elemento que implementa <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> de aplicável Para obter mais informações sobre namescopes, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Chamar RegisterName é necessário para conectar corretamente storyboards de animação para aplicativos quando criado em código. Isso ocorre porque uma chave de storyboard propriedades, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, usa uma pesquisa de nome de tempo de execução em vez de ser capaz de levar a uma referência a um elemento de destino.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Isso é verdadeiro mesmo se esse elemento é acessível por referência do código. Para obter mais informações sobre por que você precisa registrar nomes para os destinos de storyboard, consulte [Storyboards Overview](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/visualbasic/animateproperty_storyboards_vb/scopeexample.vb#namescopeexample)]
     [!code-cs[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/csharp/AnimateProperty_Storyboards_csharp/ScopeExample.cs#namescopeexample)]
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "Nome a ser usado para o mapeamento de nome do objeto especificado."
    - id: scopedElement
      type: System.Object
      description: "Objeto para o mapeamento."
  overload: System.Windows.FrameworkElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Remove o objeto fornecido da árvore lógica do elemento. <xref href=&quot;System.Windows.FrameworkElement&quot;></xref>atualiza os ponteiros do pai de árvore lógica afetados para manter em sincronização com esta exclusão."
  remarks: "Use esse método para a implementação de coleções de objetos que representam o filho lógico de um elemento. Isso pode ser feito em getters de propriedade ou setters, manipuladores de classe de `Changed` eventos, construtores, ou na coleção de tipos de si mesmos.       Para autores de controle, manipulando a árvore lógica esse nível não é a prática recomendada, a menos que nenhum dos modelos de conteúdo da classe base de controle fornecido é apropriado. Considere subclassificação no nível de <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>e <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> Essas classes fornecem um modelo de conteúdo com a imposição de específico de filhos lógicos por meio de dedicado [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)], bem como suporte para outros recursos normalmente desejáveis em um [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controle como estilo por meio de modelos."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Elemento a ser removido."
  overload: System.Windows.FrameworkElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  id: RequestBringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando <xref:System.Windows.FrameworkElement.BringIntoView*>é chamado neste elemento.</xref:System.Windows.FrameworkElement.BringIntoView*>"
  remarks: "Esse evento indica a um pai <xref:System.Windows.Controls.ScrollViewer>(ou classe derivada) que o elemento que gera o evento RequestBringIntoView deve ficar visível dentro da região rolável.</xref:System.Windows.Controls.ScrollViewer> O <xref:System.Windows.Controls.ScrollViewer>será, em seguida, marcar o evento RequestBringIntoView tratados usando a manipulação de classe de evento.</xref:System.Windows.Controls.ScrollViewer> Em geral RequestBringIntoView dados de evento não devem ser marcados tratados por qualquer classe que controlam uma região de rolagem ou por qualquer instância de manipulador, porque isso poderia interferir com o objetivo do elemento que chamado <xref:System.Windows.FrameworkElement.BringIntoView%2A>.</xref:System.Windows.FrameworkElement.BringIntoView%2A>      <a name=&quot;routedEventInfo_RequestBringIntoView&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|   | Estratégia de roteamento | Bolha |   | Delegado | <xref:System.Windows.RequestBringIntoViewEventHandler>|</xref:System.Windows.RequestBringIntoViewEventHandler></xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>"
  syntax:
    content: public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;
    return:
      type: System.Windows.RequestBringIntoViewEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  id: RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.RequestBringIntoView&quot;> </xref> eventos roteados."
  syntax:
    content: public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Resources
  id: Resources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o dicionário de recursos definidos localmente."
  remarks: "Dicionários de recursos que podem ser definidos completamente ou parcialmente em [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] normalmente são criadas como um elemento de propriedade e são normalmente no elemento raiz de qualquer página individual ou para o aplicativo. Colocar o dicionário de recurso com esse nível torna mais fácil a localização de elementos filho individual na página (ou de qualquer página, no caso de aplicativo). Na maioria dos cenários de aplicativo, é recomendável que os estilos seja definida como elementos de objeto dentro de um dicionário de recursos, ou ser definido como recursos externos para que o recurso de estilo inteiro pode ser independente (essa abordagem ajuda a separar designers responsabilidades de responsabilidades do desenvolvedor, separando arquivos físicos que precisam ser editadas).       Observe que essa propriedade retorna o dicionário de recurso declarado diretamente dentro desse elemento. Isso é diferente do processo de pesquisa de recurso real, em que um elemento filho pode acessar qualquer um dos recursos definidos em cada elemento pai, pesquisa recursivamente para cima.       Recursos também podem ser referenciados pelo código de dentro da coleção, mas lembre-se de que os recursos criados em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definitivamente não estará acessível até depois <xref:System.Windows.FrameworkElement.Loaded>é gerado pelo elemento que declara o dicionário.</xref:System.Windows.FrameworkElement.Loaded> Na verdade, os recursos são analisados e de forma assíncrona não até o <xref:System.Windows.FrameworkElement.Loaded>evento é uma garantia de que você pode fazer referência a um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definido pelo recurso.</xref:System.Windows.FrameworkElement.Loaded> Por esse motivo geralmente só deve acessar [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definido recursos como parte do código de tempo de execução ou por meio de outros [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] técnicas, como estilos ou referências de extensão de recurso para valores de atributo. Ao acessar recursos através do código, é essencialmente equivalente a uma referência feita no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       Subjacente <xref:System.Windows.ResourceDictionary>suporta os métodos necessários para adicionar, remover ou consultar recursos de dentro da coleção por meio de código.</xref:System.Windows.ResourceDictionary> A propriedade de recursos é configurável para dar suporte ao cenário de substituir completamente a coleção de recursos de um elemento para ser um novo ou diferente <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Observe que o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sintaxe mostrada não incluir um elemento para <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Este é um exemplo da sintaxe de coleção implícita; uma marca que representa o elemento de coleção pode ser omitida. Os elementos que são adicionados como itens na coleção são especificados em vez disso. Para obter mais informações sobre coleções implícita e [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], consulte [XAML sintaxe em detalhes](~/add/includes/ajax-current-ext-md.md). Um caso onde um <xref:System.Windows.ResourceDictionary>ainda estão especificadas explicitamente como um elemento é se você está implantando um dicionário mesclado, caso em que há normalmente não há elementos filho para esse <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Para obter detalhes, consulte [dicionários de recursos mesclados](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a># # Uso do elemento de propriedade de XAML ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> # # XAML valores *oneOrMoreResourceElements* um ou mais elementos de objeto, cada uma delas define um recurso.       Cada elemento de propriedade de recurso dentro de cada <xref:System.Windows.ResourceDictionary>deve ter um valor exclusivo para o [diretiva X:Key](~/add/includes/ajax-current-ext-md.md), que serve como a chave exclusiva quando os valores são recuperados de <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "O dicionário atual do definida localmente de recursos, onde cada recurso pode ser acessado por chave."
  overload: System.Windows.FrameworkElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anexa uma associação a esse elemento, com base no nome de propriedade de origem fornecido como uma qualificação de caminho para a fonte de dados."
  remarks: "Esse método é um método conveniente para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, que passa a instância atual como o <xref:System.Windows.DependencyObject>e cria um novo <xref:System.Windows.Data.Binding>com base em fornecidos `path` parâmetro.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Esta assinatura é mais conveniente se você estiver estabelecendo uma associação simples padrão. Se você precisa especificar as propriedades de associação para condições não padrão ou se desejar usar um <xref:System.Windows.Data.MultiBinding>ou <xref:System.Windows.Data.PriorityBinding>, você deve usar o <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>assinatura.</xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding using a specific path.  \n  \n [!code-cs[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#setbindingpath)]\n [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#setbindingpath)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifica a propriedade de destino onde a associação deve ser estabelecida."
    - id: path
      type: System.String
      description: "O nome da propriedade de origem ou o caminho para a propriedade usada para a associação."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Registra as condições da associação. Esse valor de retorno pode ser útil para verificação de erro."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anexa uma associação a esse elemento, com base no objeto de associação fornecido."
  remarks: "Esse método é um método conveniente para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, que passa a instância atual como <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifica a propriedade onde a associação deve ser estabelecida."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Representa as especificações da associação de dados."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Registra as condições da associação. Esse valor de retorno pode ser útil para verificação de erro."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  id: SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Define o valor da <xref:System.Windows.FrameworkElement.FlowDirection*>anexado a propriedade do elemento fornecido.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "Este método dá suporte a sintaxe da propriedade anexada para o <xref:System.Windows.FrameworkElement.FlowDirection%2A>propriedade, portanto, permitindo que o filho elementos de um fornecido <xref:System.Windows.FrameworkElement>para especificar a direção de fluxo para a organização em seu elemento pai.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> Para definir o valor no atual <xref:System.Windows.FrameworkElement>, use o direct [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] acessador <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "O elemento que especifica uma direção de fluxo."
    - id: value
      type: System.Windows.FlowDirection
      description: "Um valor de enumeração, especificando a direção."
  overload: System.Windows.FrameworkElement.SetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pesquisa um recurso com o nome especificado e define uma referência de recurso para ele para a propriedade especificada."
  remarks: "Uma referência de recurso é semelhante ao uso de um [DynamicResource Markup Extension](~/add/includes/ajax-current-ext-md.md) na marcação. A referência de recurso cria uma expressão interna que fornece o valor da propriedade especificada em uma base de tempo de execução adiada. A expressão será avaliada novamente sempre que o dicionário de recurso indica um valor alterado por meio de eventos internos ou sempre que o elemento atual é alterado o nível superior (uma alteração de pai alteraria o caminho de pesquisa de dicionário)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade à qual o recurso está associado."
    - id: name
      type: System.Object
      description: "O nome do recurso."
  overload: System.Windows.FrameworkElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna se processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Resources*>propriedade.</xref:System.Windows.FrameworkElement.Resources*>"
  remarks: "Isso retornará `true` enquanto houver pelo menos um recurso com chave local <xref:System.Windows.FrameworkElement.Resources%2A>.</xref:System.Windows.FrameworkElement.Resources%2A>"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Resources*>o valor da propriedade deve ser serializado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Resources*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna se processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Style*>propriedade.</xref:System.Windows.FrameworkElement.Style*>"
  remarks: "Isso retornará `true` se o <xref:System.Windows.Style>é definido localmente.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Style*>o valor da propriedade deve ser serializado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Style*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  id: ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna se processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Triggers*>propriedade.</xref:System.Windows.FrameworkElement.Triggers*>"
  remarks: "Este método retorna `true` se o <xref:System.Windows.FrameworkElement.Triggers%2A>localmente está definida.</xref:System.Windows.FrameworkElement.Triggers%2A>"
  syntax:
    content: public bool ShouldSerializeTriggers ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Triggers*>o valor da propriedade deve ser serializado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Triggers*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChanged
  id: SizeChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando qualquer o <> </> *> ou <> </> *> propriedades alteram valor neste elemento."
  remarks: "Os eventos roteados diretos não seguem uma rota, somente são tratados dentro do mesmo elemento no qual eles são gerados. Eventos roteados diretos suportam outro comportamento eventos roteados: eles dão suporte a uma coleção de manipuladores acessível e pode ser usados como um <xref:System.Windows.EventTrigger>em um estilo.</xref:System.Windows.EventTrigger>       O sistema de layout lê propriedades dentro de <xref:System.Windows.SizeChangedEventArgs>classe de argumento desse evento, para determinar se as alterações de tamanho relatado devem ser consideradas significativas.</xref:System.Windows.SizeChangedEventArgs> Isso permite que o sistema de layout ou de suas implementações de layout de controle específicos para evitar a imposição de uma alteração de layout devido a diferenças visualmente imperceptível entre valores de largura ou altura antiga e nova. As diferenças imperceptível podem ser devido a cálculos de arredondamento ou mesmo resultado um ponto flutuante de tipos de dados.      <a name=&quot;routedEventInfo_SizeChanged&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.SizeChangedEvent>|   | Estratégia de roteamento | Direct |   | Delegado | <xref:System.Windows.SizeChangedEventHandler>|</xref:System.Windows.SizeChangedEventHandler></xref:System.Windows.FrameworkElement.SizeChangedEvent>"
  syntax:
    content: public event System.Windows.SizeChangedEventHandler SizeChanged;
    return:
      type: System.Windows.SizeChangedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  id: SizeChangedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent SizeChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o valor de origem é alterado para qualquer propriedade existente neste elemento de associação."
  remarks: "Esse evento cria um alias para o <xref:System.Windows.Data.Binding.SourceUpdated>evento que é gerado por qualquer <xref:System.Windows.Data.Binding>associado a este elemento.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a># # Uso do atributo XAML```   <object SourceUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Style
  id: Style
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o estilo usado por este elemento quando ele for renderizado."
  remarks: "Para controles, o estilo atual normalmente é fornecido por um estilo de padrão de temas de controle, ou de estilos geralmente aplicado aos controles desse tipo por recursos no nível do aplicativo ou página (um estilo implícito). Essa propriedade não padrão não definido ou retorno estilos (tema), mas ela retorna um estilo implícito ou um estilo explícito que está atuando no elemento. No caso de estilos implícitos ou explícitos, não importa se o estilo é especificado como um recurso ou definido localmente.       Definir os estilos tem algumas restrições. Você pode redefinir a propriedade de estilo inteira para um novo <xref:System.Windows.Style>a qualquer momento, forçando uma recomposition de layout.</xref:System.Windows.Style> No entanto, assim que esse estilo é colocado em uso por um elemento carregado, o <xref:System.Windows.Style>devem ser consideradas lacrado.</xref:System.Windows.Style> Tentativa de alterar qualquer propriedade individual de um estilo em uso (como qualquer coisa dentro da coleção de <xref:System.Windows.Style.Setters%2A>) faz com que uma exceção seja lançada.</xref:System.Windows.Style.Setters%2A> Um estilo que é definido na marcação é considerado para estar em uso assim que ele é carregado de um dicionário de recurso (para recursos), ou a página que está contida na for carregada (para estilos embutidos).       Estilo é uma propriedade de dependência com precedência especial. Definido localmente estilo geralmente opera na precedência mais alta no sistema de propriedade. Se o estilo for null, neste momento, durante o carregamento a propriedade sistema verifica estilos implícitos em recursos locais ou aplicativos que especificam o tipo. Se o estilo for nulo ainda após essa etapa, o estilo de ação para fins de apresentação geralmente vêm de estilo padrão (tema), mas o estilo padrão não é retornado no valor de propriedade de estilo. Consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md) ou [estilos e modelagem](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a># # Uso do atributo XAML ```   <object Style=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Style&quot;> </a> # # uso do elemento de propriedade XAML <a name=&quot;xamlValues_Style&quot;> </a> # # XAML valores *resourceExtension* um dos seguintes:, ou.       Consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* a chave que identifica o estilo que está sendo solicitado. A chave refere-se a um recurso existente em <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Sintaxe de elemento de propriedade é tecnicamente possível, mas não recomendado na maioria dos cenários de estilo. Consulte [modelos e estilos in-line](~/add/includes/ajax-current-ext-md.md). Uma referência de associação usando ou <xref:System.Windows.Data.Binding>também é possível, mas raro.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.StyleProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.StyleProperty>"
  example:
  - "The following example defines a style in a resource dictionary.  \n  \n [!code-xml[FEResource#StyleProperty](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty)]  \n[!code-xml[FEResource#StyleProperty2](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty2)]  \n[!code-xml[FEResource#StyleProperty3](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty3)]  \n[!code-xml[FEResource#StyleProperty4](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty4)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "O estilo aplicado, de não padrão para o elemento, se presente. Caso contrário, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. O padrão para um padrão construído <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Style*>DependencyProperty.</xref:System.Windows.FrameworkElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Para obter uma descrição desse membro, consulte o <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>método.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Esse membro é uma implementação de membro de interface explícita. Ele pode ser usado somente quando o <xref:System.Windows.FrameworkElement>instância é convertida em um <xref:System.Windows.Markup.IQueryAmbient>interface.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "O nome da propriedade ambiente solicitado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se <code> propertyName </code> estiver disponível; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Tag
  id: Tag
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor de objeto arbitrário que pode ser usado para armazenar informações personalizadas sobre este elemento."
  remarks: "Essa propriedade é análoga a propriedades da marca em outros [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] modelos de programação como [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] ou [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Marca destina-se a fornecer um local de propriedade pré-existente, onde você pode armazenar alguns básicas informações personalizadas sobre qualquer <xref:System.Windows.FrameworkElement>sem a necessidade de subclasse de um elemento.</xref:System.Windows.FrameworkElement>       Como essa propriedade usa um objeto, você precisa usar o uso do elemento de propriedade para definir a propriedade de marca no [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] para algo diferente de um objeto com um conversor de tipo conhecido e internos, como uma cadeia de caracteres. Objetos usados dessa maneira normalmente não estão dentro do padrão [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] namespaces e, portanto, podem exigir o mapeamento de namespace para o namespace externo para ser apresentado como [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementos. Para obter detalhes, consulte [Namespaces XAML e o mapeamento de Namespace para WPF XAML](~/add/includes/ajax-current-ext-md.md) e [XAML e Classes personalizadas para WPF](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.TagProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "O valor desejado. Essa propriedade não tem valor padrão."
  overload: System.Windows.FrameworkElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Tag*>DependencyProperty.</xref:System.Windows.FrameworkElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o valor de destino é alterado para qualquer associação de propriedade neste elemento."
  remarks: "Esse evento cria um alias para o <xref:System.Windows.Data.Binding.TargetUpdated>evento que é gerado por qualquer <xref:System.Windows.Data.Binding>associado a este elemento.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Geralmente, isso significa que a associação em questão é uma associação bidirecional, e que a propriedade de dependência associado confirmará que o valor da propriedade anterior agora é inválido de acordo com qualquer validação ou esquema de cache que dão suporte a propriedade ou a fonte de dados.       Use os dados de eventos do evento TargetUpdated para determinar a propriedade específica que está relatando a atualização do valor de destino.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a># # Uso do atributo XAML```   <object TargetUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém uma referência para o pai do modelo deste elemento. Essa propriedade não é relevante se o elemento não foi criado por meio de um modelo."
  remarks: "TemplatedParent é frequentemente `null` para objetos que são criados na sua marcação de aplicativo ou código. Isso ocorre porque você cria esses objetos diretamente, não por meio de um modelo. Obtido percorrendo a árvore lógica da raiz, ou por referências de nome típico de referências de objeto, não vêm de um modelo.       Casos onde TemplatedParent não pode ser `null` incluem operações como teste de clique, a manipulação de eventos para certos eventos de entrada baixo nível, percorra a árvore visual com <xref:System.Windows.Media.VisualTreeHelper>, ou trabalhar com enumeradores, que podem retornar os elementos que veio modelos.</xref:System.Windows.Media.VisualTreeHelper> Outra situação é se você chamar especificamente <xref:System.Windows.FrameworkTemplate.FindName%2A>em relação a um existente <xref:System.Windows.FrameworkTemplate>e trabalhar com o objeto retornado.</xref:System.Windows.FrameworkTemplate> </xref:System.Windows.FrameworkTemplate.FindName%2A>       Modelos são objetos compartilhados na verdade, onde o conteúdo do modelo é criado apenas uma vez. Portanto, se você obtiver uma referência de objeto para um elemento que veio de um modelo, você pode achar que a árvore lógica aparente não acessar a raiz da página. Para conectar-se uma referência de modelo de árvore lógica da página, você deve obter o valor de TemplatedParent e continuar a navegar árvore elemento conforme desejado."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "O elemento cujo <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>causou esse elemento a ser criado.</xref:System.Windows.FrameworkTemplate.VisualTree*> Esse valor é frequentemente <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; consulte comentários."
  overload: System.Windows.FrameworkElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o objeto de dica de ferramenta é exibido para esse elemento no [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Se o valor dessa propriedade é do tipo <xref:System.Windows.Controls.ToolTip>, em seguida, esse valor é a dica de ferramenta que será usada no [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Se o valor for de qualquer outro tipo, esse valor será usado como o *conteúdo* para um <xref:System.Windows.Controls.ToolTip>fornecido (construído) pelo sistema.</xref:System.Windows.Controls.ToolTip> Para obter mais informações, consulte <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> A classe de serviço fornece as propriedades anexadas que podem ser usadas para personalizar um <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a># # Uso do atributo XAML ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> # # uso do elemento de propriedade XAML ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> # # XAML valores *toolTipContent* uma cadeia de caracteres que se torna o texto de exibição para a dica de ferramenta.                   *toolTipObjectContent* algum objeto fornecido na forma de elemento de objeto, que deve ser usada como o conteúdo para <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Geralmente isso seria um <xref:System.Windows.FrameworkElement>ou algum outro elemento que cria a composição de layout para a dica de ferramenta, eventualmente que contém texto conteúdo dentro da composição.</xref:System.Windows.FrameworkElement> Nesse exemplo, o <xref:System.Windows.Controls.ToolTip>elemento é criado implicitamente de analisada [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]e o *toolTipObjectContent* o conteúdo está definido como seu <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>propriedade.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ToolTipProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ToolTipProperty>"
  example:
  - "The following example creates a <xref:System.Windows.Controls.ToolTip> in code and then sets the ToolTip property on a <xref:System.Windows.Controls.Primitives.StatusBar> control.  \n  \n [!code-vb[StatusBar#MakeProgressBar](~/add/codesnippet/visualbasic/statusbar/window1.xaml.vb#makeprogressbar)]\n [!code-cs[StatusBar#MakeProgressBar](~/add/codesnippet/csharp/StatusBar/Window1.xaml.cs#makeprogressbar)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "O objeto de dica de ferramenta. Consulte os comentários abaixo para obter detalhes sobre por que esse parâmetro não é fortemente tipado."
  overload: System.Windows.FrameworkElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre pouco antes do fechamento de qualquer dica de ferramenta no elemento."
  remarks: "Marcar o evento ToolTipClosing tratados não cancelar fechando a dica de ferramenta. Depois que a dica de ferramenta é exibida, fechando a dica de ferramenta é feito apenas em resposta à interação do usuário com a interface do usuário.       Esse evento não pode ser um <xref:System.Windows.EventTrigger>em um estilo.</xref:System.Windows.EventTrigger> Isso ocorre porque o campo de identificador desse evento reutiliza uma implementação de um serviço que não expõe métodos de adicionar ou remover de evento para o evento de nível de serviço.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|   | Estratégia de roteamento | Direct |   | Delegado | <xref:System.Windows.Controls.ToolTipEventHandler>|      -Substituir <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>para implementar a manipulação de classe para esse evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando qualquer dica de ferramenta no elemento é aberta."
  remarks: "Para impedir que uma dica de ferramenta que aparece na interface do usuário, o manipulador para ToolTipOpening pode marcar a <xref:System.Windows.Controls.ToolTipEventArgs>dados de eventos manipulados.</xref:System.Windows.Controls.ToolTipEventArgs> Caso contrário, a dica de ferramenta é exibida, usando o valor da <xref:System.Windows.FrameworkElement.ToolTip%2A>a propriedade como o conteúdo da dica de ferramenta.</xref:System.Windows.FrameworkElement.ToolTip%2A> Outro cenário possível é que você pode escrever um manipulador que redefine o valor de <xref:System.Windows.FrameworkElement.ToolTip%2A>propriedade para o elemento que é a origem do evento, antes que a dica de ferramenta é exibida.</xref:System.Windows.FrameworkElement.ToolTip%2A>       ToolTipOpening não será gerado se o valor de <xref:System.Windows.FrameworkElement.ToolTip%2A>é `null` ou de outra forma unset.</xref:System.Windows.FrameworkElement.ToolTip%2A> Não defina deliberadamente <xref:System.Windows.FrameworkElement.ToolTip%2A>para `null` enquanto uma dica de ferramenta está aberta ou abrindo; isso não terá o efeito de fechamento a dica de ferramenta e em vez disso, criará um artefato visual indesejável na interface de usuário.</xref:System.Windows.FrameworkElement.ToolTip%2A>       O evento ToolTipOpening não pode ser um <xref:System.Windows.EventTrigger>em um estilo.</xref:System.Windows.EventTrigger> Isso ocorre porque o campo de identificador desse evento reutiliza uma implementação de um serviço que não expõe métodos de adicionar ou remover de evento para o evento de nível de serviço.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|   | Estratégia de roteamento | Direct |   | Delegado | <xref:System.Windows.Controls.ToolTipEventHandler>|      -Substituir <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>para implementar a manipulação de classe para esse evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ToolTip*>DependencyProperty.</xref:System.Windows.FrameworkElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Triggers
  id: Triggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a coleção de gatilhos estabelecida diretamente no elemento ou elementos filho."
  remarks: "> [!NOTE]> Esta propriedade só pode ser definida [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] por meio de mostra a sintaxe de coleção, ou acessar o objeto de coleção e usar seus vários métodos, como adicionar. A propriedade para acessar o objeto de coleção é somente leitura, a coleção em si é leitura / gravação. A propriedade existe somente em elementos raiz; tentando encontrá-lo ou defini-lo em outro lugar fará com que uma exceção seja lançada.       Essa propriedade permite que você examine gatilhos que existem como parte de estilos em uso neste elemento. O utilitário só reporta a coleção de gatilhos literalmente são adicionados à coleção, na marcação ou código. Elementos normalmente não tem elementos existentes por padrão (por meio de um modelo para a instância); é mais comum para gatilhos que vêm de composição de controle seja estabelecida em estilos.       Em termos de comportamento (e tentando estabelecer quais efeito veio de qual elemento declarado coleta de disparadores), a condição de disparo e o efeito do gatilho podem ser neste elemento, ou podem estar em seus elementos filho na árvore lógica. Observe que, se você usar eventos de tempo de vida, como <xref:System.Windows.FrameworkElement.Loaded>para obter essa coleção, os gatilhos do elemento filho não ainda seja totalmente carregados e a coleção será menor do que seria realmente em tempo de execução.</xref:System.Windows.FrameworkElement.Loaded>       Observe que a coleção de gatilhos estabelecida em um elemento só oferece suporte a <xref:System.Windows.EventTrigger>, não os disparadores de propriedade (<xref:System.Windows.Trigger>).</xref:System.Windows.Trigger> </xref:System.Windows.EventTrigger> Se você precisar de disparadores de propriedade, você deve colocá-los em um estilo ou modelo e, em seguida, atribuir esse estilo ou modelo para o elemento ou diretamente por meio de <xref:System.Windows.FrameworkElement.Style%2A>propriedade, ou indiretamente por meio de uma referência de estilo implícito.</xref:System.Windows.FrameworkElement.Style%2A>      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # Uso do elemento de propriedade de XAML ```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML valores *oneOrMoreTriggers* um ou mais definido <xref:System.Windows.EventTrigger>elementos.</xref:System.Windows.EventTrigger>       Cada gatilho tal deve conter referências e ações de storyboard válida. Observe que esta coleção só pode ser estabelecida no elemento raiz de uma página. Para obter mais informações, consulte [Storyboards Overview](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "Uma coleção fortemente tipada de <xref href=&quot;System.Windows.Trigger&quot;> </xref> objetos."
  overload: System.Windows.FrameworkElement.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um recurso com a chave especificada e retorna esse recurso se encontrado."
  remarks: "Se o recurso não foi encontrado no elemento de chamada, a árvore de recursos pai é pesquisada para cima através de árvore lógica, da mesma forma que a árvore será pesquisada se um recurso foi solicitado por chave em tempo de execução. O método retorna `null` somente se nenhum recurso de chave existia em qualquer lugar na árvore de recursos, por condições existentes da árvore no momento em que TryFindResource é chamado.       Normalmente você imediatamente atribui o valor de retorno para o tipo da propriedade que você está tentando definido com o valor retornado do recurso.       O <xref:System.Windows.FrameworkElement.FindResource%2A>método tem um comportamento semelhante, exceto que ele lança uma exceção se nenhum recurso com a chave fornecida foi retornado.</xref:System.Windows.FrameworkElement.FindResource%2A>"
  example:
  - "The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling TryFindResource on itself. This walks the element tree and finds the resource (the resource itself is defined in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] and is not shown).  \n  \n [!code-cs[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#fetryfindresource)]\n [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#fetryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O identificador de chave de recurso a ser localizado."
    return:
      type: System.Object
      description: "O recurso encontrado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso com fornecido <code> key </code> foi encontrado."
  overload: System.Windows.FrameworkElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o elemento é removido de uma árvore de elementos carregados."
  remarks: "Os eventos roteados diretos não seguem uma rota, somente são tratados dentro do mesmo elemento no qual eles são gerados. Eventos roteados diretos suportam outro comportamento eventos roteados: eles dão suporte a uma coleção de manipuladores acessível e pode ser usados como um <xref:System.Windows.EventTrigger>em um estilo.</xref:System.Windows.EventTrigger>       <xref:System.Windows.FrameworkElement.Loaded>e Unloaded pode ser ambos gerado em controles como resultado das alterações de tema do sistema iniciada pelo usuário.</xref:System.Windows.FrameworkElement.Loaded> Uma alteração de tema faz com que um invalidação do modelo de controle e a árvore visual independente, que por sua vez faz com que todo o controle descarregar e recarregar. Portanto Unloaded não é considerado como ocorrem somente na navegação para fora da página.       Observe que o evento Unloaded não é gerado depois que um aplicativo começa o desligamento. Encerramento do aplicativo ocorre quando a condição definida pelo <xref:System.Windows.Application.ShutdownMode%2A>propriedade ocorre.</xref:System.Windows.Application.ShutdownMode%2A> Se você colocar o código de limpeza dentro de um manipulador para o evento Unloaded, por exemplo, para um <xref:System.Windows.Window>ou um <xref:System.Windows.Controls.UserControl>, ele não pode ser chamado conforme o esperado.</xref:System.Windows.Controls.UserControl> </xref:System.Windows.Window>      <a name=&quot;routedEventInfo_Unloaded&quot;></a># # Roteadas informações de evento | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.UnloadedEvent>|   | Estratégia de roteamento | Direct |   | Delegado | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.Unloaded&quot;> </xref> eventos roteados."
  remarks: "Identificadores de eventos roteados são criados quando os eventos roteados são registrados. Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento. Você pode usar esses identificadores para adicionar manipuladores de classe.       Para obter mais informações sobre como registrar eventos roteados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Simplifica o acesso para o <xref:System.Windows.NameScope>cancelamento de registro de método.</xref:System.Windows.NameScope>"
  remarks: "Você só precisa cancelar o registro nomes se você pretende registrar novamente o outro elemento com o mesmo nome."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Nome do par de nome de objeto para remover do escopo atual."
  overload: System.Windows.FrameworkElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Reaplica o estilo padrão atual <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  id: UseLayoutRounding
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se o arredondamento de layout deve ser aplicado para o tamanho e a posição do elemento durante o layout."
  remarks: "Quando a propriedade UseLayoutRounding para um elemento for `true`, todos os valores de pixel integral não são calculados durante o <xref:System.Windows.UIElement.Measure%2A>e <xref:System.Windows.UIElement.Arrange%2A>passa é arredondadas para valores de pixel inteiro.</xref:System.Windows.UIElement.Arrange%2A> </xref:System.Windows.UIElement.Measure%2A>       Essa propriedade é herdada por elementos filho.      > [!NOTE] > UseLayoutRounding deve ser definido como `true` no elemento raiz. O sistema de layout adiciona coordenadas filho com as coordenadas pai; Portanto, se as coordenadas pai não estiverem em um limite de pixel, as coordenadas de filho também não são em um limite de pixel. Se UseLayoutRounding não pode ser definida na raiz, defina <xref:System.Windows.UIElement.SnapsToDevicePixels%2A>no filho para obter o efeito desejado.</xref:System.Windows.UIElement.SnapsToDevicePixels%2A>       Objetos de desenho em limites de pixel elimina as bordas semitransparentes que são produzidas por suavização, quando uma borda fica no meio de um pixel de dispositivo. A ilustração a seguir mostra a saída de uma linha de largura de pixel único que está no meio de um pixel de dispositivo. A linha à esquerda não use o arredondamento de layout e é sem alias. A linha à direita usa arredondamento de layout.       ![Linha de suavização em comparação comparada a linha de pixel único. ] (~/add/media/pixelsnaplinecompare.PNG &quot;Linha suavizada comparada à linha de pixel único.&quot;)       Quando você usa arredondamento de layout e <xref:System.Windows.GridUnitType>de dimensionamento, o sistema de layout cria pequenas variações nas medidas de linha ou coluna para evitar a renderização sub-pixel.</xref:System.Windows.GridUnitType> Por exemplo, se uma grade tem uma largura total de 100 com 3 colunas de tamanho <xref:System.Windows.GridUnitType>, em vez de criar três colunas que têm uma largura igual de 33,3, o sistema de layout cria 2 colunas que têm uma largura de 33 e um que tenha uma largura de 34.</xref:System.Windows.GridUnitType>      > [!NOTE] > Foram feitas alterações no .NET 4.6 para layout de arredondamento para reduzir as instâncias de recorte em controles com bordas. Por padrão, esse recurso é habilitado se a estrutura de destino é .NET Framework 4.6 ou posterior. Aplicativos que versões anteriores do framework de destino podem aceitar o novo comportamento adicionando a seguinte configuração para um arquivo App. config: `<runtime>``<AppContextSwitchOverrides      value=&quot;Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false&quot;/>``</runtime>` a configuração terá efeito somente quando o aplicativo está em execução no .NET Framework 4.6."
  example:
  - "The following example demonstrates the effect that the UseLayoutRounding property has on a single pixel-width line. The line on the left does not use layout rounding and the line on the right uses layout rounding. If you slowly resize the window, you can see the difference that layout rounding makes.  \n  \n```xaml  \n  \n<Page x:Class=\"LayoutRounding.Lines\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Lines\" Name=\"linesPage\"  \n    >  \n  <StackPanel Width=\"150\"  Margin=\"7\" Orientation=\"Horizontal\">  \n    <!-- Single pixel line with layout rounding turned OFF.-->  \n    <Rectangle UseLayoutRounding=\"False\"  \n       Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n    <!-- Single pixel line with layout rounding turned ON.-->  \n    <Rectangle UseLayoutRounding=\"True\"  \n      Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n  </StackPanel>  \n  <!-- Background Grid -->  \n  <Page.Background>  \n    <DrawingBrush  Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\" TileMode=\"Tile\">  \n      <DrawingBrush.Drawing>  \n        <DrawingGroup>  \n          <GeometryDrawing Brush=\"White\">  \n            <GeometryDrawing.Geometry>  \n              <RectangleGeometry Rect=\"0,0,1,1\" />  \n            </GeometryDrawing.Geometry>  \n          </GeometryDrawing>  \n          <GeometryDrawing Geometry=\"M0,0 L1,0 1,0.1, 0,0.1Z \" Brush=\"#CCCCFF\" />  \n          <GeometryDrawing Geometry=\"M0,0 L0,1 0.1,1, 0.1,0Z\" Brush=\"#CCCCFF\" />  \n        </DrawingGroup>  \n      </DrawingBrush.Drawing>  \n    </DrawingBrush>  \n  </Page.Background>  \n</Page>  \n```"
  syntax:
    content: public bool UseLayoutRounding { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o arredondamento de layout é aplicado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.UseLayoutRounding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  id: UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.UseLayoutRounding*>DependencyProperty.</xref:System.Windows.FrameworkElement.UseLayoutRounding*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignment
  id: VerticalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define as características de alinhamento vertical aplicadas a este elemento quando ele é composto de um elemento pai como um painel ou controle de itens."
  remarks: "Quando <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.Width%2A>propriedades são definidas explicitamente em um elemento, essas medidas levar precedentes de layout e cancelam os efeitos de definir esta propriedade para <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> </xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>       VerticalAlignment é o [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] acessador de propriedade para o que é na verdade uma propriedade de dependência. Essa propriedade de dependência particular com bastante frequência tem seu valor aparente &quot;padrão&quot; definido em classes de elemento derivado, particularmente os controles de modo diferente. Isso geralmente ocorre em uma das duas maneiras: a propriedade de dependência é registrada novamente para uma determinada classe derivada, mas com diferentes metadados para a configuração de seus padrões; ou há um estilo de padrão que está sendo aplicado que define esse valor de propriedade de dependência de maneira diferente. Por exemplo, o aparente &quot;padrão&quot; de VerticalAlignment para um <xref:System.Windows.Controls.ComboBoxItem>controle será <xref:System.Windows.VerticalAlignment>, mesmo que <xref:System.Windows.Controls.ComboBoxItem>herda direta VerticalAlignment de <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> Isso ocorre porque esse valor foi redefinida no estilo padrão de <xref:System.Windows.Controls.ComboBoxItem>, no modelo de controle de style.</xref:System.Windows.Controls.ComboBoxItem>       <xref:System.Windows.Controls.Canvas>não usar VerticalAlignment ao compor o layout, pois <xref:System.Windows.Controls.Canvas>baseia-se no posicionamento absoluto.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       Quando herdado por <xref:System.Windows.Controls.ComboBoxItem>ou qualquer classe derivada, <xref:System.Windows.Controls.ComboBoxItem>redefine o valor padrão dessa propriedade para ser <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.Controls.ComboBoxItem>      <a name=&quot;dependencyPropertyInfo_VerticalAlignment&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>"
  syntax:
    content: public System.Windows.VerticalAlignment VerticalAlignment { get; set; }
    return:
      type: System.Windows.VerticalAlignment
      description: "Uma configuração de alinhamento vertical. O padrão é <xref href=&quot;System.Windows.VerticalAlignment&quot;> </xref>."
  overload: System.Windows.FrameworkElement.VerticalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  id: VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.VerticalAlignment*>DependencyProperty.</xref:System.Windows.FrameworkElement.VerticalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  id: VisualChildrenCount
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o número de elementos filhos visuais dentro deste elemento."
  remarks: "O <xref:System.Windows.FrameworkElement>implementação VisualChildrenCount sempre retorna zero ou um.</xref:System.Windows.FrameworkElement> As classes que mantêm uma coleção de filhos visuais que pode exceder uma devem substituir essa propriedade e o <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.</xref:System.Windows.FrameworkElement.GetVisualChild%2A>       Essa propriedade é geralmente usada para determinar os limites superiores da coleção filho atual para fins de implementar as substituições de layout (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A>"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children and reports these values through overrides of VisualChildrenCount and <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override int VisualChildrenCount { get; }
    return:
      type: System.Int32
      description: "O número de elementos filho de visual para este elemento."
  overload: System.Windows.FrameworkElement.VisualChildrenCount*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Width
  id: Width
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a largura do elemento."
  remarks: "Esta é uma das três propriedades em <xref:System.Windows.FrameworkElement>que especificam as informações de largura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.MinWidth%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>  Se houver um conflito entre esses valores, a ordem do aplicativo para a determinação de largura real é primeiro <xref:System.Windows.FrameworkElement.MinWidth%2A>devem ser cumprido, em seguida, <xref:System.Windows.FrameworkElement.MaxWidth%2A>e, finalmente, se cada um deles está dentro dos limites, largura.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       O valor de retorno dessa propriedade é sempre igual a qualquer valor que foi definido para ele. Em contraste, o valor de <xref:System.Windows.FrameworkElement.ActualWidth%2A>podem variar.</xref:System.Windows.FrameworkElement.ActualWidth%2A> O layout pode ter o tamanho sugerido rejeitada por algum motivo. Além disso, o sistema de layout funciona de forma assíncrona em relação ao conjunto de sistema de propriedades de largura e pode não ter processado específico dimensionamento de alteração de propriedade ainda.       Além de aceitável <xref:System.Double>valores, essa propriedade também podem ser <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> Isso é como especificar comportamento de dimensionamento automático. Em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] você definir o valor para a cadeia de caracteres &quot;Automática&quot; (não diferencia maiusculas de minúsculas) para habilitar o comportamento de dimensionamento de auto. Comportamento de dimensionamento de auto implica que o elemento preencher a largura disponível para ele. No entanto, observe que os controles específicos frequentemente fornecem valores padrão em seus estilos padrão que irá desabilitar o auto comportamento de dimensionamento, a menos que ela seja reativada especificamente.       Além de verificação de validação, há um valor de superior não determinístico vinculado a largura que é imposta pelo sistema de layout (Este é um número muito grande, maior do que <xref:System.Single.MaxValue?displayProperty=fullName>mas menor do que <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> Se você exceder esse associado, o elemento não será processada e nenhuma exceção é lançada. Não defina largura como um valor que é significativamente maior do que o tamanho máximo de qualquer exibição visual possíveis, ou pode exceder esse limite superior não determinístico.      <a name=&quot;xamlAttributeUsage_Width&quot;></a># # Uso do atributo XAML ```   <object Width=&quot;double&quot;/>   - or –   <object Width =&quot;qualifiedDouble&quot;/>   - or -   <object Width =&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Width&quot;> </a> # # XAML valores *duplo* <xref:System.Double> representação de cadeia de caracteres um <xref:System.Double>valor igual ou maior que 0.0.</xref:System.Double> </xref:System.Double>           Consulte comentários para obter informações de limite superior. Esse valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, um valor de `1` é aceitável.       *qualifiedDouble* um *duplo* valor conforme descrito acima, seguido por um dos seguintes unidade declaração cadeias de caracteres: `px`, `in`, `cm`, `pt`.       `px`(padrão) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` polegadas; em 1 = = 96px `cm` centímetros; 1cm==(96/2.54) px `pt` pontos; 1pt==(96/72) px `Auto` habilita o comportamento de dimensionamento automático.        Consulte comentários.      <a name=&quot;dependencyPropertyInfo_Width&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.FrameworkElement.WidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.WidthProperty>"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "A largura do elemento, no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor padrão é &lt;xref:System.Double?displayProperty=fullName&gt;. Esse valor deve ser igual ou maior que 0.0. Consulte comentários para obter informações de limite superior."
  overload: System.Windows.FrameworkElement.Width*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.WidthProperty
  id: WidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Width*>DependencyProperty.</xref:System.Windows.FrameworkElement.Width*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.UIElement
  isExternal: false
  name: System.Windows.UIElement
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkElement.#ctor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
- uid: System.Windows.FrameworkElement.ActualHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkElement.ActualWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkElement.ApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.FrameworkElement.BeginInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Windows.FrameworkElement.BindingGroup
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
- uid: System.Windows.FrameworkElement.BringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
- uid: System.Windows.FrameworkElement.ContextMenu
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
- uid: System.Windows.FrameworkElement.Cursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkElement.CursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
- uid: System.Windows.FrameworkElement.DataContext
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DataContextChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkElement.DataContextProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkElement.EndInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
- uid: System.Windows.FrameworkElement.FindName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
- uid: System.Windows.FrameworkElement.FlowDirection
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
- uid: System.Windows.FlowDirection
  parent: System.Windows
  isExternal: false
  name: FlowDirection
  nameWithType: FlowDirection
  fullName: System.Windows.FlowDirection
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkElement.ForceCursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
- uid: System.Windows.FrameworkElement.GetUIParentCore
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
- uid: System.Windows.Media.Visual
  parent: System.Windows.Media
  isExternal: false
  name: Visual
  nameWithType: Visual
  fullName: System.Windows.Media.Visual
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.FrameworkElement.Height
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
- uid: System.Windows.HorizontalAlignment
  parent: System.Windows
  isExternal: false
  name: HorizontalAlignment
  nameWithType: HorizontalAlignment
  fullName: System.Windows.HorizontalAlignment
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
- uid: System.Windows.InheritanceBehavior
  parent: System.Windows
  isExternal: false
  name: InheritanceBehavior
  nameWithType: InheritanceBehavior
  fullName: System.Windows.InheritanceBehavior
- uid: System.Windows.FrameworkElement.Initialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkElement.InputScope
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkElement.InputScopeProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
- uid: System.Windows.FrameworkElement.IsInitialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkElement.LanguageProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
- uid: System.Windows.FrameworkElement.LayoutTransform
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
- uid: System.Windows.FrameworkElement.Loaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkElement.LoadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
- uid: System.Windows.FrameworkElement.LogicalChildren
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkElement.Margin
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
- uid: System.Windows.Thickness
  parent: System.Windows
  isExternal: false
  name: Thickness
  nameWithType: Thickness
  fullName: System.Windows.Thickness
- uid: System.Windows.FrameworkElement.MarginProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
- uid: System.Windows.FrameworkElement.MaxHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
- uid: System.Windows.FrameworkElement.MaxWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
- uid: System.Windows.FrameworkElement.MinHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
- uid: System.Windows.FrameworkElement.MinWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MinWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkElement.Name
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
- uid: System.Windows.FrameworkElement.NameProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkElement.Parent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
- uid: System.Windows.RequestBringIntoViewEventHandler
  parent: System.Windows
  isExternal: false
  name: RequestBringIntoViewEventHandler
  nameWithType: RequestBringIntoViewEventHandler
  fullName: System.Windows.RequestBringIntoViewEventHandler
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
- uid: System.Windows.FrameworkElement.Resources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
- uid: System.Windows.FrameworkElement.SizeChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
- uid: System.Windows.SizeChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: SizeChangedEventHandler
  nameWithType: SizeChangedEventHandler
  fullName: System.Windows.SizeChangedEventHandler
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
- uid: System.Windows.FrameworkElement.SourceUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkElement.Style
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
- uid: System.Windows.FrameworkElement.StyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkElement.Tag
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TagProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
- uid: System.Windows.FrameworkElement.TargetUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
- uid: System.Windows.FrameworkElement.TemplatedParent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.ToolTipClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkElement.ToolTipOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkElement.ToolTipProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
- uid: System.Windows.FrameworkElement.Triggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
- uid: System.Windows.FrameworkElement.Unloaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
- uid: System.Windows.FrameworkElement.UnloadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
- uid: System.Windows.FrameworkElement.VerticalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
- uid: System.Windows.VerticalAlignment
  parent: System.Windows
  isExternal: false
  name: VerticalAlignment
  nameWithType: VerticalAlignment
  fullName: System.Windows.VerticalAlignment
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
- uid: System.Windows.FrameworkElement.WidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
- uid: System.Windows.FrameworkElement.#ctor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement.FrameworkElement
- uid: System.Windows.FrameworkElement.ActualHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
- uid: System.Windows.FrameworkElement.ActualWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.AddLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkElement.AddLogicalChild
- uid: System.Windows.FrameworkElement.ApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate
  nameWithType: FrameworkElement.ApplyTemplate
- uid: System.Windows.FrameworkElement.ArrangeCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore
  nameWithType: FrameworkElement.ArrangeCore
- uid: System.Windows.FrameworkElement.ArrangeOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride
  nameWithType: FrameworkElement.ArrangeOverride
- uid: System.Windows.FrameworkElement.BeginInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkElement.BeginInit
- uid: System.Windows.FrameworkElement.BeginStoryboard*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkElement.BeginStoryboard
- uid: System.Windows.FrameworkElement.BindingGroup*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
- uid: System.Windows.FrameworkElement.BringIntoView*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkElement.BringIntoView
- uid: System.Windows.FrameworkElement.ContextMenu*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
- uid: System.Windows.FrameworkElement.Cursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
- uid: System.Windows.FrameworkElement.DataContext*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DefaultStyleKey*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.EndInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkElement.EndInit
- uid: System.Windows.FrameworkElement.FindName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkElement.FindName
- uid: System.Windows.FrameworkElement.FindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkElement.FindResource
- uid: System.Windows.FrameworkElement.FlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
- uid: System.Windows.FrameworkElement.FocusVisualStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
- uid: System.Windows.FrameworkElement.ForceCursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.GetBindingExpression*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkElement.GetBindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection
  nameWithType: FrameworkElement.GetFlowDirection
- uid: System.Windows.FrameworkElement.GetLayoutClip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: FrameworkElement.GetLayoutClip
- uid: System.Windows.FrameworkElement.GetTemplateChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild
  nameWithType: FrameworkElement.GetTemplateChild
- uid: System.Windows.FrameworkElement.GetUIParentCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkElement.GetUIParentCore
- uid: System.Windows.FrameworkElement.GetVisualChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild
  nameWithType: FrameworkElement.GetVisualChild
- uid: System.Windows.FrameworkElement.Height*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HorizontalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
- uid: System.Windows.FrameworkElement.InheritanceBehavior*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
- uid: System.Windows.FrameworkElement.InputScope*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
- uid: System.Windows.FrameworkElement.IsInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
- uid: System.Windows.FrameworkElement.LayoutTransform*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
- uid: System.Windows.FrameworkElement.LogicalChildren*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
- uid: System.Windows.FrameworkElement.Margin*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
- uid: System.Windows.FrameworkElement.MaxHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MeasureCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore
  nameWithType: FrameworkElement.MeasureCore
- uid: System.Windows.FrameworkElement.MeasureOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride
  nameWithType: FrameworkElement.MeasureOverride
- uid: System.Windows.FrameworkElement.MinHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MoveFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkElement.MoveFocus
- uid: System.Windows.FrameworkElement.Name*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
- uid: System.Windows.FrameworkElement.OnApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate
  nameWithType: FrameworkElement.OnApplyTemplate
- uid: System.Windows.FrameworkElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkElement.OnContextMenuClosing
- uid: System.Windows.FrameworkElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkElement.OnContextMenuOpening
- uid: System.Windows.FrameworkElement.OnGotFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkElement.OnGotFocus
- uid: System.Windows.FrameworkElement.OnInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkElement.OnInitialized
- uid: System.Windows.FrameworkElement.OnPropertyChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkElement.OnPropertyChanged
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: FrameworkElement.OnRenderSizeChanged
- uid: System.Windows.FrameworkElement.OnStyleChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkElement.OnStyleChanged
- uid: System.Windows.FrameworkElement.OnToolTipClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkElement.OnToolTipClosing
- uid: System.Windows.FrameworkElement.OnToolTipOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkElement.OnToolTipOpening
- uid: System.Windows.FrameworkElement.OnVisualParentChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: FrameworkElement.OnVisualParentChanged
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.Parent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated
  nameWithType: FrameworkElement.ParentLayoutInvalidated
- uid: System.Windows.FrameworkElement.PredictFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkElement.PredictFocus
- uid: System.Windows.FrameworkElement.RegisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkElement.RegisterName
- uid: System.Windows.FrameworkElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkElement.RemoveLogicalChild
- uid: System.Windows.FrameworkElement.Resources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
- uid: System.Windows.FrameworkElement.SetBinding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkElement.SetBinding
- uid: System.Windows.FrameworkElement.SetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection
  nameWithType: FrameworkElement.SetFlowDirection
- uid: System.Windows.FrameworkElement.SetResourceReference*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkElement.SetResourceReference
- uid: System.Windows.FrameworkElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkElement.ShouldSerializeResources
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers
  nameWithType: FrameworkElement.ShouldSerializeTriggers
- uid: System.Windows.FrameworkElement.Style*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkElement.Tag*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TemplatedParent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.Triggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
- uid: System.Windows.FrameworkElement.TryFindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkElement.TryFindResource
- uid: System.Windows.FrameworkElement.UnregisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkElement.UnregisterName
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkElement.UpdateDefaultStyle
- uid: System.Windows.FrameworkElement.UseLayoutRounding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.VerticalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
- uid: System.Windows.FrameworkElement.VisualChildrenCount*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
