### YamlMime:ManagedReference
items:
- uid: System.ServiceProcess.ServiceBase
  id: ServiceBase
  children:
  - System.ServiceProcess.ServiceBase.#ctor
  - System.ServiceProcess.ServiceBase.AutoLog
  - System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  - System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  - System.ServiceProcess.ServiceBase.CanPauseAndContinue
  - System.ServiceProcess.ServiceBase.CanShutdown
  - System.ServiceProcess.ServiceBase.CanStop
  - System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  - System.ServiceProcess.ServiceBase.EventLog
  - System.ServiceProcess.ServiceBase.ExitCode
  - System.ServiceProcess.ServiceBase.MaxNameLength
  - System.ServiceProcess.ServiceBase.OnContinue
  - System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  - System.ServiceProcess.ServiceBase.OnPause
  - System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  - System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  - System.ServiceProcess.ServiceBase.OnShutdown
  - System.ServiceProcess.ServiceBase.OnStart(System.String[])
  - System.ServiceProcess.ServiceBase.OnStop
  - System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  - System.ServiceProcess.ServiceBase.ServiceHandle
  - System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  - System.ServiceProcess.ServiceBase.ServiceName
  - System.ServiceProcess.ServiceBase.Stop
  langs:
  - csharp
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
  type: Class
  summary: "Fornece uma classe base para um serviço que exista como parte de um aplicativo de serviço. ServiceBase deve ser derivado de ao criar uma nova classe de serviço."
  remarks: "Derive from ServiceBase when defining your service class in a service application. Any useful service overrides the [OnStart(String\\[\\])](assetId:///M:System.ServiceProcess.ServiceBase.OnStart(System.String[])?qualifyHint=False&autoUpgrade=True) and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods. For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.  \n  \n A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account. The service can run without any user being logged on to the computer.  \n  \n By default, services run under the System account, which is not the same as the Administrator account. You cannot change the rights of the System account. Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.  \n  \n An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service. The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system. The installer also associates each service with an event log that you can use to record service commands. The `main()` function in the executable defines which services should run. The current working directory of the service is the system directory, not the directory in which the executable is located.  \n  \n When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable. However, running the service is not the same as running the executable. The executable only loads the service. The service is accessed (for example, started and stopped) through the Service Control Manager.  \n  \n The executable calls the ServiceBase derived class's constructor the first time you call Start on the service. The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes. The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.  \n  \n The Service Control Manager (SCM) provides a way to interact with the service. You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service. The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands. Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class. If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.  \n  \n You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface. You can automate the tasks available in the console. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.  \n  \n You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in ServiceBase. However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden. The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method. The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the ServiceBase object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.  \n  \n You can use `InstallUtil.exe` to install services on your system.  \n  \n> [!NOTE]\n>  You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log. Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging."
  syntax:
    content: >-
      [System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))]

      public class ServiceBase : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.#ctor
  id: '#ctor'
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
  type: Constructor
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Cria uma nova instância do <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> classe."
  remarks: "Não crie uma instância da <xref:System.ServiceProcess.ServiceBase>classe.</xref:System.ServiceProcess.ServiceBase> Em vez disso, derivam <xref:System.ServiceProcess.ServiceBase>e criar uma instância de sua classe derivada</xref:System.ServiceProcess.ServiceBase> O mínimo necessário implementar no construtor para uma classe herdada de <xref:System.ServiceProcess.ServiceBase>é definir o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>no seu componente.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> </xref:System.ServiceProcess.ServiceBase> Nenhum outro processamento é necessário no construtor. Você deve tratar a maioria dos inicialização em <xref:System.ServiceProcess.ServiceBase.OnStart%2A>em vez de no construtor.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Caso contrário, não há nenhuma garantia que os objetos serão reinicializados quando você reinicia um serviço depois que ele foi interrompido.       Se você substituir o construtor em sua classe derivada, chame o construtor de classe base em seu código.       O <xref:System.ServiceProcess.ServiceBase>conjuntos de construtor <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `true`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> </xref:System.ServiceProcess.ServiceBase> Se você não quiser registrar automaticamente chamadas para o serviço do Gerenciador de controle de serviços (SCM), definir <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `false`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>       Se o arquivo executável contiver um único serviço, o sistema chama construtor do serviço quando iniciar é selecionado do SCM e executa o destruidor se Stop for chamado.       Se o arquivo executável contiver vários serviços, chamar Start em um serviço faz com que os construtores a ser chamado para todos os serviços no executável, mas apenas o serviço especificado é iniciado. Destruidores para os serviços são executados juntos quando todos os serviços foram interrompidos, não individualmente quando cada serviço é interrompido.      > [!NOTE] > Se você substituir o construtor da classe base, você deve chamá-lo explicitamente no construtor de classe derivada."
  syntax:
    content: public ServiceBase ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.AutoLog
  id: AutoLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica se deve iniciar, parar, pausar e continuar comandos no log de eventos de relatório."
  remarks: "Definindo AutoLog como `true` instrui o serviço para usar o log de eventos do aplicativo para falhas de comando do relatório, bem como informações de alteração de estado para iniciar, parar, pausar e continuar eventos no serviço. O nome do serviço é usado como o log <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>.</xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>       Para relatar informações para um log de eventos personalizado em vez de log do aplicativo, defina AutoLog como `false` e escrever instruções dentro do método de manipulação de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>para enviar para o log adequado</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>      > [!NOTE] > A <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>que fornece a cadeia de caracteres de origem para o log de eventos deve ser definida antes do serviço tenta gravar o log de eventos.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Tentativa de acessar o log de eventos antes que o nome de origem é definido gera uma exceção."
  syntax:
    content: public bool AutoLog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para relatar informações no log de eventos; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.AutoLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  id: CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode manipular notificações de alterações de status de energia do computador."
  remarks: "Quando as alterações de status de energia do computador, o Gerenciador de controle de serviços (SCM) verifica se o serviço aceita comandos de evento de energia usando o valor de CanHandlePowerEvent.       Se for CanHandlePowerEvent `true`, o comando é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>método é chamado, se definido.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>não está implementado na classe derivada, o SCM manipula o evento de energia por meio da classe base vazio <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName>método.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>"
  syntax:
    content: public bool CanHandlePowerEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço lida com o status de energia do computador alterações indicadas no <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> classe, caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Essa propriedade é modificada depois que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  id: CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode manipular os eventos de alteração de sessão recebidos de uma sessão do Terminal Server."
  syntax:
    content: public bool CanHandleSessionChangeEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode manipular eventos de alteração de sessão do Terminal Server; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Essa propriedade é modificada depois que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  id: CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode ser pausado e retomado."
  remarks: "Defina o valor da propriedade CanPauseAndContinue no construtor para o serviço.       Quando um serviço for pausado, ele interrompe o que está fazendo. Quando você continuar o serviço (ou através do Gerenciador de controle de serviço por meio de programação), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>é executado.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Enviar uma solicitação de pausa o serviço pode conservar recursos do sistema. Pausar não pode liberar todos os recursos do sistema, mas não de parada. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>geralmente são implementadas para executar o processamento de menor que <xref:System.ServiceProcess.ServiceBase.OnStop%2A>e <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A></xref:System.ServiceProcess.ServiceBase.OnPause%2A>       Quando for CanPauseAndContinue `true`, substituir <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>para especificar o processamento que deve ocorrer quando o Gerenciador de controle de serviços (SCM) transmite uma solicitação para pausar ou continuar para seu serviço.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve ser implementado para desfazer o processamento do <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se for CanPauseAndContinue `false`, o SCM não passará pausar ou continuar solicitações para o serviço, então o <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>métodos não serão chamados mesmo que eles são implementados.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> No SCM, o `Pause` e `Continue` controles são desabilitados quando CanPauseAndContinue é `false`."
  syntax:
    content: public bool CanPauseAndContinue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode ser pausado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. A propriedade CanPauseAndContinue não pode ser alterada depois que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  id: CanShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço deve ser notificado quando o sistema está sendo desligado."
  remarks: "Se for CanShutdown `true`, o serviço seja notificado quando o sistema está sendo desligado. Durante o desligamento, o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>método é chamado se ela foi implementada em sua classe derivada</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>      > [!NOTE] > Apenas o sistema deve fazer com que o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>método seja executado; o serviço pode chamá-lo, mas isso não é recomendado.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>"
  syntax:
    content: public bool CanShutdown { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço deve ser notificado quando o sistema está sendo desligado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.  O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanShutdown*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. A propriedade CanShutdown não pode ser alterada depois que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanStop
  id: CanStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode ser interrompido depois que ele foi iniciado."
  remarks: "Quando a interrupção for chamada em um serviço, o Gerenciador de controle de serviços (SCM) verifica se o serviço aceita comandos Stop usando o valor de CanStop. Para a maioria dos serviços, o valor de CanStop é `true`, mas alguns serviços do sistema operacional, por exemplo, não permitir que o usuário interrompê-los.       Se for CanStop `true`, o comando de parada é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>método é chamado se ela está definida.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A>não está implementado na classe derivada, os identificadores SCM a interrupção de comando por meio da classe base vazia <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName>método.</xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnStop%2A>"
  syntax:
    content: public bool CanStop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode ser interrompido e o <xref:System.ServiceProcess.ServiceBase.OnStop*>método chamado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.ServiceProcess.ServiceBase.OnStop*>"
  overload: System.ServiceProcess.ServiceBase.CanStop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. A propriedade CanStop não pode ser alterada depois que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Libera os recursos (diferente de memória) usados pelo <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref>."
  remarks: "Chamar Dispose em sua classe derivada (e, no <xref:System.ServiceProcess.ServiceBase>classe) quando terminar de usar a classe derivada</xref:System.ServiceProcess.ServiceBase> O método Dispose deixa a classe derivada em um estado inutilizável. Depois de chamar Dispose, você deve liberar todas as referências à classe derivada e <xref:System.ServiceProcess.ServiceBase>para a memória que eles foram ocupando pode ser recuperada pela coleta de lixo.</xref:System.ServiceProcess.ServiceBase>      > [!NOTE] > Sempre chamada Dispose antes de liberar sua última referência para a classe derivada de <xref:System.ServiceProcess.ServiceBase>.</xref:System.ServiceProcess.ServiceBase> Caso contrário, os recursos <xref:System.ServiceProcess.ServiceBase>e a classe derivada são usando será não ser liberado até que a coleta de lixo chama destruidores os objetos.</xref:System.ServiceProcess.ServiceBase>       <xref:System.ServiceProcess.ServiceBase.OnStop%2A>geralmente é implementado para processar o código em <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinado com uma chamada para Dispose.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se você optar por fazer isso em sua classe derivada, é comum implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A>alocar qualquer Dispose liberado.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.ServiceProcess.ServiceBase.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.EventLog
  id: EventLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém um log de eventos, que você pode usar para gravar a notificação de comando de chamadas de serviço, como iniciar e parar, o log de eventos do aplicativo."
  remarks: "O construtor inicializa a propriedade de log de eventos a uma instância com o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName>propriedades definidas.</xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> A fonte é o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>do serviço, e o log é o log de aplicativo. do computador</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Esses valores são definidas automaticamente e não podem ser alterados para registro automático de comandos de serviço.       Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, iniciar, parar, pausar, continuar e comandos personalizados são registrados automaticamente no log de eventos do aplicativo.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Você pode usar a propriedade de log de eventos para gravar mensagens adicionais que também o log. As chamadas de componente <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>usando esse membro EventLog.</xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>       Para relatar informações para um log de eventos personalizado em vez de log do aplicativo, defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `false` e escrever instruções dentro do método de manipulação de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>para enviar para o log adequado</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public virtual System.Diagnostics.EventLog EventLog { get; }
    return:
      type: System.Diagnostics.EventLog
      description: "Um <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> instância cuja origem é registrada no log de aplicativo."
  overload: System.ServiceProcess.ServiceBase.EventLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ExitCode
  id: ExitCode
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define o código de saída para o serviço."
  remarks: "Defina a propriedade ExitCode para um valor diferente de zero antes de parar o serviço para indicar um erro com o Gerenciador de controle de serviço."
  syntax:
    content: public int ExitCode { get; set; }
    return:
      type: System.Int32
      description: "O código de saída para o serviço."
  overload: System.ServiceProcess.ServiceBase.ExitCode*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  id: MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
  type: Field
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica o tamanho máximo para um nome de serviço."
  remarks: "ServiceName e DisplayName têm restrições de tamanho que devem ser observadas ao definir as propriedades em sua classe de serviço."
  syntax:
    content: public const int MaxNameLength = 80;
    return:
      type: System.Int32
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnContinue
  id: OnContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, OnContinue é executado quando um comando continuar é enviado para o serviço pelo Gerenciador de controle de serviços (SCM). Especifica as ações a serem tomadas quando um serviço retoma o funcionamento normal após ser pausado."
  remarks: "Implementar OnContinue para espelhar a resposta do aplicativo para <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> Quando você continuar o serviço (ou por meio do console de serviços por meio de programação), o OnContinue processamento é executado, e o serviço fica ativo novamente.       OnContinue deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é de propriedade `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`, o SCM não passará pausar ou continuar solicitações para o serviço, então o <xref:System.ServiceProcess.ServiceBase.OnPause%2A>OnContinue métodos não serão chamado, mesmo se eles são implementados.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> No SCM, o `Pause` e `Continue` controles são desabilitados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnContinue ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnContinue*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  id: OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, OnCustomCommand executa quando o Gerenciador de controle de serviços (SCM) passa um comando personalizado para o serviço. Especifica as ações a serem tomadas quando ocorre um comando com o valor do parâmetro especificado."
  remarks: "OnCustomCommand permite que você especifique funcionalidade adicional além de iniciar, parar, pausando e continuando serviços.       O SCM não examina o comando personalizado para verificar se o serviço oferece suporte a `command` parâmetro passado. Ele passa o comando personalizado diretamente ao serviço. Se o serviço não reconhece o `command` parâmetro, ele não faz nada.       Comandos personalizados são gerados por um <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>instrução em um <xref:System.ServiceProcess.ServiceController>componente.</xref:System.ServiceProcess.ServiceController> </xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> Use uma instrução switch ou se... em seguida, condição para lidar com os comandos personalizados que definem em seu serviço.       Os únicos valores para um comando personalizado que você pode definir em seu aplicativo ou use OnCustomCommand são aqueles entre 128 e 255. Números inteiros abaixo 128 correspondem aos valores reservado pelo sistema.       Se o <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é de propriedade `true`, comandos personalizados, como todos os outros comandos, gravam entradas de log de eventos para relatar se a execução do método teve êxito ou falhou.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: protected virtual void OnCustomCommand (int command);
    parameters:
    - id: command
      type: System.Int32
      description: "A mensagem de comando enviada para o serviço."
  overload: System.ServiceProcess.ServiceBase.OnCustomCommand*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPause
  id: OnPause
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, executa quando um comando Pausar é enviado para o serviço pelo Gerenciador de controle de serviços (SCM). Especifica as ações a serem tomadas quando faz uma pausa de um serviço."
  remarks: "Use OnPause para especificar o processamento que ocorre quando o serviço recebe um comando Pausar. OnPause deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é de propriedade `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Quando você continuar um serviço pausado (ou por meio do console de serviços por meio de programação), o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>processamento é executado, e o serviço fica ativo novamente.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       O comando Pause só permite que seu aplicativo para reagir a um evento específico. OnPause não faz nada para o serviço que você não defini-lo para fazer.       Enviar uma solicitação de pausa o serviço pode conservar recursos do sistema porque pausar não precisa liberar todos os recursos do sistema. Por exemplo, se os threads foram abertos pelo processo de pausar um serviço em vez de interrompê-lo pode permitir que os threads permanecerá aberta, dispensando a necessidade de realocá-las quando o serviço continua. Se você definir pausar para liberar todos os recursos do sistema, ele se comporta como um comando de parada.       Definir <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>para `true`e substituir OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>para especificar o processamento que deve ocorrer quando o SCM transmite uma solicitação para pausar ou continuar para seu serviço.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve ser implementado para o processamento do OnPause de desfazer.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`, o SCM não passará pausar ou continuar solicitações para o serviço, então o OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>métodos não serão chamados mesmo se implementado.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> No SCM, o `Pause` e `Continue` controles são desabilitados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnPause ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnPause*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  id: OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, executa quando o status de energia do computador foi alterada. Isso se aplica a computadores laptop quando eles entram no modo suspenso, que não é o mesmo que um desligamento do sistema."
  remarks: "Use OnPowerEvent para especificar o processamento que ocorre quando o evento do sistema indicado no <xref:System.ServiceProcess.PowerBroadcastStatus>enumeração ocorre – por exemplo, quando o computador é colocado no modo suspenso ou indica pouca bateria.</xref:System.ServiceProcess.PowerBroadcastStatus>       OnPowerEvent deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>é de propriedade `true`.</xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>"
  syntax:
    content: protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);
    parameters:
    - id: powerStatus
      type: System.ServiceProcess.PowerBroadcastStatus
      description: "Um <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> que indica que uma notificação do sistema sobre seu status de energia."
    return:
      type: System.Boolean
      description: "Quando implementada em uma classe derivada, as necessidades do seu aplicativo determinam o valor a ser retornado. Por exemplo, se um <xref uid=&quot;langword_csharp_QuerySuspend&quot; name=&quot;QuerySuspend&quot; href=&quot;&quot;> </xref> difusão status for passado, você poderá causar seu aplicativo para rejeitar a consulta retornando <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.OnPowerEvent*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  id: OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Executa quando um evento de alteração é proveniente de uma sessão do Terminal Server."
  remarks: "Você deve definir o <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>propriedade `true` para habilitar a execução deste método.</xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>"
  syntax:
    content: protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);
    parameters:
    - id: changeDescription
      type: System.ServiceProcess.SessionChangeDescription
      description: "Uma estrutura que identifica o tipo de alteração."
  overload: System.ServiceProcess.ServiceBase.OnSessionChange*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  id: OnShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, executa quando o sistema está sendo desligado. Especifica o que deve ocorrer imediatamente antes do desligamento do sistema."
  remarks: "Use OnShutdown para especificar o processamento que ocorre quando o sistema é desligado.       Esse evento ocorre somente quando o sistema operacional for desligado, não quando o computador é desligado.       OnShutdown deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>é de propriedade `true`.</xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>"
  syntax:
    content: protected virtual void OnShutdown ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  id: OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, executa quando um comando de início é enviado para o serviço pelo Gerenciador de controle de serviços (SCM) ou quando o sistema operacional for iniciado (para um serviço que inicia automaticamente). Especifica as ações a serem tomadas quando o serviço é iniciado."
  remarks: "Use OnStart to specify the processing that occurs when the service receives a Start command. OnStart is the method in which you specify the behavior of the service. OnStart can take arguments as a way to pass data, but this usage is rare.  \n  \n> [!CAUTION]\n>  Do not use the constructor to perform processing that should be in OnStart. Use OnStart to handle all initialization of your service. The constructor is called when the application's executable runs, not when the service runs. The executable runs before OnStart. When you continue, for example, the constructor is not called again because the SCM already holds the object in memory. If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in OnStart, the needed resources would not be created again the second time the service is called.  \n  \n Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode>. In such a situation, OnStart would be called at system startup.  \n  \n OnStart is expected to be overridden in the derived class. For the service to be useful, OnStart and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.  \n  \n Process initialization arguments for the service in the OnStart method, not in the Main method. The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console. The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel. Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<service name>*). You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`."
  syntax:
    content: protected virtual void OnStart (string[] args);
    parameters:
    - id: args
      type: System.String[]
      description: "Dados passados pelo comando de início."
  overload: System.ServiceProcess.ServiceBase.OnStart*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStop
  id: OnStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada em uma classe derivada, executa quando um comando de parada é enviado para o serviço pelo Gerenciador de controle de serviços (SCM). Especifica as ações a serem tomadas quando um serviço é interrompido."
  remarks: "Use OnStop para especificar o processamento que ocorre quando o serviço recebe um comando de parada.       Quando o SCM recebe um comando de parada, ele usa o valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>para verificar se o serviço aceita comandos Stop.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>é `true`, o comando de parada é passado para o serviço, e o método OnStop é chamado se ela está definida.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se o serviço não está implementada OnStop, o SCM lida com o comando de parada.       Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>é `false`, o SCM ignora o comando parar.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Ela não é passada para o serviço. O comando parar retorna e lançará uma exceção.       OnStop deve ser substituído na classe derivada. O serviço deve ser útil, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>e OnStop deve ser implementado na sua classe de serviço.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected virtual void OnStop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnStop*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  id: RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Tempo adicional de solicitações para uma operação pendente."
  remarks: "O método RequestAdditionalTime é destinado a ser chamado por substituído <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>métodos para solicitar mais tempo para uma operação pendente, para impedir que o Gerenciador de controle de serviços (SCM) marcando o serviço como não está respondendo.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>  Se a operação pendente não é um continuar, pausar, iniciar ou parar, um <xref:System.InvalidOperationException>é gerada.</xref:System.InvalidOperationException>"
  syntax:
    content: public void RequestAdditionalTime (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "O tempo solicitado em milissegundos."
  overload: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço não está em um estado pendente."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  id: Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra o executável para um serviço com o Gerenciador de controle de serviços (SCM)."
  remarks: "Chamar essa sobrecarga de `main()` função do serviço executável para registrar o serviço com o Gerenciador de controle de serviço. Depois de chamar a execução, o Gerenciador de controle de serviço emite um comando de início, o que resulta em uma chamada para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A>método no serviço.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> O serviço não é iniciado até que o comando de início é executado.       O método de execução é chamado da mesma maneira como <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>para aplicativos Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, uma entrada é gravada no log de eventos se o serviço especificado pelo `service` parâmetro não pode ser iniciado.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase service);
    parameters:
    - id: service
      type: System.ServiceProcess.ServiceBase
      description: "Um <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> que indica que um serviço para iniciar."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>service</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  id: Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra o executável para vários serviços com o Gerenciador de controle de serviços (SCM)."
  remarks: "Chamar essa sobrecarga de `main()` função do serviço executável para registrar os serviços com o Gerenciador de controle de serviço. Depois de chamar a execução, o Gerenciador de controle de serviço emite comandos de início, o que resultam em chamadas para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A>métodos nos serviços.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Os serviços não são iniciados até que os comandos de início são executados.       O método de execução é chamado da mesma maneira como o <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>método para aplicativos do Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, uma entrada é gravada no log de eventos se qualquer serviço na matriz não for iniciado.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase[] services);
    parameters:
    - id: services
      type: System.ServiceProcess.ServiceBase[]
      description: "Uma matriz de instâncias de ServiceBase que indicam os serviços para iniciar."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Você não forneceu um serviço para iniciar. A matriz pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou vazio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  id: ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém o identificador de controle de serviço para o serviço."
  remarks: "O identificador de controle de serviço é usado para se comunicar com o Gerenciador de controle de serviços (SCM).  O identificador pode ser usado para atualizar as informações de status do Gerenciador de controle de serviço para o serviço de chamada usando não gerenciado `SetServiceStatus` função."
  syntax:
    content: protected IntPtr ServiceHandle { get; }
    return:
      type: System.IntPtr
      description: "Um <xref:System.IntPtr>estrutura que contém o identificador de controle de serviço para o serviço.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceHandle*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  id: ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Registra o manipulador de comando e inicia o serviço."
  syntax:
    content: public void ServiceMainCallback (int argCount, IntPtr argPointer);
    parameters:
    - id: argCount
      type: System.Int32
      description: "O número de argumentos na matriz de argumento."
    - id: argPointer
      type: System.IntPtr
      description: "Um <xref:System.IntPtr>estrutura que aponta para uma matriz de argumentos.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceName
  id: ServiceName
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define o nome abreviado usado para identificar o serviço no sistema."
  remarks: "O ServiceName identifica o serviço para o Gerenciador de controle de serviço. O valor dessa propriedade deve ser idêntico ao nome registrado para o serviço na <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName>propriedade de classe de instalador correspondente.</xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> No código, ServiceName do serviço geralmente é definido `main()` função do executável.       O ServiceName também é usado para especificar o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>associado a <xref:System.ServiceProcess.ServiceBase.EventLog%2A>propriedade.</xref:System.ServiceProcess.ServiceBase.EventLog%2A> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Essa <xref:System.ServiceProcess.ServiceBase.EventLog%2A>é uma instância que grava informações de comando de serviço para o log de aplicativo.</xref:System.ServiceProcess.ServiceBase.EventLog%2A>       ServiceName, que fornece a cadeia de caracteres de origem para o log de eventos, deve ser definida antes do serviço grava o log de eventos. Tentativa de acessar o log de eventos antes que o nome de origem é definido faz com que uma exceção seja lançada."
  syntax:
    content: public string ServiceName { get; set; }
    return:
      type: System.String
      description: "O nome do serviço."
  overload: System.ServiceProcess.ServiceBase.ServiceName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. A propriedade ServiceName não pode ser alterada depois que o serviço foi iniciado."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome especificado é uma cadeia de caracteres de comprimento zero ou tem mais de <xref href=&quot;System.ServiceProcess.ServiceBase.MaxNameLength&quot;> </xref>, ou o nome especificado contém caracteres de barra ou barra invertida direta."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Stop
  id: Stop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Interrompe o serviço em execução."
  remarks: "O método de parada define o estado do serviço para indicar uma parada está pendente e chama o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>método.</xref:System.ServiceProcess.ServiceBase.OnStop%2A>  Depois que o aplicativo for interrompido, o estado do serviço é definido como parado. Se o aplicativo é um serviço hospedado, o domínio de aplicativo será descarregado."
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.Stop*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ServiceProcess.ServiceBase.#ctor
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
- uid: System.ServiceProcess.ServiceBase.AutoLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
- uid: System.ServiceProcess.ServiceBase.EventLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
- uid: System.Diagnostics.EventLog
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
- uid: System.ServiceProcess.ServiceBase.OnContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
- uid: System.ServiceProcess.ServiceBase.OnPause
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
- uid: System.ServiceProcess.PowerBroadcastStatus
  parent: System.ServiceProcess
  isExternal: false
  name: PowerBroadcastStatus
  nameWithType: PowerBroadcastStatus
  fullName: System.ServiceProcess.PowerBroadcastStatus
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
- uid: System.ServiceProcess.SessionChangeDescription
  parent: System.ServiceProcess
  isExternal: false
  name: SessionChangeDescription
  nameWithType: SessionChangeDescription
  fullName: System.ServiceProcess.SessionChangeDescription
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.OnStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
- uid: System.ServiceProcess.ServiceBase
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
- uid: System.ServiceProcess.ServiceBase[]
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase[]
  spec.csharp:
  - uid: System.ServiceProcess.ServiceBase
    name: ServiceBase
    nameWithType: ServiceBase
    fullName: ServiceBase[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
- uid: System.ServiceProcess.ServiceBase.ServiceName
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceProcess.ServiceBase.Stop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
- uid: System.ServiceProcess.ServiceBase.#ctor*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase.ServiceBase
- uid: System.ServiceProcess.ServiceBase.AutoLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose
  nameWithType: ServiceBase.Dispose
- uid: System.ServiceProcess.ServiceBase.EventLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
- uid: System.ServiceProcess.ServiceBase.OnContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue
  nameWithType: ServiceBase.OnContinue
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand
  nameWithType: ServiceBase.OnCustomCommand
- uid: System.ServiceProcess.ServiceBase.OnPause*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause
  nameWithType: ServiceBase.OnPause
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent
  nameWithType: ServiceBase.OnPowerEvent
- uid: System.ServiceProcess.ServiceBase.OnSessionChange*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange
  nameWithType: ServiceBase.OnSessionChange
- uid: System.ServiceProcess.ServiceBase.OnShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown
  nameWithType: ServiceBase.OnShutdown
- uid: System.ServiceProcess.ServiceBase.OnStart*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart
  nameWithType: ServiceBase.OnStart
- uid: System.ServiceProcess.ServiceBase.OnStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop
  nameWithType: ServiceBase.OnStop
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime
  nameWithType: ServiceBase.RequestAdditionalTime
- uid: System.ServiceProcess.ServiceBase.Run*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run
  nameWithType: ServiceBase.Run
- uid: System.ServiceProcess.ServiceBase.ServiceHandle*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback
  nameWithType: ServiceBase.ServiceMainCallback
- uid: System.ServiceProcess.ServiceBase.ServiceName*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
- uid: System.ServiceProcess.ServiceBase.Stop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop
  nameWithType: ServiceBase.Stop
