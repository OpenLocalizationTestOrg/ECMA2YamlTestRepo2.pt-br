### YamlMime:ManagedReference
items:
- uid: System.Messaging.Message
  id: Message
  children:
  - System.Messaging.Message.#ctor
  - System.Messaging.Message.#ctor(System.Object)
  - System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  - System.Messaging.Message.AcknowledgeType
  - System.Messaging.Message.Acknowledgment
  - System.Messaging.Message.AdministrationQueue
  - System.Messaging.Message.AppSpecific
  - System.Messaging.Message.ArrivedTime
  - System.Messaging.Message.AttachSenderId
  - System.Messaging.Message.Authenticated
  - System.Messaging.Message.AuthenticationProviderName
  - System.Messaging.Message.AuthenticationProviderType
  - System.Messaging.Message.Body
  - System.Messaging.Message.BodyStream
  - System.Messaging.Message.BodyType
  - System.Messaging.Message.ConnectorType
  - System.Messaging.Message.CorrelationId
  - System.Messaging.Message.DestinationQueue
  - System.Messaging.Message.DestinationSymmetricKey
  - System.Messaging.Message.DigitalSignature
  - System.Messaging.Message.EncryptionAlgorithm
  - System.Messaging.Message.Extension
  - System.Messaging.Message.Formatter
  - System.Messaging.Message.HashAlgorithm
  - System.Messaging.Message.Id
  - System.Messaging.Message.InfiniteTimeout
  - System.Messaging.Message.IsFirstInTransaction
  - System.Messaging.Message.IsLastInTransaction
  - System.Messaging.Message.Label
  - System.Messaging.Message.LookupId
  - System.Messaging.Message.MessageType
  - System.Messaging.Message.Priority
  - System.Messaging.Message.Recoverable
  - System.Messaging.Message.ResponseQueue
  - System.Messaging.Message.SecurityContext
  - System.Messaging.Message.SenderCertificate
  - System.Messaging.Message.SenderId
  - System.Messaging.Message.SenderVersion
  - System.Messaging.Message.SentTime
  - System.Messaging.Message.SourceMachine
  - System.Messaging.Message.TimeToBeReceived
  - System.Messaging.Message.TimeToReachQueue
  - System.Messaging.Message.TransactionId
  - System.Messaging.Message.TransactionStatusQueue
  - System.Messaging.Message.UseAuthentication
  - System.Messaging.Message.UseDeadLetterQueue
  - System.Messaging.Message.UseEncryption
  - System.Messaging.Message.UseJournalQueue
  - System.Messaging.Message.UseTracing
  langs:
  - csharp
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
  type: Class
  summary: "Fornece acesso às propriedades necessárias para definir uma mensagem do serviço de enfileiramento de mensagens."
  remarks: "Use a classe de mensagem para inspecionar ou receber mensagens de uma fila ou ter controle refinado sobre propriedades de mensagens ao enviar uma mensagem para uma fila.       <xref:System.Messaging.MessageQueue>usa a classe de mensagem quando ele exibe ou recebe mensagens de filas, porque tanto o <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName>e <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName>métodos criar uma nova instância da classe de mensagem e definir as propriedades da instância.</xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName></xref:System.Messaging.MessageQueue> Propriedades da classe de mensagem de somente leitura se aplicam a recuperação de mensagens de uma fila, enquanto as propriedades de leitura/gravação se aplicam para enviar e recuperar mensagens. Quando <xref:System.Messaging.MessageQueue>exibe ou recebe uma mensagem de uma fila, seu <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>propriedade determina quais propriedades da mensagem são recuperados.</xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> </xref:System.Messaging.MessageQueue>       O <xref:System.Messaging.MessageQueue>da classe <xref:System.Messaging.MessageQueue.Send%2A>método permite que você especificar qualquer tipo de objeto para uma mensagem que está sendo enviada para essa fila.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.MessageQueue> Você pode usar o <xref:System.Messaging.MessageQueue>da instância <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>propriedade para especificar configurações para genéricas mensagens enviadas à fila.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> </xref:System.Messaging.MessageQueue> Os tipos de configurações incluem o formatador, rótulo, criptografia e autenticação. Você também pode especificar valores para as <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>membros quando coordenar seu aplicativo de mensagens para responder às mensagens de confirmação e relatório.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Usar uma instância de mensagem para enviar uma mensagem à fila oferece a flexibilidade para acessar e modificar muitas dessas propriedades — em uma única mensagem ou em uma base por mensagem. Propriedades da mensagem têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Dados da mensagem são armazenados no <xref:System.Messaging.Message.Body%2A>propriedade e uma extensão menor, o <xref:System.Messaging.Message.AppSpecific%2A>e <xref:System.Messaging.Message.Extension%2A>Propriedades.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> </xref:System.Messaging.Message.Body%2A> Quando os dados da mensagem são criptografados, serializados ou desserializados, somente o conteúdo do <xref:System.Messaging.Message.Body%2A>propriedade são afetados.</xref:System.Messaging.Message.Body%2A>       O conteúdo do <xref:System.Messaging.Message.Body%2A>propriedade são serializados quando a mensagem é enviada usando o <xref:System.Messaging.Message.Formatter%2A>propriedade que você especificar.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A> O conteúdo serializado é encontrado no <xref:System.Messaging.Message.BodyStream%2A>propriedade.</xref:System.Messaging.Message.BodyStream%2A> Você também pode definir o <xref:System.Messaging.Message.BodyStream%2A>propriedade diretamente, por exemplo, para enviar um arquivo como o conteúdo de dados de uma mensagem.</xref:System.Messaging.Message.BodyStream%2A> Você pode alterar o <xref:System.Messaging.Message.Body%2A>ou <xref:System.Messaging.Message.Formatter%2A>propriedades a qualquer momento antes de enviar a mensagem e os dados poderão ser serializadas adequadamente quando você chama <xref:System.Messaging.MessageQueue.Send%2A>.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       As propriedades definidas pelo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName>propriedade se aplica apenas a mensagens que não são do tipo Message.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName> Se você especificar o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>propriedade para um <xref:System.Messaging.MessageQueue>, as propriedades com nomes idênticos em uma instância de mensagem enviada para essa fila fazer com que essas propriedades padrão ser ignorada.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Para obter uma lista de valores de propriedade inicial para uma instância da mensagem, consulte o <xref:System.Messaging.Message.%23ctor%2A>construtor.</xref:System.Messaging.Message.%23ctor%2A>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/t-system.messaging.message_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/t-system.messaging.message_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/t-system.messaging.message_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/t-system.messaging.message_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/t-system.messaging.message_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/t-system.messaging.message_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class Message : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.Message.#ctor
  id: '#ctor'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Messaging.Message&quot;> </xref> classe com um corpo vazio."
  remarks: "Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.Message>classe que tem um corpo vazio.</xref:System.Messaging.Message>       Especifique o <xref:System.Messaging.Message.Body%2A>propriedade ou o <xref:System.Messaging.Message.BodyStream%2A>propriedade antes de enviar o <xref:System.Messaging.Message>objeto.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> </xref:System.Messaging.Message.Body%2A> O <xref:System.Messaging.Message.Body%2A>propriedade pode ser qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido.</xref:System.Messaging.Message.Body%2A>       A menos que você gravar o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A>propriedade, defina o <xref:System.Messaging.Message.Formatter%2A>propriedade antes de enviar a mensagem.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> O corpo é serializado usando o <xref:System.Messaging.Message.Formatter%2A>o valor da propriedade no momento em que o <xref:System.Messaging.MessageQueue.Send%2A>método é chamado no <xref:System.Messaging.MessageQueue>instância.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A>       O <xref:System.Messaging.XmlMessageFormatter>é flexível, portanto, não é necessário ter o mesmo objeto ao usar esse formato de tipo no remetente e receptor.</xref:System.Messaging.XmlMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>e <xref:System.Messaging.BinaryMessageFormatter>serializar os dados em representação binária.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>é usado ao enviar ou receber componentes COM.</xref:System.Messaging.ActiveXMessageFormatter>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider versão 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `null`|   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/m-system.messaging.messa_16_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_16_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/m-system.messaging.messa_16_1.cs)]"
  syntax:
    content: public Message ();
    parameters: []
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Messaging.Message&quot;> </xref> classe usando o <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> para serializar o objeto especificado no corpo da mensagem."
  remarks: "Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.Message>classe que contém o <xref:System.Messaging.Message.Body%2A>especificado pelo `body` parâmetro.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> O `body` parâmetro pode ser qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido. O corpo é serializado usando o <xref:System.Messaging.XmlMessageFormatter>a menos que você altere o <xref:System.Messaging.Message.Formatter%2A>propriedade antes do <xref:System.Messaging.Message>é enviada.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.XmlMessageFormatter> Se você alterar o <xref:System.Messaging.Message.Body%2A>ou <xref:System.Messaging.Message.Formatter%2A>propriedade a qualquer momento antes de chamar <xref:System.Messaging.MessageQueue.Send%2A>, a mensagem será serializada de acordo com o novo valor da propriedade.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       O <xref:System.Messaging.XmlMessageFormatter>é flexível, portanto, não é necessário ter o mesmo objeto ao usar esse formato de tipo no remetente e receptor.</xref:System.Messaging.XmlMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>e <xref:System.Messaging.BinaryMessageFormatter>serializar os dados em representação binária.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>é usado ao enviar ou receber componentes COM.</xref:System.Messaging.ActiveXMessageFormatter>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider versão 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| O `body` parâmetro. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example creates a new queue, sends a message that contains an order to it, and then retrieves it.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.messa_33_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.messa_33_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_33_1.vb)]"
  syntax:
    content: public Message (object body);
    parameters:
    - id: body
      type: System.Object
      description: "O objeto a ser serializado no corpo da mensagem."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  id: '#ctor(System.Object,System.Messaging.IMessageFormatter)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Messaging.Message&quot;> </xref> classe usando o formatador especificado para serializar o objeto especificado no corpo da mensagem."
  remarks: "Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.Message>classe que contém o <xref:System.Messaging.Message.Body%2A>especificado pelo `body` parâmetro e que usa qualquer formatador válido para serializar o corpo.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> O `body` parâmetro é qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido. Se você alterar o <xref:System.Messaging.Message.Body%2A>ou <xref:System.Messaging.Message.Formatter%2A>propriedade a qualquer momento antes de chamar <xref:System.Messaging.MessageQueue.Send%2A>, a mensagem será serializada de acordo com o novo valor da propriedade.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       O <xref:System.Messaging.XmlMessageFormatter>é flexível, portanto, não é necessário ter o mesmo objeto ao usar esse formato de tipo no remetente e receptor.</xref:System.Messaging.XmlMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>e <xref:System.Messaging.BinaryMessageFormatter>serializar os dados em representação binária.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>é usado ao enviar ou receber componentes COM.</xref:System.Messaging.ActiveXMessageFormatter>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider versão 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| O `body` parâmetro. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.Formatter%2A>| O `formatter` parâmetro. |   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Uma cadeia de caracteres vazia (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Uma matriz de bytes de comprimento zero |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - >-
    [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/6734a59e-0a86-49d1-96b9-_1.cpp)]
     [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/6734a59e-0a86-49d1-96b9-_1.cs)]
     [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/6734a59e-0a86-49d1-96b9-_1.vb)]
  syntax:
    content: public Message (object body, System.Messaging.IMessageFormatter formatter);
    parameters:
    - id: body
      type: System.Object
      description: "O objeto a ser serializado no corpo da mensagem."
    - id: formatter
      type: System.Messaging.IMessageFormatter
      description: "Um <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> que especifica o formatador com o qual serializar o corpo da mensagem."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.AcknowledgeType
  id: AcknowledgeType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o tipo de mensagem de confirmação a ser retornado para o aplicativo de envio."
  remarks: "A propriedade AcknowledgeType Especifica o tipo de mensagens de confirmação solicitada pelo aplicativo de envio. Defina a propriedade de AcknowledgeType antes de enviar a mensagem de solicitação de notificação de determinadas ocorrências — por exemplo, uma mensagem atingir sua fila de destino, uma mensagem que está sendo recuperado ou um tempo limite impedindo uma mensagem atingir ou que está sendo recuperada da fila de destino.       O Message Queuing retorna notificação enviando mensagens de confirmação para o <xref:System.Messaging.Message.AdministrationQueue%2A>propriedade especificada pela mensagem original.</xref:System.Messaging.Message.AdministrationQueue%2A> Uma mensagem de confirmação <xref:System.Messaging.Message.Acknowledgment%2A>propriedade indica o tipo de confirmação de que ele representa.</xref:System.Messaging.Message.Acknowledgment%2A> Por exemplo, se uma mensagem de confirmação foi enviada como uma mensagem não alcançaram o destino antes do <xref:System.Messaging.Message.TimeToReachQueue%2A>intervalo expirou, o <xref:System.Messaging.Message.Acknowledgment%2A>propriedade da mensagem de confirmação contém o valor `ReachQueueTimeout`.</xref:System.Messaging.Message.Acknowledgment%2A> </xref:System.Messaging.Message.TimeToReachQueue%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_11_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_11_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_11_1.vb)]"
  syntax:
    content: public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }
    return:
      type: System.Messaging.AcknowledgeTypes
      description: "Uma da <xref href=&quot;System.Messaging.AcknowledgeTypes&quot;> </xref> valores que representam a ambos os tipos de mensagens de confirmação, o sistema envia a fila de administração e as condições sob as quais as confirmações são retornadas para o aplicativo de envio. O padrão é <xref uid=&quot;langword_csharp_None&quot; name=&quot;None&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AcknowledgeType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem é filtrada para ignorar a propriedade AcknowledgeType."
  platform:
  - net462
- uid: System.Messaging.Message.Acknowledgment
  id: Acknowledgment
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a classificação da confirmação que esta mensagem representa."
  remarks: "Quando você recebe uma mensagem de uma fila de administração, leia a propriedade de confirmação para verificar o status da mensagem original.       Quando uma mensagem é enviada para a sua fila de destino, o enfileiramento de mensagens pode ser solicitado para postar uma mensagem de confirmação. Esta mensagem pode indicar, por exemplo, se a mensagem chegou e se foi recuperada no tempo limite especificado, ou pode indicar que deu errado em caso de falha de entrega. A fila de destino retorna mensagens de confirmação e envia-os para a fila de administração especificada na mensagem original <xref:System.Messaging.Message.AdministrationQueue%2A>propriedade.</xref:System.Messaging.Message.AdministrationQueue%2A> O <xref:System.Messaging.Message.Id%2A>propriedade de uma mensagem de confirmação identifica a mensagem de confirmação, não na mensagem original.</xref:System.Messaging.Message.Id%2A> Você pode encontrar o identificador da mensagem original em que a confirmação <xref:System.Messaging.Message>da instância <xref:System.Messaging.Message.CorrelationId%2A>propriedade.</xref:System.Messaging.Message.CorrelationId%2A> </xref:System.Messaging.Message>       Se este <xref:System.Messaging.Message>instância representa uma mensagem de confirmação, a propriedade de confirmação Especifica o tipo de confirmação.</xref:System.Messaging.Message> Caso contrário, a propriedade de confirmação contém o valor `Normal`.       Use o <xref:System.Messaging.Message.AcknowledgeType%2A>propriedade da mensagem original para especificar as circunstâncias sob a qual as confirmações serão retornadas.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  syntax:
    content: public System.Messaging.Acknowledgment Acknowledgment { get; }
    return:
      type: System.Messaging.Acknowledgment
      description: "Uma da <xref href=&quot;System.Messaging.Acknowledgment&quot;> </xref> valores de enumeração."
  overload: System.Messaging.Message.Acknowledgment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar o <xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>propriedade.</xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>"
  platform:
  - net462
- uid: System.Messaging.Message.AdministrationQueue
  id: AdministrationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a fila que recebe as mensagens de confirmação que gera de enfileiramento de mensagens."
  remarks: "A fila especificada na propriedade AdministrationQueue pode ser qualquer fila não transacional. As mensagens de confirmação enviadas para a fila de administração podem indicar se a mensagem original alcançou sua fila de destino e se ela foi removida da fila.       Quando o <xref:System.Messaging.Message.AcknowledgeType%2A>propriedade tem qualquer valor diferente de `None`, o aplicativo de envio deve especificar a fila a ser usada como a fila de administração.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_47_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_47_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_47_1.vb)]"
  syntax:
    content: public System.Messaging.MessageQueue AdministrationQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "O <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> que especifica a fila de administração usada para mensagens de confirmação geradas pelo sistema. O padrão é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AdministrationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade AdministrationQueue."
  platform:
  - net462
- uid: System.Messaging.Message.AppSpecific
  id: AppSpecific
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define informações adicionais específicas do aplicativo."
  remarks: "A propriedade AppSpecific contém informações específicas de aplicativo que você pode usar para organizar os diferentes tipos de mensagens. Por exemplo, você pode usar índices específicos do aplicativo. É responsabilidade do aplicativo para interpretar as informações de propriedade AppSpecific.       Sempre que possível, você deve incluir dados de mensagem no corpo da mensagem, em vez da propriedade de AppSpecific.       Ao trabalhar com filas externas, use o <xref:System.Messaging.Message.Extension%2A>propriedade para especificar propriedades de mensagem que não existem no serviço de enfileiramento de mensagens.</xref:System.Messaging.Message.Extension%2A> Como com a propriedade AppSpecific, é responsabilidade do aplicativo para entender o conteúdo do <xref:System.Messaging.Message.Extension%2A>propriedade.</xref:System.Messaging.Message.Extension%2A>"
  syntax:
    content: public int AppSpecific { get; set; }
    return:
      type: System.Int32
      description: "Informações que são específicas para o aplicativo. O padrão é zero."
  overload: System.Messaging.Message.AppSpecific*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade AppSpecific."
  platform:
  - net462
- uid: System.Messaging.Message.ArrivedTime
  id: ArrivedTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a hora em que a mensagem chegou na fila de destino."
  remarks: "A mensagem <xref:System.Messaging.Message.TimeToBeReceived%2A>propriedade indica a rapidez a mensagem deve ser recebida da fila de destino.</xref:System.Messaging.Message.TimeToBeReceived%2A> O <xref:System.Messaging.Message.TimeToBeReceived%2A>timer de propriedade inicia quando a mensagem é enviada, não quando a mensagem chega na fila.</xref:System.Messaging.Message.TimeToBeReceived%2A>"
  example:
  - "The following code example displays the value of a message's ArrivedTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime ArrivedTime { get; }
    return:
      type: System.DateTime
      description: "Um <xref:System.DateTime>que representa a hora de chegada da mensagem na fila de destino.</xref:System.DateTime> A hora é ajustada do GMT à hora local do computador no qual reside a fila de destino."
  overload: System.Messaging.Message.ArrivedTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade de hora de chegada."
  platform:
  - net462
- uid: System.Messaging.Message.AttachSenderId
  id: AttachSenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se a ID do remetente deve ser anexada à mensagem."
  remarks: "O <xref:System.Messaging.Message.SenderId%2A>propriedade é uma matriz de bytes que representa o identificador do usuário envio.</xref:System.Messaging.Message.SenderId%2A> A ID do remetente é definida pelo enfileiramento de mensagens e é usada pelo Gerenciador de fila de recebimento para verificar se o remetente tem direitos de acesso a uma fila.       A ausência do remetente que ID é uma indicação pelo aplicativo de envio que Message Queuing não deve validar o remetente da mensagem nem verificar o acesso do remetente de direitos para a fila de recebimento. O <xref:System.Messaging.Message.SenderId%2A>é confiável somente se a mensagem foi autenticada quando atingiu a fila de destino.</xref:System.Messaging.Message.SenderId%2A> A mensagem foi rejeitada quando atingir a fila de destino se a fila aceita apenas mensagens autenticadas e qualquer um de <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>ou o <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>é de propriedade `false`.</xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> </xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>      > [!CAUTION] > Se uma mensagem for rejeitada, é enviadas para a fila de mensagens mortas (se <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é `true`), ou ele será ignorado.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Você pode solicitar confirmações quando uma mensagem de falha ao acessar uma fila. Caso contrário, quando <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é `false` a mensagem pode ser perdida sem aviso.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>"
  example:
  - "The following code example gets and sets the value of a message's AttachSenderId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool AttachSenderId { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Messaging.Message.SenderId*>devem ser anexados à mensagem; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.SenderId*> O padrão é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AttachSenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade AttachSenderId."
  platform:
  - net462
- uid: System.Messaging.Message.Authenticated
  id: Authenticated
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém um valor que indica se a mensagem foi autenticada."
  remarks: "A propriedade autenticado é usada somente pelo aplicativo enquanto ele está interagindo com a mensagem e tentar determinar se a autenticação foi solicitada. Se a mensagem está na fila, a mensagem foi autenticada. Por outro lado, se a propriedade autenticado `true`, Gerenciador de fila de recebimento autenticado a mensagem quando ele recebeu essa mensagem.       Você não pode determinar se uma mensagem de falha na autenticação examinando suas propriedades. O Message Queuing descarta mensagens de falham de autenticação antes que sejam enviadas para a fila. No entanto, você pode solicitar que uma mensagem de confirmação enviada se uma falha de entrega impede que a mensagem que chega na fila."
  example:
  - "The following code example displays the value of a message's Authenticated property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Authenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a autenticação foi solicitada para a mensagem quando inserida fila; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Authenticated*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade autenticado."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderName
  id: AuthenticationProviderName
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o nome do provedor criptográfico usado para gerar a assinatura digital da mensagem."
  remarks: "Geralmente, você usa o AuthenticationProviderName ao trabalhar com filas externas. O Message Queuing requer o nome do provedor de autenticação e o tipo de provedor de autenticação do provedor criptográfico (provedor de autenticação) para validar as assinaturas digitais de mensagens enviadas para uma fila externa e mensagens passadas para enfileiramento de mensagens de uma fila externa.       Ao enviar uma mensagem, defina sempre o AuthenticationProviderName e <xref:System.Messaging.Message.ConnectorType%2A>propriedades juntas.</xref:System.Messaging.Message.ConnectorType%2A> Quando a mensagem é enviada, enfileiramento de mensagens ignora o nome do provedor de autenticação, se o tipo de conector também não é definido.       A propriedade AuthenticationProviderName não pode ser `null`, mas pode ser uma cadeia de caracteres vazia (&quot;&quot;)."
  syntax:
    content: public string AuthenticationProviderName { get; set; }
    return:
      type: System.String
      description: "O nome do provedor criptográfico usado para gerar a assinatura digital da mensagem. O padrão é Microsoft Base Cryptographic Provider versão 1.0."
  overload: System.Messaging.Message.AuthenticationProviderName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível definir a propriedade AuthenticationProviderName.       - ou - a fila de mensagens é filtrada para ignorar a propriedade AuthenticationProviderName."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O AuthenticationProviderName foi definida como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderType
  id: AuthenticationProviderType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o tipo de provedor de criptografia usado para gerar a assinatura digital da mensagem."
  remarks: "Você normalmente usar a propriedade AuthenticationProviderType ao trabalhar com filas externas para especificar quais serviços de criptografia provedor está associado uma mensagem. O Message Queuing requer o nome do provedor de autenticação e o tipo de provedor de autenticação do provedor criptográfico (provedor de autenticação) para validar as assinaturas digitais de mensagens enviadas para uma fila externa e mensagens passadas para enfileiramento de mensagens de uma fila externa.       Somente `RsaFull` se destina a ser usado com o sistema de mensagens.       Ao enviar uma mensagem, defina sempre o AuthenticationProviderType e <xref:System.Messaging.Message.ConnectorType%2A>propriedades juntas.</xref:System.Messaging.Message.ConnectorType%2A> Quando a mensagem é enviada, enfileiramento de mensagens ignora o tipo de provedor de autenticação, se o tipo de conector também não é definido."
  syntax:
    content: public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }
    return:
      type: System.Messaging.CryptographicProviderType
      description: "Uma da <xref href=&quot;System.Messaging.CryptographicProviderType&quot;> </xref> valores. O padrão é <xref uid=&quot;langword_csharp_RSA_FULL&quot; name=&quot;RSA_FULL&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AuthenticationProviderType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível definir a propriedade AuthenticationProviderType.       - ou - a fila de mensagens é filtrada para ignorar a propriedade AuthenticationProviderType."
  platform:
  - net462
- uid: System.Messaging.Message.Body
  id: Body
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o conteúdo da mensagem."
  remarks: "Propriedade do corpo da mensagem normalmente contém os dados associados com a mensagem. Embora você também pode enviar dados específicos do aplicativo <xref:System.Messaging.Message.AppSpecific%2A>e <xref:System.Messaging.Message.Extension%2A>Propriedades, você deve incluir dados de mensagem no corpo da mensagem sempre que possível.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> Somente o conteúdo da propriedade corpo é serializado ou criptografado.       A propriedade corpo pode conter qualquer objeto cujo tamanho não exceder 4 MB. Se você usar <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>para enviar qualquer objeto que não é do tipo <xref:System.Messaging.Message>para o <xref:System.Messaging.MessageQueue>esse objeto será localizado na propriedade de corpo da <xref:System.Messaging.Message>instância retornada por <xref:System.Messaging.MessageQueue.Peek%2A>ou <xref:System.Messaging.MessageQueue.Receive%2A>.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue.Peek%2A> </xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>       O argumento de cadeia de caracteres em `MessageQueue.Send(&quot;hello.&quot;)` é um exemplo de tal um objeto genérico.       O <xref:System.Messaging.Message.BodyType%2A>propriedade indica o tipo de informação que é armazenada no corpo da mensagem.</xref:System.Messaging.Message.BodyType%2A> O Message Queuing usa essas informações para identificar o tipo de conteúdo de corpo de propriedade.       Especifique a propriedade de corpo ou <xref:System.Messaging.Message.BodyStream%2A>propriedade antes de enviar o <xref:System.Messaging.Message>objeto.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> A propriedade corpo pode ser qualquer objeto serializável, como uma cadeia de caracteres de texto, o objeto de estrutura, a instância da classe ou o objeto inserido.       A menos que você gravar o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A>propriedade, defina o <xref:System.Messaging.Message.Formatter%2A>propriedade antes de enviar a mensagem.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> Quando o <xref:System.Messaging.MessageQueue.Send%2A>método é chamado no <xref:System.Messaging.MessageQueue>instância, o corpo é serializada usando o formatador contido o <xref:System.Messaging.Message.Formatter%2A>propriedade.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Se você enviar a mensagem sem especificar um valor para a <xref:System.Messaging.Message.Formatter%2A>propriedade, os padrões de formatador para <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>      > [!NOTE] > Tentativa de definir o corpo de uma mensagem para <xref:System.Decimal.MaxValue>fará com que um <xref:System.OverflowException>quando o `Send` método do <xref:System.Messaging.MessageQueue>classe é chamada e o <xref:System.Messaging.ActiveXMessageFormatter>é usado.</xref:System.Messaging.ActiveXMessageFormatter> </xref:System.Messaging.MessageQueue> </xref:System.OverflowException> </xref:System.Decimal.MaxValue>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_13_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_13_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_13_1.cs)]"
  syntax:
    content: public object Body { get; set; }
    return:
      type: System.Object
      description: "Um objeto que especifica o conteúdo da mensagem. O objeto pode ser uma cadeia de caracteres, uma data, moeda, um número, uma matriz de bytes ou qualquer objeto gerenciado."
  overload: System.Messaging.Message.Body*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref:System.Messaging.Message.Formatter*>é de propriedade <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.Formatter*>       - ou - a fila de mensagens é filtrada para ignorar a propriedade Body."
  platform:
  - net462
- uid: System.Messaging.Message.BodyStream
  id: BodyStream
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define as informações no corpo da mensagem."
  remarks: "O corpo de uma mensagem pode consistir em qualquer tipo de informação — por exemplo, uma cadeia de caracteres, uma data, moeda, um número, uma matriz de bytes ou qualquer objeto gerenciado. Essa informação é serializada em um <xref:System.IO.Stream>a serem passados para a fila.</xref:System.IO.Stream>       Especifique o <xref:System.Messaging.Message.Body%2A>propriedade ou a propriedade BodyStream antes de enviar o <xref:System.Messaging.Message>objeto.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Body%2A> Se você definir o <xref:System.Messaging.Message.Body%2A>propriedade, o conteúdo é serializado na propriedade BodyStream.</xref:System.Messaging.Message.Body%2A> No entanto, você pode optar por gravar a propriedade BodyStream diretamente. Isso é útil, por exemplo, quando desejar abrir uma conexão para um arquivo e transmitir seu conteúdo no corpo da mensagem.       A menos que você grava o conteúdo da mensagem diretamente para a propriedade BodyStream, defina o <xref:System.Messaging.Message.Formatter%2A>propriedade antes de enviar a mensagem.</xref:System.Messaging.Message.Formatter%2A> Quando o <xref:System.Messaging.MessageQueue.Send%2A>método é chamado no <xref:System.Messaging.MessageQueue>instância, o corpo é serializada usando o formatador contido o <xref:System.Messaging.Message.Formatter%2A>propriedade.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Se você enviar a mensagem sem especificar um valor para a <xref:System.Messaging.Message.Formatter%2A>propriedade, os padrões de formatador para <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>       Se você definir o <xref:System.Messaging.Message.UseEncryption%2A>propriedade `true` para o corpo da mensagem, a mensagem será criptografada quando enviada, não quando você definir o <xref:System.Messaging.Message.Body%2A>propriedade.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message.UseEncryption%2A> Portanto, a propriedade BodyStream nunca será criptografada."
  syntax:
    content: public System.IO.Stream BodyStream { get; set; }
    return:
      type: System.IO.Stream
      description: "Um <xref:System.IO.Stream>que contém as informações serializadas incluídas no <xref:System.Messaging.Message.Body*>da mensagem.</xref:System.Messaging.Message.Body*> </xref:System.IO.Stream>"
  overload: System.Messaging.Message.BodyStream*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar o <xref:System.Messaging.Message.Body*>propriedade.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.BodyType
  id: BodyType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o tipo de dados que contém o corpo da mensagem."
  remarks: "O Message Queuing reconhece os conteúdos do corpo como um objeto ou como um fluxo serializado. A propriedade BodyType indica o tipo de objeto dentro do <xref:System.Messaging.Message.Body%2A>propriedade da mensagem.</xref:System.Messaging.Message.Body%2A>       O <xref:System.Messaging.XmlMessageFormatter>executa a associação entre tipos nativos e o objeto no corpo da mensagem.</xref:System.Messaging.XmlMessageFormatter> Se você usar o <xref:System.Messaging.XmlMessageFormatter>, o formatador define a propriedade BodyType para você.</xref:System.Messaging.XmlMessageFormatter>       Outros formatadores podem fornecer funcionalidade de associação também, como mostra o código c# a seguir.      ```   message.Formatter = new ActiveXMessageFormatter();   object myObject message.Body;   if (myObject is string) {   }   if (myObject is int) {   }   if (myObject is float) {   }   ```"
  example:
  - "The following code example displays the value of a message's BodyType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public int BodyType { get; set; }
    return:
      type: System.Int32
      description: "Verdadeiro tipo do corpo da mensagem, como uma cadeia de caracteres, uma data, moeda ou um número."
  overload: System.Messaging.Message.BodyType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar o <xref:System.Messaging.Message.Body*>propriedade.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.ConnectorType
  id: ConnectorType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se algumas propriedades de mensagem geralmente definidas pelo enfileiramento de mensagens foram definidas pelo aplicativo de envio."
  remarks: "O Message Queuing requer a propriedade ConnectorType seja sempre que um aplicativo define uma propriedade de mensagem que é geralmente definida pelo enfileiramento de mensagens. Um aplicativo normalmente usa um ConnectorType nos seguintes casos: - sempre que um aplicativo conector transmite uma mensagem. O ConnectorType informa os aplicativos de envio e recebimento como interpretar as propriedades de segurança e de confirmação da mensagem.      -Sempre que o aplicativo de envio, em vez de enfileiramento de mensagens, criptografa uma mensagem. O ConnectorType informa o enfileiramento de mensagens para usar o <xref:System.Messaging.Message.DestinationSymmetricKey%2A>valor da propriedade para descriptografar a mensagem.</xref:System.Messaging.Message.DestinationSymmetricKey%2A>       Você deve definir a propriedade ConnectorType se você definir qualquer uma das seguintes propriedades (caso contrário, a fila ignora essas propriedades quando a mensagem é enviada):- <xref:System.Messaging.Message.AuthenticationProviderName%2A>- <xref:System.Messaging.Message.AuthenticationProviderType%2A>- <xref:System.Messaging.Message.DestinationSymmetricKey%2A>- <xref:System.Messaging.Message.DigitalSignature%2A>- <xref:System.Messaging.Message.MessageType%2A>- <xref:System.Messaging.Message.SenderId%2A></xref:System.Messaging.Message.SenderId%2A> </xref:System.Messaging.Message.MessageType%2A> </xref:System.Messaging.Message.DigitalSignature%2A> </xref:System.Messaging.Message.DestinationSymmetricKey%2A> </xref:System.Messaging.Message.AuthenticationProviderType%2A> </xref:System.Messaging.Message.AuthenticationProviderName%2A>"
  syntax:
    content: public Guid ConnectorType { get; set; }
    return:
      type: System.Guid
      description: "Um <xref:System.Guid>definido pelo aplicativo e usado em conjunto com aplicativos do conector ou criptografia de mensagens.</xref:System.Guid> Isso <xref:System.Guid>permite que um aplicativo de recebimento interpretar as propriedades de mensagens que foram definidas pelo aplicativo de envio, mas que geralmente são definidas pelo enfileiramento de mensagens.</xref:System.Guid>"
  overload: System.Messaging.Message.ConnectorType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade ConnectorType."
  platform:
  - net462
- uid: System.Messaging.Message.CorrelationId
  id: CorrelationId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o identificador de mensagem usado por confirmação, relatório e mensagens de resposta para fazer referência a mensagem original."
  remarks: "Quando o enfileiramento de mensagens gera uma mensagem de confirmação ou de relatório, ele usa a propriedade do identificador de correlação para especificar o identificador da mensagem da mensagem original. Dessa maneira, o identificador de correlação vincula a mensagem de confirmação ou de relatório à mensagem original.       O aplicativo de envio, em seguida, pode corresponder a confirmação ou relatório com a mensagem original usando a propriedade CorrelationId para identificar a mensagem original <xref:System.Messaging.Message.Id%2A>propriedade.</xref:System.Messaging.Message.Id%2A>       Aplicativos do conector também devem definir a propriedade CorrelationId das mensagens de confirmação e o relatório como o identificador de mensagem da mensagem original.       Quando o aplicativo envia uma mensagem de resposta para o aplicativo de envio, você pode definir a propriedade CorrelationId da mensagem de resposta para o identificador de mensagem da mensagem original. O aplicativo de envio, em seguida, pode corresponder a mensagem de resposta para a mensagem foi enviada."
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_95_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_95_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_95_1.vb)]"
  syntax:
    content: public string CorrelationId { get; set; }
    return:
      type: System.String
      description: "O identificador da mensagem especificado pelo <xref:System.Messaging.Message.Id*>propriedade da mensagem original.</xref:System.Messaging.Message.Id*> O identificador de correlação é usado pelo enfileiramento de mensagens ao gerar uma mensagem de confirmação ou de relatório e por um aplicativo quando ele gera uma mensagem de resposta."
  overload: System.Messaging.Message.CorrelationId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade CorrelationId."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É o CorrelationId <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationQueue
  id: DestinationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a fila de destino pretendido para uma mensagem."
  remarks: "A propriedade FilaDeDestino é mais comumente usada para determinar o destino original de uma mensagem que chegaram em um diário ou fila de mensagens mortas. Normalmente, você não precisa examinar essa propriedade, porque você normalmente recuperar a mensagem da fila de destino."
  example:
  - "The following code example displays the value of a message's DestinationQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue DestinationQueue { get; }
    return:
      type: System.Messaging.MessageQueue
      description: "Um <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> que especifica a fila de destino pretendido para a mensagem."
  overload: System.Messaging.Message.DestinationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade FilaDeDestino."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationSymmetricKey
  id: DestinationSymmetricKey
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a chave simétrica usada para criptografar mensagens criptografadas por aplicativos ou as mensagens enviadas para filas externas."
  remarks: "Dois cenários exigem que você use a propriedade DestinationSymmetricKey. A primeira é quando o seu aplicativo, em vez de enfileiramento de mensagens, criptografa uma mensagem. O segundo é quando você enviar uma mensagem criptografada para um sistema de enfileiramento de mensagens diferente de enfileiramento de mensagens.       Antes de você define essa propriedade, você deve criptografar a chave simétrica com a chave pública do Gerenciador de fila de recebimento. Quando você envia uma mensagem criptografada pelo aplicativo, o Gerenciador de fila de recebimento usa a chave simétrica para descriptografar a mensagem antes de enviá-la para a sua fila de destino.       Se você enviar uma mensagem para uma fila externa, a mensagem é recebida primeiro pelo aplicativo conector apropriado, que encaminha a mensagem criptografada com a chave simétrica anexada para o aplicativo receptor. Em seguida, é responsabilidade do aplicativo de recebimento para descriptografar a mensagem usando a chave simétrica.       Quando você definir a propriedade DestinationSymmetricKey, você também deve definir o <xref:System.Messaging.Message.ConnectorType%2A>propriedade.</xref:System.Messaging.Message.ConnectorType%2A> Quando a mensagem é enviada, enfileiramento de mensagens ignora a propriedade DestinationSymmetricKey se o <xref:System.Messaging.Message.ConnectorType%2A>propriedade também não é definida.</xref:System.Messaging.Message.ConnectorType%2A>       A propriedade DestinationSymmetricKey tem um tamanho de matriz máximo de 256."
  syntax:
    content: public byte[] DestinationSymmetricKey { get; set; }
    return:
      type: System.Byte[]
      description: "Uma matriz de valores de byte que especifica a chave simétrica de destino usada para criptografar a mensagem. O padrão é uma matriz de comprimento zero."
  overload: System.Messaging.Message.DestinationSymmetricKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade DestinationSymmetricKey."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É o DestinationSymmetricKey <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DigitalSignature
  id: DigitalSignature
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a assinatura digital que o enfileiramento de mensagens usa ao autenticar a mensagem."
  remarks: "O Message Queuing usa a assinatura digital na autenticação de mensagens que foram enviadas por versão 1.0 do enfileiramento de mensagens. Na maioria dos casos, o enfileiramento de mensagens gera e define a propriedade DigitalSignature quando o aplicativo de envio solicita autenticação. O aplicativo de recebimento usa essa propriedade para recuperar a assinatura digital anexada à mensagem.       Você só pode usar a propriedade DigitalSignature ao executar a versão 2.0 do enfileiramento de mensagens. O aplicativo de envio deve especificar o Message Queuing assinaturas da versão 1.0 ao solicitar a autenticação. Se o aplicativo de envio envia uma assinatura de versão 2.0 do enfileiramento de mensagens, esta propriedade contém um buffer de quatro bytes, cada contém zero.       A propriedade DigitalSignature, junto com o <xref:System.Messaging.Message.SenderCertificate%2A>propriedade, também é usado por aplicativos de conector quando uma mensagem é enviada.</xref:System.Messaging.Message.SenderCertificate%2A> Nesse cenário, o aplicativo conector — em vez de enfileiramento de mensagens, gera a assinatura digital, ele se baseia no certificado de usuário que está enviando a mensagem.       A propriedade DigitalSignature tem um tamanho de matriz máximo de 256.       Quando você definir a propriedade DigitalSignature, você também deve definir o <xref:System.Messaging.Message.ConnectorType%2A>propriedade.</xref:System.Messaging.Message.ConnectorType%2A> Quando uma mensagem é enviada, enfileiramento de mensagens ignora a propriedade DigitalSignature se o <xref:System.Messaging.Message.ConnectorType%2A>propriedade também não é definida.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] DigitalSignature { get; set; }
    return:
      type: System.Byte[]
      description: "Uma matriz de valores de byte que especifica a assinatura digital do Message Queuing 1.0 usada para autenticar a mensagem. O padrão é uma matriz de comprimento zero."
  overload: System.Messaging.Message.DigitalSignature*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade DigitalSignature."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A propriedade DigitalSignature é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.EncryptionAlgorithm
  id: EncryptionAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o algoritmo de criptografia usado para criptografar o corpo de uma mensagem particular."
  remarks: "Se uma mensagem é particular (criptografada), ele é criptografado antes de ser enviado e descriptografado após o recebimento. A propriedade EncryptionAlgorithm Especifica o algoritmo usado para criptografar o corpo da mensagem de uma mensagem particular.       Uma fila pode exigir que entrada mensagens ser criptografadas. Se um aplicativo envia uma mensagem de (não-particular) não criptografado para uma fila que aceita somente mensagens particulares ou envia uma mensagem particular para uma fila que aceita somente mensagens de não-particular, a fila rejeitará a mensagem. O aplicativo de envio pode solicitar que uma mensagem de confirmação negativa retornado nesse caso."
  syntax:
    content: public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }
    return:
      type: System.Messaging.EncryptionAlgorithm
      description: "Uma da <xref href=&quot;System.Messaging.EncryptionAlgorithm&quot;> </xref> valores de enumeração. O padrão é <xref uid=&quot;langword_csharp_RC2&quot; name=&quot;RC2&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.EncryptionAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade EncryptionAlgorithm."
  platform:
  - net462
- uid: System.Messaging.Message.Extension
  id: Extension
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define informações adicionais, definido pelo aplicativo associadas à mensagem."
  remarks: "Fornece a propriedade de extensão para obter informações definidas pelo aplicativo, como um objeto binário grande, que está associado com a mensagem. É responsabilidade do aplicativo de recebimento para interpretar o conteúdo da propriedade de extensão.       Sempre que possível, você deve incluir dados de mensagem no <xref:System.Messaging.Message.Body%2A>propriedade de mensagem em vez da propriedade de extensão.</xref:System.Messaging.Message.Body%2A>       Ao trabalhar com filas externas, use a propriedade de extensão para especificar propriedades de mensagem que não existem no enfileiramento de mensagens.       Existe uma fila externa em um sistema de enfileiramento de mensagens diferente de enfileiramento de mensagens da Microsoft. O Message Queuing se comunica com essas filas por meio de um aplicativo conector."
  syntax:
    content: public byte[] Extension { get; set; }
    return:
      type: System.Byte[]
      description: "Uma matriz de valores de byte que fornece informações definidas pelo aplicativo associadas à mensagem. O padrão é uma matriz de comprimento zero."
  overload: System.Messaging.Message.Extension*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade de extensão."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A propriedade de extensão é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.Formatter
  id: Formatter
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o formatador usado para serializar ou desserializar um objeto do corpo da mensagem."
  remarks: "Use a propriedade formatador ao ler e gravar uma mensagem. Quando uma mensagem é enviada para a fila, o formatador serializa o <xref:System.Messaging.Message.Body%2A>propriedade em um fluxo que pode ser enviado para a fila de mensagens.</xref:System.Messaging.Message.Body%2A> Ao ler de uma fila, o formatador desserializa os dados da mensagem para o <xref:System.Messaging.Message.Body%2A>propriedade.</xref:System.Messaging.Message.Body%2A>       A menos que você gravar o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A>propriedade, defina a propriedade de formatador antes de enviar a mensagem.</xref:System.Messaging.Message.BodyStream%2A> Quando o <xref:System.Messaging.MessageQueue.Send%2A>método é chamado no <xref:System.Messaging.MessageQueue>instância, o corpo é serializada usando o formatador contido na propriedade formatador.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Se você enviar a mensagem sem especificar um valor para a propriedade de formatador, o formatador padrão <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>       O <xref:System.Messaging.XmlMessageFormatter>é flexível, portanto, não é necessário ter o mesmo objeto ao usar esse formato de tipo no remetente e receptor.</xref:System.Messaging.XmlMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>e <xref:System.Messaging.BinaryMessageFormatter>serializar os dados em representação binária.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> O <xref:System.Messaging.ActiveXMessageFormatter>é usado ao enviar ou receber componentes COM.</xref:System.Messaging.ActiveXMessageFormatter>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_2.vb)]"
  syntax:
    content: public System.Messaging.IMessageFormatter Formatter { get; set; }
    return:
      type: System.Messaging.IMessageFormatter
      description: "O <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> que produz um fluxo a ser gravados ou lidos do corpo da mensagem. O padrão é <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref>."
  overload: System.Messaging.Message.Formatter*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A propriedade formatador é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.HashAlgorithm
  id: HashAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o algoritmo que o enfileiramento de mensagens usa ao autenticar uma mensagem de hash ou criando uma assinatura digital de uma mensagem."
  remarks: "No computador de origem, o enfileiramento de mensagens usa o algoritmo de hash durante a criação de uma assinatura digital de uma mensagem. O Gerenciador de filas de destino, em seguida, usa o mesmo algoritmo de hash para autenticar a mensagem quando ela é recebida."
  syntax:
    content: public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }
    return:
      type: System.Messaging.HashAlgorithm
      description: "Uma da <xref href=&quot;System.Messaging.HashAlgorithm&quot;> </xref> valores de enumeração. Para o Windows XP, o padrão é <xref uid=&quot;langword_csharp_SHA&quot; name=&quot;SHA&quot; href=&quot;&quot;> </xref>. Caso contrário, o padrão é <xref uid=&quot;langword_csharp_MD5&quot; name=&quot;MD5&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade HashAlgorithm."
  platform:
  - net462
- uid: System.Messaging.Message.Id
  id: Id
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém o identificador da mensagem."
  remarks: "O Message Queuing gera um identificador de mensagem quando a mensagem é enviada. O identificador é composto de 20 bytes e inclui dois itens: a máquina <xref:System.Guid>do computador de envio e um identificador exclusivo para a mensagem no computador.</xref:System.Guid> A combinação dos dois itens produz um identificador de mensagem que é exclusivo na rede.       Mensagem de enfileiramento de mensagens gera identificadores de mensagem para todas as mensagens, incluindo mensagens de confirmação e relatório. Geralmente, uma mensagem de confirmação é enviada pelo enfileiramento de mensagens em reação a chegada ou falha de uma mensagem original, enviada. Você pode encontrar o valor da propriedade Id da mensagem original no <xref:System.Messaging.Message.CorrelationId%2A>propriedade de uma mensagem de confirmação.</xref:System.Messaging.Message.CorrelationId%2A>       Você também pode usar a propriedade Id ao enviar uma mensagem de resposta para uma fila de resposta. Para incluir o identificador da mensagem original em uma mensagem de resposta, defina o <xref:System.Messaging.Message.CorrelationId%2A>propriedade da mensagem de resposta para a propriedade de Id da mensagem original.</xref:System.Messaging.Message.CorrelationId%2A> O aplicativo que lê a mensagem de resposta, em seguida, pode usar o identificador de correlação da mensagem de resposta para identificar a mensagem original."
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_19_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_19_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_19_1.vb)]"
  syntax:
    content: public string Id { get; }
    return:
      type: System.String
      description: "Identificador exclusivo a mensagem, que é gerado pelo serviço de enfileiramento de mensagens."
  overload: System.Messaging.Message.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade Id."
  platform:
  - net462
- uid: System.Messaging.Message.InfiniteTimeout
  id: InfiniteTimeout
  parent: System.Messaging.Message
  langs:
  - csharp
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
  type: Field
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Especifica que nenhum tempo limite existe."
  remarks: "<xref:System.Messaging.Message.TimeToBeReceived%2A>e <xref:System.Messaging.Message.TimeToReachQueue%2A>requer um valor que especifica um tempo limite.</xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A> Para o primeiro, o tempo limite é o tempo máximo permitido para uma mensagem a ser recebida da fila. Para o último, o tempo limite é o tempo permitido para uma mensagem chegar à fila. Em ambos os casos, você pode especificar o tempo limite como um número de segundos ou usar InfiniteTimeout para indicar que não existe nenhum tempo limite."
  example:
  - "The following code example demonstrates the use of the InfiniteTimeout field.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public static readonly TimeSpan InfiniteTimeout;
    return:
      type: System.TimeSpan
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.IsFirstInTransaction
  id: IsFirstInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém um valor que indica se a mensagem foi a primeira mensagem enviada em uma transação."
  remarks: "Aplicativos de recebimento usam a propriedade IsFirstInTransaction para verificar se uma mensagem foi a primeira mensagem enviada em uma única transação para uma única fila.       Essa propriedade está disponível somente com o enfileiramento de mensagens versão 2.0 e posterior.       Para verificar limites de transação, você pode usar a propriedade IsFirstInTransaction junto com duas outras propriedades: <xref:System.Messaging.Message.IsLastInTransaction%2A>e <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsLastInTransaction%2A> Use o primeiro para verificar se uma mensagem foi a última mensagem enviada na transação e usar o segundo para recuperar o identificador da transação.       Se apenas uma mensagem é enviada em uma transação, o IsFirstInTransaction e <xref:System.Messaging.Message.IsLastInTransaction%2A>propriedades são definidas como `true`.</xref:System.Messaging.Message.IsLastInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsFirstInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsFirstInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a mensagem foi a primeira mensagem enviada em uma transação; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsFirstInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade IsFirstInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.IsLastInTransaction
  id: IsLastInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém um valor que indica se a mensagem foi a última mensagem enviada em uma transação."
  remarks: "Aplicativos de recebimento usam a propriedade IsLastInTransaction para verificar se uma mensagem foi a última mensagem enviada em uma única transação para uma única fila.       Essa propriedade está disponível somente com o enfileiramento de mensagens versão 2.0 e posterior.       Para verificar limites de transação, você pode usar a propriedade IsLastInTransaction junto com duas outras propriedades: <xref:System.Messaging.Message.IsFirstInTransaction%2A>e <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A> Use o primeiro para verificar se uma mensagem foi a primeira mensagem enviada na transação e usar o segundo para recuperar o identificador da transação.       Se apenas uma mensagem é enviada em uma transação, o <xref:System.Messaging.Message.IsFirstInTransaction%2A>e IsLastInTransaction propriedades são definidas como `true`.</xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsLastInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsLastInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a mensagem foi a última mensagem enviada em uma única transação; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsLastInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade IsLastInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.Label
  id: Label
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define uma cadeia Unicode definido pelo aplicativo que descreve a mensagem."
  remarks: "Você pode usar um rótulo de mensagem para várias finalidades. Por exemplo, você pode usar isso para fins de exibição ou seletivamente processar mensagens com base no valor do rótulo. O rótulo não precisa ser exclusivo entre as mensagens.       Fila de mensagens e mensagem rótulos representam um valor definido pelo aplicativo que pode ajudar a identificam a fila ou a mensagem em termos legível. É responsabilidade do aplicativo para interpretar o conteúdo de rótulo, que não têm nenhum significado intrínseco para o aplicativo do serviço de enfileiramento de mensagens."
  example:
  - "The following code example gets and sets the value of a message's Label property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string Label { get; set; }
    return:
      type: System.String
      description: "O rótulo da mensagem. O padrão é uma cadeia de caracteres vazia (&quot;&quot;)."
  overload: System.Messaging.Message.Label*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade de rótulo."
  platform:
  - net462
- uid: System.Messaging.Message.LookupId
  id: LookupId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Introduzido no MSMQ 3.0. Obtém o identificador de pesquisa da mensagem."
  remarks: "A propriedade Lookupld fornece acesso somente leitura ao identificador de pesquisa da mensagem. O identificador de pesquisa, introduzido no MSMQ 3.0, é um identificador de 64 bits que é gerado pelo serviço de enfileiramento de mensagens e atribuído a cada mensagem quando a mensagem é colocada na fila. O identificador de pesquisa não é o mesmo que o identificador da mensagem que é gerado quando a mensagem é enviada.       O Message Queuing gera um identificador de pesquisa para todas as mensagens são colocadas em qualquer fila, incluindo os gerados pelo aplicativo de destino, administração e filas de relatórios, bem como diário gerado pelo sistema, mensagens mortas, conector e filas de saída. Em outras palavras, isso inclui as duas mensagens enviadas por aplicativos de envio e pelo enfileiramento de mensagens. O identificador de pesquisa é exclusivo para a fila e não tem nenhum significado fora da fila.       Se uma mensagem é enviada para várias filas de destino, ou se uma cópia de uma mensagem é armazenada em um diário de computador ou fila, cada cópia da mensagem terá seu próprio identificador de pesquisa quando ele é colocado na respectiva fila.       A propriedade Lookupld só pode ser lidos em recuperados de uma fila de mensagens.       Um identificador de pesquisa é usado para ler uma mensagem específica na fila. Depois que o identificador de pesquisa de uma mensagem é conhecido, o aplicativo receptor pode chamar o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>ou <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>funcionar para ir diretamente para essa mensagem e inspecionar ou recuperá-la da fila, ao contrário de cursores que deve começar no início da fila e navegue até o final da fila, obter os identificadores de pesquisa de mensagens na fila é de responsabilidade do aplicativo.</xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> </xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Uma maneira possível para obter os identificadores de pesquisa é criar um gatilho para a fila de destino que invoca um componente que armazena em cache os identificadores de cada mensagem conforme eles são colocados em fila."
  syntax:
    content: public long LookupId { get; }
    return:
      type: System.Int64
      description: "Identificador de pesquisa da mensagem, que é gerado pelo serviço de enfileiramento de mensagens e é exclusivo para a fila onde reside a mensagem."
  overload: System.Messaging.Message.LookupId*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "MSMQ 3.0 não está instalado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade Lookupld."
  platform:
  - net462
- uid: System.Messaging.Message.MessageType
  id: MessageType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: 'Gets the message type: <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Acknowledgment&quot; name=&quot;Acknowledgment&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Report&quot; name=&quot;Report&quot; href=&quot;&quot;></xref>.'
  remarks: "O Message Queuing normalmente define essa propriedade quando ele envia a mensagem. Uma mensagem de enfileiramento de mensagens pode ser um dos seguintes tipos:- `Normal`, que é uma mensagem típica enviada de um aplicativo para uma fila ou uma mensagem de resposta retornados para o aplicativo de envio.      - `Acknowledgement`, enfileiramento de mensagens gerado sempre que o aplicativo de envio solicita um. Por exemplo, enfileiramento de mensagens pode gerar mensagens positivas ou negativas para indicar que a mensagem original chegou ou foi lido. O Message Queuing retorna a mensagem de confirmação apropriada para a fila de administração especificada pelo aplicativo de envio.      - `Report`, enfileiramento de mensagens gerado sempre que uma fila de relatórios está definida na fonte de Gerenciador de fila. Quando o rastreamento estiver habilitado, enfileiramento de mensagens envia uma mensagem de relatório para a fila de enfileiramento de mensagens de relatório sempre que a mensagem original entra ou sai de um servidor de enfileiramento de mensagens."
  example:
  - "The following code example displays the value of a message's MessageType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageType MessageType { get; }
    return:
      type: System.Messaging.MessageType
      description: "Um dos valores MessageType."
  overload: System.Messaging.Message.MessageType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade MessageType."
  platform:
  - net462
- uid: System.Messaging.Message.Priority
  id: Priority
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a prioridade da mensagem, que determina onde colocada a mensagem na fila."
  remarks: "A propriedade de prioridade afeta como enfileiramento trata a mensagem enquanto ele estiver em trânsito e depois de atingir o destino. Mensagens de prioridade mais alta são recebem preferência durante o roteamento e inseridas em direção à frente da fila de destino. Mensagens com a mesma prioridade são colocadas na fila de acordo com a hora de chegada.       Você pode definir uma prioridade significativa somente para mensagens não transacionais. O Message Queuing automaticamente define a prioridade de mensagens transacionais para `Lowest`, que faz com que a prioridade da mensagem transacional ser ignorada."
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_87_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_87_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_87_1.cs)]"
  syntax:
    content: public System.Messaging.MessagePriority Priority { get; set; }
    return:
      type: System.Messaging.MessagePriority
      description: "Uma da <xref href=&quot;System.Messaging.MessagePriority&quot;> </xref> valores que representam os níveis de prioridade de mensagens não transacionais. O padrão é <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Priority*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade de prioridade."
  platform:
  - net462
- uid: System.Messaging.Message.Recoverable
  id: Recoverable
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se a mensagem é entregue no caso de um problema de falha ou de rede do computador."
  remarks: "A propriedade recuperável indica se a entrega de uma mensagem é — mesmo que um computador trave enquanto a mensagem estiver a caminho para a fila de destino.       Se a garantia de entrega de uma mensagem, a mensagem é armazenada localmente em cada etapa na rota, até que a mensagem é encaminhada com êxito para o próximo computador. Definir a propriedade recuperável como `true` pode afetar a taxa de transferência.       Se a mensagem for transacional, enfileiramento de mensagens automaticamente trata a mensagem como recuperável, independentemente do valor da propriedade recuperável."
  example:
  - "The following code example gets and sets the value of a message's Recoverable property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Recoverable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a entrega da mensagem é garantida (por meio de salvar a mensagem no disco no caminho); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se a entrega não é garantida. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Recoverable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade recuperável."
  platform:
  - net462
- uid: System.Messaging.Message.ResponseQueue
  id: ResponseQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a fila que recebe mensagens de resposta geradas por aplicativo."
  remarks: "A propriedade ResponseQueue identifica a fila que recebe mensagens de resposta geradas por aplicativo, que retorna o aplicativo de recebimento para o aplicativo de envio. O aplicativo de envio Especifica filas de resposta quando o aplicativo envia suas mensagens. Qualquer fila disponível pode ser especificada como uma fila de resposta.       As mensagens retornadas para a fila de resposta são específicas do aplicativo. O aplicativo deve definir o conteúdo de mensagens, bem como a ação seja após o recebimento de uma mensagem."
  example:
  - "The following code example gets and sets the value of a message's ResponseQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue ResponseQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "O <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> para qual resposta geradas pelo aplicativo, as mensagens são retornadas. O padrão é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.ResponseQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade ResponseQueue."
  platform:
  - net462
- uid: System.Messaging.Message.SecurityContext
  id: SecurityContext
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o contexto de segurança para uma mensagem."
  syntax:
    content: public System.Messaging.SecurityContext SecurityContext { get; set; }
    return:
      type: System.Messaging.SecurityContext
      description: "Um <xref href=&quot;System.Messaging.SecurityContext&quot;> </xref> objeto que contém o contexto de segurança para uma mensagem, se a propriedade foi definida anteriormente; caso contrário, nulo."
  overload: System.Messaging.Message.SecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.SenderCertificate
  id: SenderCertificate
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define o certificado de segurança usado para autenticar mensagens."
  remarks: "O aplicativo de recebimento usa a propriedade SenderCertificate quando a mensagem inclui um certificado de segurança externas.       O Message Queuing pode autenticar uma mensagem usando um certificado de segurança internos ou externos. O Message Queuing fornece certificados internos, que são usados para verificar a integridade de mensagem. Uma autoridade de certificação fornece um certificado externo, você pode acessar por meio da propriedade SenderCertificate da mensagem. Além de permitir que o enfileiramento de mensagens autenticar a mensagem, um certificado externo permite que o aplicativo de recebimento verificar o remetente. Um certificado interno não tem utilizável valor para um aplicativo de recebimento.       Um certificado externo deve ser registrado com o serviço de diretório do sistema de enfileiramento de mensagens. Um certificado externo contém informações sobre a autoridade de certificação, o usuário do certificado, o período de validade do certificado, a chave pública do usuário de certificado e assinatura da autoridade de certificação."
  syntax:
    content: public byte[] SenderCertificate { get; set; }
    return:
      type: System.Byte[]
      description: "Uma matriz de valores de byte que representa um certificado de segurança, enfileiramento de mensagens usa para verificar o remetente da mensagem. O padrão é uma matriz de comprimento zero."
  overload: System.Messaging.Message.SenderCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade SenderCertificate."
  platform:
  - net462
- uid: System.Messaging.Message.SenderId
  id: SenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém o identificador do usuário envio."
  remarks: "Se o <xref:System.Messaging.Message.AttachSenderId%2A>é de propriedade `false`, o identificador de remetente especificado na propriedade SenderId não está anexado à mensagem quando ela é enviada.</xref:System.Messaging.Message.AttachSenderId%2A> Isso indica ao enfileiramento de mensagens que o remetente não deve ser validado quando ele envia a mensagem à fila de destino. Se o <xref:System.Messaging.Message.AttachSenderId%2A>é de propriedade `true`, o valor da propriedade SenderId será confiável somente se a mensagem foi autenticada.</xref:System.Messaging.Message.AttachSenderId%2A> Use o <xref:System.Messaging.Message.Authenticated%2A>propriedade em conjunto com a propriedade SenderId para verificar os direitos de acesso do remetente.</xref:System.Messaging.Message.Authenticated%2A>       Um aplicativo conector é um aplicativo que usa um servidor de conector para fornecer comunicação entre o enfileiramento de mensagens e outros sistemas de enfileiramento de mensagens. O Message Queuing requer aplicativos de conector para a identificação do remetente. Você deve definir o <xref:System.Messaging.Message.ConnectorType%2A>propriedade ao enviar uma mensagem por meio de um aplicativo conector.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] SenderId { get; }
    return:
      type: System.Byte[]
      description: "Uma matriz de valores de byte que identifica o remetente. Gerenciador de fila de recebimento usa o identificador quando ele autentica a mensagem para verificar o remetente da mensagem e os direitos de acesso do remetente para a fila."
  overload: System.Messaging.Message.SenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade SenderId."
  platform:
  - net462
- uid: System.Messaging.Message.SenderVersion
  id: SenderVersion
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a versão do serviço de enfileiramento de mensagens usado para enviar a mensagem."
  remarks: "A propriedade SenderVersion é importante para determinados recursos. Por exemplo, o processamento de transações é suportado somente pelo Message Queuing 2.0 e posteriores, e assinaturas digitais são usadas para autenticar mensagens enviadas pelo MSMQ 1.0.       O Gerenciador de fila de envio define a propriedade SenderVersion quando a mensagem é enviada."
  example:
  - "The following code example displays the value of a message's SenderVersion property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public long SenderVersion { get; }
    return:
      type: System.Int64
      description: "A versão do serviço de enfileiramento de mensagens usado para enviar a mensagem."
  overload: System.Messaging.Message.SenderVersion*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade SenderVersion."
  platform:
  - net462
- uid: System.Messaging.Message.SentTime
  id: SentTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a data e hora no computador de envio que a mensagem foi enviada pelo Gerenciador de fila de origem."
  remarks: "A propriedade de hora de envio é ajustada à hora local do computador no qual essa instância do <xref:System.Messaging.Message>classe foi criada.</xref:System.Messaging.Message> Este fuso horário pode ser diferente das filas de origem e de destino."
  example:
  - "The following code example displays the value of a message's SentTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime SentTime { get; }
    return:
      type: System.DateTime
      description: "Um <xref:System.DateTime>que representa a hora em que a mensagem foi enviada.</xref:System.DateTime>"
  overload: System.Messaging.Message.SentTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade de hora de envio."
  platform:
  - net462
- uid: System.Messaging.Message.SourceMachine
  id: SourceMachine
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém o computador que originou a mensagem."
  remarks: "O formato da propriedade SourceMachine não inclui o anterior duas barras (\\\\\\\\). Por exemplo, `myServer` é um SourceMachine válido."
  example:
  - "The following code example displays the value of a message's SourceMachine property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string SourceMachine { get; }
    return:
      type: System.String
      description: "O nome do computador do qual a mensagem foi enviada."
  overload: System.Messaging.Message.SourceMachine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade SourceMachine."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Não foi possível acessar o serviço de diretório ou de informações do computador."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToBeReceived
  id: TimeToBeReceived
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a quantidade máxima de tempo para a mensagem ser recebida da fila de destino."
  remarks: "A propriedade TimeToBeReceived Especifica o tempo total para uma mensagem enviada ser recebida da fila de destino. O limite de tempo inclui o tempo gasto Obtendo a fila de destino e o tempo gasto aguardando na fila antes da mensagem for recebida.      > [!CAUTION] > Ao usar computadores cliente dependentes, certifique-se de que o relógio no computador cliente está sincronizado com o relógio do servidor que está executando o enfileiramento de mensagens. Caso contrário, o comportamento imprevisível pode resultar quando enviar uma mensagem cuja propriedade TimeToBeReceived não é <xref:System.Messaging.Message.InfiniteTimeout>.</xref:System.Messaging.Message.InfiniteTimeout>       Se o intervalo especificado pela propriedade TimeToBeReceived expira antes que a mensagem é removida da fila, enfileiramento de mensagens descartará a mensagem em uma das duas maneiras. Se a mensagem <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é de propriedade `true`, a mensagem é enviada para a fila de mensagens mortas.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é `false`, a mensagem será ignorada.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Você pode definir a mensagem <xref:System.Messaging.Message.AcknowledgeType%2A>propriedade para solicitar que o serviço de enfileiramento de mensagens envia uma mensagem de confirmação negativa de volta para o aplicativo de envio se a mensagem não foi recuperada antes do timer expira.</xref:System.Messaging.Message.AcknowledgeType%2A>       Se o valor especificado pela propriedade TimeToBeReceived for menor que o valor especificado pelo <xref:System.Messaging.Message.TimeToReachQueue%2A>propriedade TimeToBeReceived terá precedência.</xref:System.Messaging.Message.TimeToReachQueue%2A>       Quando várias mensagens são enviadas em uma única transação, enfileiramento de mensagens usa a propriedade TimeToBeReceived da primeira mensagem."
  example:
  - "The following code example gets and sets the value of a message's TimeToBeReceived property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToBeReceived { get; set; }
    return:
      type: System.TimeSpan
      description: "O tempo total para uma mensagem enviada ser recebida da fila de destino. O padrão é <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToBeReceived*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade TimeToBeReceived."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O valor especificado para TimeToBeReceived é inválido."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToReachQueue
  id: TimeToReachQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define a quantidade máxima de tempo para a mensagem chegar à fila."
  remarks: "Se o intervalo especificado pela propriedade TimeToReachQueue expira antes que a mensagem chega ao seu destino, enfileiramento de mensagens descartará a mensagem em uma das duas maneiras. Se a mensagem <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é de propriedade `true`, a mensagem é enviada para a fila de mensagens mortas.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A>é `false`, a mensagem será ignorada da mensagem podem ser definidas <xref:System.Messaging.Message.AcknowledgeType%2A>propriedade para solicitar que o serviço de enfileiramento de mensagens envia uma mensagem de confirmação negativa de volta para o aplicativo de envio se a mensagem não chegou antes do timer expira.</xref:System.Messaging.Message.AcknowledgeType%2A> </xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Se a propriedade TimeToReachQueue é definida como 0 segundos, enfileiramento de mensagens tenta uma vez para enviar a mensagem para o destino — se a fila está esperando a mensagem. Se a fila for local, a mensagem chega sempre-lo.       Se o valor especificado pela propriedade TimeToReachQueue for maior que o valor especificado pelo <xref:System.Messaging.Message.TimeToBeReceived%2A>propriedade <xref:System.Messaging.Message.TimeToBeReceived%2A>terá precedência.</xref:System.Messaging.Message.TimeToBeReceived%2A> </xref:System.Messaging.Message.TimeToBeReceived%2A>       Quando várias mensagens são enviadas em uma única transação, enfileiramento de mensagens usa a propriedade TimeToReachQueue da primeira mensagem."
  example:
  - "The following code example gets and sets the value of a message's TimeToReachQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToReachQueue { get; set; }
    return:
      type: System.TimeSpan
      description: "O tempo limite para a mensagem chegar à fila de destino, a partir do momento a mensagem é enviada. O padrão é <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToReachQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade TimeToReachQueue."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O valor especificado para TimeToReachQueue é inválido. Ele pode representar um número negativo."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionId
  id: TransactionId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém o identificador para a transação do qual a mensagem era uma parte."
  remarks: "Aplicativos de recebimento usam a propriedade TransactionId para verificar se uma mensagem foi enviada como parte de uma transação específica. O identificador da transação contém o identificador do computador de envio (primeiros 16 bits) seguido por um número de sequência da transação de 4 bytes.       Essa propriedade está disponível somente para enfileiramento de mensagens versão 2.0 e posterior.       Não há garantia de identificadores de transação seja exclusivo, como números de sequência de transação não são persistentes, e eles recomeçar novamente em 2 <sup>20</sup>. O Message Queuing apenas garante que as transações subsequentes terá números de sequência de transação diferente.       Você pode usar a propriedade TransactionId juntamente com o <xref:System.Messaging.Message.IsFirstInTransaction%2A>e <xref:System.Messaging.Message.IsLastInTransaction%2A>Propriedades para verificar limites de transação.</xref:System.Messaging.Message.IsLastInTransaction%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's TransactionId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string TransactionId { get; }
    return:
      type: System.String
      description: "O identificador para a transação associada à mensagem."
  overload: System.Messaging.Message.TransactionId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade de TransactionId."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionStatusQueue
  id: TransactionStatusQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém a fila de status de transação no computador de origem."
  remarks: "A propriedade TransactionStatusQueue identifica a fila transacional no computador de origem que recebe as confirmações de confirmação de leitura de aplicativos do conector. O Message Queuing define a propriedade e os aplicativos de conector para usar a propriedade ao recuperar mensagens transacionais enviadas para filas externas.       Existe uma fila externa em um sistema de enfileiramento de mensagens diferente de enfileiramento de mensagens da Microsoft. O Message Queuing se comunica com essas filas por meio de um aplicativo conector.       O aplicativo do conector pode usar a fila de status de transação para enviar mensagens de confirmação de volta para o aplicativo de envio. A fila de status de transação deve receber essas confirmações, mesmo se o aplicativo de envio não solicita outras confirmações."
  example:
  - "The following code example displays the value of a message's TransactionStatusQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "A fila de status de transação no computador de origem, que é usado para enviar mensagens de confirmação de volta para o aplicativo de envio. O padrão é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.TransactionStatusQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas da fila.       - ou - a fila de mensagens é filtrada para ignorar a propriedade TransactionStatusQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseAuthentication
  id: UseAuthentication
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se a mensagem foi (ou deve ser) autenticada antes que está sendo enviado."
  remarks: "A propriedade UseAuthentication Especifica se a mensagem precisa ser autenticada. Se o aplicativo de envio solicita autenticação, enfileiramento de mensagens cria uma assinatura digital e o utiliza para assinar a mensagem quando ela é enviada e autenticar a mensagem quando ela é recebida.       Se for UseAuthentication `false` e uma mensagem é enviada a uma fila que aceita apenas mensagens autenticadas, a mensagem será rejeitada quando atingir a fila.       Você não pode determinar se uma mensagem de falha na autenticação examinando suas propriedades. O Message Queuing descarta tais mensagens antes que sejam enviadas para a fila. No entanto, você pode solicitar que uma mensagem de confirmação enviada se uma falha de entrega impede que uma mensagem que chega na fila."
  syntax:
    content: public bool UseAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o aplicativo de envio solicitou autenticação para a mensagem. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseAuthentication*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade UseAuthentication."
  platform:
  - net462
- uid: System.Messaging.Message.UseDeadLetterQueue
  id: UseDeadLetterQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se uma cópia da mensagem não pôde ser entregue deve ser enviada a uma fila de mensagens mortas."
  remarks: "O <xref:System.Messaging.Message.UseJournalQueue%2A>e as propriedades de UseDeadLetterQueue especificam como o enfileiramento de mensagens rastreia uma mensagem.</xref:System.Messaging.Message.UseJournalQueue%2A> Se for UseDeadLetterQueue `true`, falha de entrega (de uma mensagem não transacional), faz com que a mensagem a ser enviada para a fila de mensagens mortas não transacional no computador que não foi possível entregar a mensagem. Falha de entrega pode ser causada por um timer de mensagem expirar, por exemplo.       No caso de falha de entrega para uma mensagem transacional, enfileiramento de mensagens envia a mensagem para a fila de mensagens mortas transacional no computador de origem em todos os casos negativos e em dúvida.       Quando você armazena mensagens em uma fila de mensagens mortas, você deve limpar a fila periodicamente para remover as mensagens que não são mais necessários. Mensagens armazenadas na contagem de filas de mensagens mortas em relação à cota de tamanho para o computador em que a fila reside. A cota do computador é definida pelo administrador e refere-se ao tamanho alocado para o armazenamento de mensagens no computador inteiro, não apenas em uma única fila.       Você não criar uma fila de mensagens mortas ou diário. Esses são ambas as filas do sistema que gera enfileiramento de mensagens."
  example:
  - "The following code example gets and sets the value of a message's UseDeadLetterQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseDeadLetterQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a entrega de mensagens deve resultar em uma cópia da mensagem está sendo enviada para uma fila de mensagens mortas; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseDeadLetterQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade UseDeadLetterQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseEncryption
  id: UseEncryption
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se a mensagem privada."
  remarks: "Se uma mensagem for privada, o corpo é criptografado antes de ser enviado e descriptografado quando é recebido. Para enviar uma mensagem particular, o aplicativo de envio deve especificar que a criptografia usado e, opcionalmente, o algoritmo de criptografia.       Ao enviar mensagens particulares, seu aplicativo não precisa executar a criptografia de mensagem. O Message Queuing pode criptografar o corpo da mensagem para você, se seu aplicativo está enviando mensagens dentro de uma empresa, Microsoft Windows 2000, que tem acesso ao serviço de diretório. Ao receber mensagens particulares, o Gerenciador de fila de recebimento sempre descriptografa o corpo da mensagem."
  example:
  - "The following code example gets and sets the value of a message's UseEncryption property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseEncryption { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para exigir que o enfileiramento de mensagens criptografar a mensagem. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseEncryption*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade UseEncryption."
  platform:
  - net462
- uid: System.Messaging.Message.UseJournalQueue
  id: UseJournalQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se uma cópia da mensagem deve ser mantida em um diário de máquina no computador de origem."
  remarks: "O UseJournalQueue e <xref:System.Messaging.Message.UseDeadLetterQueue%2A>propriedades que especificam como o enfileiramento de mensagens rastreia uma mensagem.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Se for UseJournalQueue `true`, em seguida, uma cópia é mantida no diário do computador no computador de origem em cada etapa que uma mensagem é transmitida.       A mensagem enviada somente é copiada para a fila de diário, se a fila de destino estiver em um computador remoto. Se o destino estiver no computador local, a mensagem é enviada diretamente para a fila; Não há nenhuma etapa intermediária para exigir o registro em log.       Quando você armazenar mensagens em uma fila do diário, limpe a fila periodicamente para remover as mensagens que não são mais necessários. Mensagens armazenadas na contagem de filas de diário em relação à cota para o computador em que a fila reside. (A cota do computador é definida pelo administrador).       Você não criar uma fila de mensagens mortas ou diário. Esses são ambas as filas do sistema que gera enfileiramento de mensagens."
  example:
  - "The following code example gets and sets the value of a message's UseJournalQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseJournalQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para exigir que uma cópia de uma mensagem ser mantida no diário de máquina do computador de origem após a mensagem tiver sido transmitidos com êxito (a partir do computador de origem para o próximo servidor); Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseJournalQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade UseJournalQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseTracing
  id: UseTracing
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Obtém ou define um valor que indica se uma mensagem de rastreamento como ele segue para a sua fila de destino."
  remarks: "A propriedade UseTracing Especifica se deve controlar a rota de uma mensagem à medida que se aproxima sua fila de destino. Se `true`, uma mensagem de relatório (gerada pelo enfileiramento de mensagens) é enviada para uma fila de relatórios sempre que a mensagem passa por um servidor de roteamento de enfileiramento de mensagens. A fila de relatórios é especificada pela fonte do Gerenciador de fila. Filas de relatórios não se limitam a mensagens de relatório geradas pelo enfileiramento de mensagens; as mensagens geradas pelo aplicativo também podem ser enviadas para filas de relatórios.       Usando rastreamento envolve a configuração do Active Directory e especificando uma fila de relatórios para a empresa de enfileiramento de mensagens. O administrador configura essas configurações."
  example:
  - "The following code example gets and sets the value of a message's UseTracing property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseTracing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se cada etapa intermediária feita por mensagem original voltados para a fila de destino gera um relatório a ser enviado para a fila de relatórios do sistema; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseTracing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fila de mensagens é filtrada para ignorar a propriedade UseTracing."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.Messaging.Message.#ctor
  parent: System.Messaging.Message
  isExternal: false
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
- uid: System.Messaging.Message.#ctor(System.Object)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
- uid: System.Messaging.IMessageFormatter
  parent: System.Messaging
  isExternal: false
  name: IMessageFormatter
  nameWithType: IMessageFormatter
  fullName: System.Messaging.IMessageFormatter
- uid: System.Messaging.Message.AcknowledgeType
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
- uid: System.Messaging.AcknowledgeTypes
  parent: System.Messaging
  isExternal: false
  name: AcknowledgeTypes
  nameWithType: AcknowledgeTypes
  fullName: System.Messaging.AcknowledgeTypes
- uid: System.Messaging.Message.Acknowledgment
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
- uid: System.Messaging.Acknowledgment
  parent: System.Messaging
  isExternal: false
  name: Acknowledgment
  nameWithType: Acknowledgment
  fullName: System.Messaging.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
- uid: System.Messaging.MessageQueue
  parent: System.Messaging
  isExternal: false
  name: MessageQueue
  nameWithType: MessageQueue
  fullName: System.Messaging.MessageQueue
- uid: System.Messaging.Message.AppSpecific
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Messaging.Message.ArrivedTime
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Messaging.Message.AttachSenderId
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message.Authenticated
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Messaging.Message.AuthenticationProviderType
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
- uid: System.Messaging.CryptographicProviderType
  parent: System.Messaging
  isExternal: false
  name: CryptographicProviderType
  nameWithType: CryptographicProviderType
  fullName: System.Messaging.CryptographicProviderType
- uid: System.Messaging.Message.Body
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
- uid: System.Messaging.Message.BodyStream
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Messaging.Message.BodyType
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
- uid: System.Messaging.Message.ConnectorType
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Messaging.Message.CorrelationId
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.Message.DigitalSignature
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
- uid: System.Messaging.EncryptionAlgorithm
  parent: System.Messaging
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: EncryptionAlgorithm
  fullName: System.Messaging.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
- uid: System.Messaging.Message.Formatter
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
- uid: System.Messaging.HashAlgorithm
  parent: System.Messaging
  isExternal: false
  name: HashAlgorithm
  nameWithType: HashAlgorithm
  fullName: System.Messaging.HashAlgorithm
- uid: System.Messaging.Message.Id
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
- uid: System.Messaging.Message.InfiniteTimeout
  parent: System.Messaging.Message
  isExternal: false
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.Message.IsFirstInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
- uid: System.Messaging.Message.Label
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
- uid: System.Messaging.Message.LookupId
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Messaging.Message.MessageType
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
- uid: System.Messaging.MessageType
  parent: System.Messaging
  isExternal: false
  name: MessageType
  nameWithType: MessageType
  fullName: System.Messaging.MessageType
- uid: System.Messaging.Message.Priority
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
- uid: System.Messaging.MessagePriority
  parent: System.Messaging
  isExternal: false
  name: MessagePriority
  nameWithType: MessagePriority
  fullName: System.Messaging.MessagePriority
- uid: System.Messaging.Message.Recoverable
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
- uid: System.Messaging.SecurityContext
  parent: System.Messaging
  isExternal: false
  name: SecurityContext
  nameWithType: SecurityContext
  fullName: System.Messaging.SecurityContext
- uid: System.Messaging.Message.SenderCertificate
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
- uid: System.Messaging.Message.SenderId
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
- uid: System.Messaging.Message.SenderVersion
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
- uid: System.Messaging.Message.SentTime
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
- uid: System.Messaging.Message.SourceMachine
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
- uid: System.Messaging.Message.#ctor*
  parent: System.Messaging.Message
  isExternal: false
  name: Message
  nameWithType: Message.Message
- uid: System.Messaging.Message.AcknowledgeType*
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
- uid: System.Messaging.Message.Acknowledgment*
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
- uid: System.Messaging.Message.AppSpecific*
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
- uid: System.Messaging.Message.ArrivedTime*
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
- uid: System.Messaging.Message.AttachSenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
- uid: System.Messaging.Message.Authenticated*
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
- uid: System.Messaging.Message.AuthenticationProviderType*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
- uid: System.Messaging.Message.Body*
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
- uid: System.Messaging.Message.BodyStream*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
- uid: System.Messaging.Message.BodyType*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
- uid: System.Messaging.Message.ConnectorType*
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
- uid: System.Messaging.Message.CorrelationId*
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
- uid: System.Messaging.Message.DigitalSignature*
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension*
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
- uid: System.Messaging.Message.Formatter*
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
- uid: System.Messaging.Message.Id*
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
- uid: System.Messaging.Message.IsFirstInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
- uid: System.Messaging.Message.Label*
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
- uid: System.Messaging.Message.LookupId*
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
- uid: System.Messaging.Message.MessageType*
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
- uid: System.Messaging.Message.Priority*
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
- uid: System.Messaging.Message.Recoverable*
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext*
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
- uid: System.Messaging.Message.SenderCertificate*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
- uid: System.Messaging.Message.SenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
- uid: System.Messaging.Message.SenderVersion*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
- uid: System.Messaging.Message.SentTime*
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
- uid: System.Messaging.Message.SourceMachine*
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication*
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption*
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing*
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
