### YamlMime:ManagedReference
items:
- uid: System.Reflection.Emit.DynamicILInfo
  id: DynamicILInfo
  children:
  - System.Reflection.Emit.DynamicILInfo.DynamicMethod
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  langs:
  - csharp
  name: DynamicILInfo
  nameWithType: DynamicILInfo
  fullName: System.Reflection.Emit.DynamicILInfo
  type: Class
  summary: "Fornece suporte para modos alternativos gerar o Microsoft intermediate language (MSIL) e metadados para um método dinâmico, incluindo métodos para criar tokens e para inserir o código, tratamento de exceção e blobs de assinatura de variável local."
  remarks: "A classe DynamicILInfo permite que os desenvolvedores criem seus próprios geradores MSIL em vez de usar <xref:System.Reflection.Emit.ILGenerator>.</xref:System.Reflection.Emit.ILGenerator>       Para criar instâncias de outros tipos, chamar métodos e assim por diante, você gerar MSIL deve incluir tokens para as entidades. A classe DynamicILInfo fornece várias sobrecargas do <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>método que retorne tokens válido no escopo do DynamicILInfo atual.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> Por exemplo, se você precisa chamar uma sobrecarga de <xref:System.Console.WriteLine%2A?displayProperty=fullName>método, você pode obter um <xref:System.RuntimeMethodHandle>para que a sobrecarga e passá-lo para o <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>método para obter um token para incorporar o MSIL.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> </xref:System.RuntimeMethodHandle> </xref:System.Console.WriteLine%2A?displayProperty=fullName>       Uma vez que você criou <xref:System.Byte>matrizes para sua assinatura de variável local, exceções e corpo de código, você pode usar o <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, e <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A>métodos inseri-los no <xref:System.Reflection.Emit.DynamicMethod>associados ao objeto DynamicILInfo.</xref:System.Reflection.Emit.DynamicMethod> </xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A> </xref:System.Byte>       Gerar seus próprios metadados e MSIL requer familiaridade com a documentação de infra-estrutura de linguagem comum (CLI), &quot;especialmente partição II: metadados definição e semântica&quot; e &quot;Partição III: conjunto de instruções CIL&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional.      > [!NOTE] > Não use DynamicILInfo para gerar o código que cria um delegado para outro método dinâmico chamando o construtor delegate diretamente. Em vez disso, use o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>método para criar o delegado.</xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Um delegado que é criado com o construtor delegate não tem uma referência para o método dinâmico de destino. O método dinâmico pode ser recuperado pela coleta de lixo enquanto o representante ainda está em uso."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class DynamicILInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  id: DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém o método dinâmico cujo corpo é gerado pela instância atual."
  remarks: "Um <xref:System.Reflection.Emit.DynamicILInfo>objeto sempre está associado um método dinâmico.</xref:System.Reflection.Emit.DynamicILInfo> A finalidade de <xref:System.Reflection.Emit.DynamicILInfo>classe é fornecer outra maneira de inserir o fluxo MSIL, manipulação de exceção e assinatura de variável local para um método dinâmico, para desenvolvedores que desejam gerar MSIL sem usar a <xref:System.Reflection.Emit.ILGenerator>classe.</xref:System.Reflection.Emit.ILGenerator> </xref:System.Reflection.Emit.DynamicILInfo>"
  syntax:
    content: public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }
    return:
      type: System.Reflection.Emit.DynamicMethod
      description: "Um <xref:System.Reflection.Emit.DynamicMethod>objeto que representa o método dinâmico para o qual atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto está gerando o código.</xref:System.Reflection.Emit.DynamicMethod>"
  overload: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  id: GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa a assinatura para o método dinâmico associado."
  remarks: 'Para obter informações sobre blobs de assinatura, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente &quot;partição II: metadados definição e semântica&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional.'
  syntax:
    content: public int GetTokenFor (byte[] signature);
    parameters:
    - id: signature
      type: System.Byte[]
      description: "Uma matriz que contém a assinatura."
    return:
      type: System.Int32
      description: "Um token que pode ser inserido em metadados e o fluxo MSIL para o método dinâmico associado."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  id: GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um método dinâmico a ser chamado do método associado."
  remarks: "O token retornado por essa sobrecarga de método permite que você chamar um método dinâmico de método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo> Para chamar o método dinâmica associado de forma recursiva, passe o valor da <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>propriedade.</xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>"
  syntax:
    content: public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);
    parameters:
    - id: method
      type: System.Reflection.Emit.DynamicMethod
      description: "O método dinâmico para chamar."
    return:
      type: System.Int32
      description: "Um token que pode ser inserido no fluxo MSIL para o método dinâmico associado, como o destino de uma instrução MSIL."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  id: GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um campo para ser acessado a partir do método dinâmico associado."
  remarks: "Você deve obter um token para qualquer campo que será acessado pelo método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo> Use o <xref:System.Type.GetField%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.FieldInfo>para o campo que você deseja acessar, em seguida, use a <xref:System.Reflection.FieldInfo.FieldHandle%2A>propriedade a ser obtida <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> </xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "O campo a ser acessado."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que acessa os campos no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  id: GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um método a ser acessado a partir do método dinâmico associado."
  remarks: "Você deve obter um token para qualquer método que será acessado pelo método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo> Use o <xref:System.Type.GetMethod%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.MethodInfo>para o método que você deseja acessar e, em seguida, use a <xref:System.Reflection.MethodBase.MethodHandle%2A>propriedade a ser obtida <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> </xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>      > [!NOTE] > Para um método que pertence a um tipo genérico, use o <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>método de sobrecarga e especificar um <xref:System.RuntimeTypeHandle>para o tipo genérico.</xref:System.RuntimeTypeHandle> </xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "O método a ser acessado."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que acessa os métodos, como <xref:System.Reflection.Emit.OpCodes.Call>ou <xref:System.Reflection.Emit.OpCodes.Ldtoken>, no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um tipo a ser usado no método dinâmico associado."
  remarks: "O token retornado por essa sobrecarga de método permite que você definir um tipo de variável local e emitir MSIL para criar uma instância de um tipo no método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo>       Para obter um <xref:System.RuntimeTypeHandle>representando um tipo, use o <xref:System.Type.TypeHandle%2A?displayProperty=fullName>propriedade.</xref:System.Type.TypeHandle%2A?displayProperty=fullName> </xref:System.RuntimeTypeHandle>"
  syntax:
    content: public int GetTokenFor (RuntimeTypeHandle type);
    parameters:
    - id: type
      type: System.RuntimeTypeHandle
      description: "O tipo a ser usado."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que requer um tipo, no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  id: GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa uma cadeia de caracteres literal a ser usado no método dinâmico associado."
  syntax:
    content: public int GetTokenFor (string literal);
    parameters:
    - id: literal
      type: System.String
      description: "A cadeia de caracteres a ser usado."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que requer uma cadeia de caracteres, no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um campo a ser acessado com o método dinâmico associado; o campo é do tipo genérico especificado."
  remarks: "Você deve obter um token para qualquer campo que será acessado pelo método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo> Use o <xref:System.Type.GetField%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.FieldInfo>para o campo que você deseja acessar e, em seguida, use a <xref:System.Reflection.FieldInfo.FieldHandle%2A>propriedade a ser obtida <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> </xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "O campo a ser acessado."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "O tipo genérico que o campo pertence."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que acessa os campos no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Obtém um token válido no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, que representa um método em um tipo genérico."
  remarks: "Você deve obter um token para qualquer método que será chamado pelo método dinâmico associado atual <xref:System.Reflection.Emit.DynamicILInfo>objeto.</xref:System.Reflection.Emit.DynamicILInfo> Use o <xref:System.Type.GetMethod%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.MethodInfo>para o método que você deseja chamar e, em seguida, use a <xref:System.Reflection.MethodBase.MethodHandle%2A>propriedade a ser obtida <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> </xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "O método."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "O tipo genérico que o método pertence."
    return:
      type: System.Int32
      description: "Um token que pode ser usado como o operando de uma instrução MSIL que acessa os métodos, como <xref:System.Reflection.Emit.OpCodes.Call>ou <xref:System.Reflection.Emit.OpCodes.Ldtoken>, no escopo atual <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objeto.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  id: SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define o corpo de código do método dinâmico associado."
  remarks: "Nenhuma verificação de validade é executada no fluxo MSIL.       Chamar esse método uma segunda vez substitui o primeiro fluxo MSIL com a segunda.       Gerar seus próprios metadados e MSIL requer familiaridade com a documentação de infra-estrutura de linguagem comum (CLI), &quot;especialmente partição II: metadados definição e semântica&quot; e &quot;Partição III: conjunto de instruções CIL&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional."
  syntax:
    content: public void SetCode (byte[] code, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte[]
      description: "Uma matriz que contém o fluxo MSIL."
    - id: maxStackSize
      type: System.Int32
      description: "O número máximo de itens na pilha de operando quando o método está sendo executado."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  id: SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define o corpo de código do método dinâmico associado."
  remarks: "Nenhuma verificação de validade é executada no fluxo MSIL.       Chamar esse método uma segunda vez substitui o primeiro fluxo MSIL com a segunda.       Gerar seus próprios metadados e MSIL requer familiaridade com a documentação de infra-estrutura de linguagem comum (CLI), especialmente &quot;partição II: metadados definição e a semântica de&quot; e &quot;partição III: conjunto de instruções CIL.&quot; A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional."
  syntax:
    content: public void SetCode (byte* code, int codeSize, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte*
      description: "Um ponteiro para uma matriz de bytes que contém o fluxo MSIL."
    - id: codeSize
      type: System.Int32
      description: "O número de bytes no fluxo MSIL."
    - id: maxStackSize
      type: System.Int32
      description: "O número máximo de itens na pilha de operando quando o método está sendo executado."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>code</code>é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> e <code>codeSize</code> é maior que 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>codeSize</code>é menor que 0."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  id: SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define os metadados de exceção para o método dinâmico associado."
  remarks: 'Os metadados de exceção para um método definem o local e o tamanho de todos os `try`, `catch`, `finally`, filtro e blocos de falha. Para obter informações sobre o layout de metadados, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente &quot;partição II: metadados definição e semântica&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional.'
  syntax:
    content: public void SetExceptions (byte[] exceptions);
    parameters:
    - id: exceptions
      type: System.Byte[]
      description: "Uma matriz que contém os metadados de exceção."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  id: SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define os metadados de exceção para o método dinâmico associado."
  remarks: 'Os metadados de exceção para um método definem o local e o tamanho de todos os `try`, `catch`, `finally`, filtro e blocos de falha. Para obter informações sobre o layout de metadados, consulte a documentação de infra-estrutura de linguagem comum (CLI), &quot;especialmente partição II: metadados definição e semântica&quot; e &quot;Partição III: conjunto de instruções CIL&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional.'
  syntax:
    content: public void SetExceptions (byte* exceptions, int exceptionsSize);
    parameters:
    - id: exceptions
      type: System.Byte*
      description: "Um ponteiro para uma matriz de bytes que contém os metadados de exceção."
    - id: exceptionsSize
      type: System.Int32
      description: "O número de bytes de metadados de exceção."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>exceptions</code>é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> e <code>exceptionSize</code> é maior que 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>exceptionSize</code>é menor que 0."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  id: SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define a assinatura de variável local que descreve o layout de variáveis locais para o método dinâmico associado."
  remarks: "A assinatura de variável local descreve o layout de variáveis locais do método. Para simplificar a construção da assinatura de variável local, use o `static` (`Shared` no Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.Emit.SignatureHelper>para a assinatura local.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       Para obter informações sobre assinaturas de variável locais, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente &quot;partição II: metadados definição e semântica&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional."
  syntax:
    content: public void SetLocalSignature (byte[] localSignature);
    parameters:
    - id: localSignature
      type: System.Byte[]
      description: "Uma matriz que contém o layout de variáveis locais para o associado <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod>"
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  id: SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Define a assinatura de variável local que descreve o layout de variáveis locais para o método dinâmico associado."
  remarks: "A assinatura de variável local descreve o layout de variáveis locais do método. Para simplificar a construção da assinatura de variável local, use o `static` (`Shared` no Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>método para obter um <xref:System.Reflection.Emit.SignatureHelper>para a assinatura local.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       Para obter informações sobre assinaturas de variável locais, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente &quot;partição II: metadados definição e semântica&quot;. A documentação está disponível online; consulte [ECMA para c# e padrões de infra-estrutura de linguagem comum](http://go.microsoft.com/fwlink/?LinkID=99212) no MSDN e [padrão ECMA-335 - infraestrutura de linguagem comum (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) no site da Ecma internacional."
  syntax:
    content: public void SetLocalSignature (byte* localSignature, int signatureSize);
    parameters:
    - id: localSignature
      type: System.Byte*
      description: "Uma matriz que contém o layout de variáveis locais para o associado <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod>"
    - id: signatureSize
      type: System.Int32
      description: "O número de bytes na assinatura."
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localSignature</code>é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> e <code>signatureSize</code> é maior que 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>signatureSize</code>é menor que 0."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicMethod
  parent: System.Reflection.Emit
  isExternal: true
  name: DynamicMethod
  nameWithType: DynamicMethod
  fullName: System.Reflection.Emit.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: true
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
- uid: System.RuntimeMethodHandle
  parent: System
  isExternal: true
  name: RuntimeMethodHandle
  nameWithType: RuntimeMethodHandle
  fullName: System.RuntimeMethodHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor
  nameWithType: DynamicILInfo.GetTokenFor
- uid: System.Reflection.Emit.DynamicILInfo.SetCode*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode
  nameWithType: DynamicILInfo.SetCode
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions
  nameWithType: DynamicILInfo.SetExceptions
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature
  nameWithType: DynamicILInfo.SetLocalSignature
