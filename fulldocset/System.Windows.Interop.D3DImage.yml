### YamlMime:ManagedReference
items:
- uid: System.Windows.Interop.D3DImage
  id: D3DImage
  children:
  - System.Windows.Interop.D3DImage.#ctor
  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  - System.Windows.Interop.D3DImage.Clone
  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CloneCurrentValue
  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CopyBackBuffer
  - System.Windows.Interop.D3DImage.CreateInstanceCore
  - System.Windows.Interop.D3DImage.Finalize
  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.Height
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  - System.Windows.Interop.D3DImage.Lock
  - System.Windows.Interop.D3DImage.Metadata
  - System.Windows.Interop.D3DImage.PixelHeight
  - System.Windows.Interop.D3DImage.PixelWidth
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  - System.Windows.Interop.D3DImage.Unlock
  - System.Windows.Interop.D3DImage.Width
  langs:
  - csharp
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
  type: Class
  summary: "Um <xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> que exibe uma superfície de Direct3D criado pelo usuário."
  remarks: "Use a classe D3DImage para hospedar conteúdo Direct3D em um aplicativo do Windows Presentation Foundation (WPF).       Chamar o <xref:System.Windows.Interop.D3DImage.Lock%2A>método para alterar o conteúdo de Direct3D exibido pelo D3DImage.</xref:System.Windows.Interop.D3DImage.Lock%2A> Chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método para atribuir uma superfície Direct3D para um D3DImage.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Chamar o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>método para controlar as atualizações para a superfície do Direct3D.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método para exibir as áreas alteradas.</xref:System.Windows.Interop.D3DImage.Unlock%2A>       A classe D3DImage gerencia dois buffers de exibição, que são chamados de *buffer de fundo* e *buffer frontal*. O buffer de fundo é a superfície do Direct3D.  Alterações para o buffer de fundo são copiadas para frente no buffer frontal ao chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método, onde ele é exibido no hardware.</xref:System.Windows.Interop.D3DImage.Unlock%2A> Ocasionalmente, o buffer frontal ficará indisponível. Esta falta de disponibilidade pode ser causada pelo bloqueio de tela, aplicativos Direct3D exclusivos de tela inteira, troca de usuário ou outras atividades do sistema. Quando isso ocorrer, o aplicativo do WPF é notificado manipulando o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Como seu aplicativo responde ao buffer frontal fique indisponível depende se o WPF está habilitado para voltar a renderização por software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que usa um parâmetro que especifica se WPF voltará para renderização por software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Responder a um Buffer frontal indisponível quando WPF não será revertido para a renderização de Software ao chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>sobrecarregar ou chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com a `enableSoftwareFallback` parâmetro definido como `false`, o sistema de processamento libera sua referência para o buffer de fundo quando o buffer principal fica indisponível, e nada é exibido.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando o buffer frontal está disponível novamente, o sistema de processamento gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento para notificar o aplicativo do WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Você pode criar um manipulador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar renderização novamente com uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar o processamento, você deve chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Respondendo a um Buffer frontal indisponível quando WPF cai voltar para renderização de Software quando você chama o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com a `enableSoftwareFallback` parâmetro definido como `true`, o sistema de processamento retém sua referência para o buffer de fundo quando o buffer principal fica indisponível, portanto, não há necessidade de chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando o buffer frontal está disponível novamente.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>  Pode haver situações em que o dispositivo do usuário se torna indisponível.  Quando isso ocorrer, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>para liberar a referência do WPF para o buffer de fundo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Se você precisar redefinir o dispositivo, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com o `backBuffer` parâmetro definido como `null`e, em seguida, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>novamente com `backBuffer` definido como uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      > [!NOTE] > Desempenho depende muito das configurações da superfície Direct3D. Para obter mais informações, consulte [considerações sobre desempenho de Direct3D9 e interoperabilidade do WPF](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > D3DImage a classe não exibe conteúdo Direct3D ao WPF é renderizado no software, como em uma conexão de área de trabalho remota, a menos que você chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>e especifique `true` para o `enableSoftwareFallback` parâmetro.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>"
  example:
  - "The following code example shows how to declare a D3DImage in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-xml[System.Windows.Interop.D3DImage#10](~/add/codesnippet/xaml/d3dhost/window1.xaml#10)]"
  syntax:
    content: 'public class D3DImage : System.Windows.Media.ImageSource'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  - System.Windows.Media.Animation.Animatable
  - System.Windows.Media.ImageSource
  implements: []
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)
  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Media.ImageSource.ToString
  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor
  id: '#ctor'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe."
  remarks: "A resolução de vídeo padrão é 1/96 polegada."
  syntax:
    content: public D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  id: '#ctor(System.Double,System.Double)'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe com a resolução de exibição especificado."
  remarks: "A resolução de vídeo padrão é 1/96 polegada."
  syntax:
    content: public D3DImage (double dpiX, double dpiY);
    parameters:
    - id: dpiX
      type: System.Double
      description: "A resolução de vídeo no eixo x."
    - id: dpiY
      type: System.Double
      description: "A resolução de vídeo no eixo y."
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>dpiX</code>ou <code>dpiY</code> é menor que zero."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  id: AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Especifica a área de buffer de fundo que foram alteradas."
  remarks: "Chame o método AddDirtyRect para indicar as alterações que seu código tenha feito para o buffer de fundo. Para ser processado, a área alterada no buffer de fundo deve ter uma área correspondente alterada em <xref:System.Windows.Interop.D3DImage>.</xref:System.Windows.Interop.D3DImage>       Chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>e <xref:System.Windows.Interop.D3DImage.Lock%2A>métodos antes de chamar o método AddDirtyRect.</xref:System.Windows.Interop.D3DImage.Lock%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método para copiar as áreas alteradas no buffer frontal.</xref:System.Windows.Interop.D3DImage.Unlock%2A>      > [!NOTE] > Após algumas chamadas para o método AddDirtyRect, as áreas alteradas são mescladas em uma única área. Isso significa que você deve ter dados válidos fora de áreas alteradas."
  example:
  - "The following code example shows how to call the AddDirtyRect method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);
    parameters:
    - id: dirtyRect
      type: System.Windows.Int32Rect
      description: "Um <xref href=&quot;System.Windows.Int32Rect&quot;> </xref> que representa a área que foram alteradas."
  overload: System.Windows.Interop.D3DImage.AddDirtyRect*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O bitmap não foi bloqueado por uma chamada para o <> </> *> ou <> </> *> métodos.       - ou - o buffer de fundo não foi atribuído por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer*>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer*>"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um ou mais das seguintes condições é verdadeira.       <code>dirtyRect.X</code>&lt; 0       <code>dirtyRect.Y</code> &lt; 0       <code>dirtyRect.Width</code> &lt; 0 or <code>dirtyRect.Width</code> &gt; <>*>       <code>dirtyRect.Height</code> &lt; 0 or <code>dirtyRect.Height</code> &gt;<>*>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Clone
  id: Clone
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria um clone modificável <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> objeto, fazendo cópias profundas dos valores do objeto. Ao copiar as propriedades de dependência, esse método copia dados e referências de ligações de recurso (que não podem resolver), mas não animações ou seus valores atuais."
  remarks: "Esse método é usado para produzir cópias modificáveis de congelada <xref:System.Windows.Freezable>objetos (ou qualquer <xref:System.Windows.Freezable>objeto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Para sua conveniência, este método sombreia a versão herdada com uma implementação fortemente tipada.       Para obter mais informações, consulte <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage Clone ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Um clone modificável do objeto atual. O objeto clonado <> </> *> propriedade será <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> mesmo se a fonte <> </> *> era de propriedade<xref uid=&quot;langword_csharp_true.&quot; name=&quot;true.&quot; href=&quot;&quot;></xref>"
  overload: System.Windows.Interop.D3DImage.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  id: CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz a instância de um clone (cópia em profundidade) especificada <xref href=&quot;System.Windows.Freezable&quot;> </xref> usando valores de propriedade base (não animado)."
  syntax:
    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O objeto para clonar."
  overload: System.Windows.Interop.D3DImage.CloneCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  id: CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria um clone modificável <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> objeto, fazendo cópias profundas dos valores atuais deste objeto. Referências de recurso, associações de dados e animações não são copiadas, mas seus valores atuais serão copiados."
  remarks: "Esse método é usado para produzir cópias modificáveis de congelada <xref:System.Windows.Freezable>objetos (ou qualquer <xref:System.Windows.Freezable>objeto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Para sua conveniência, este método sombreia a versão herdada com uma implementação fortemente tipada.       Para obter mais informações, consulte <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Um clone modificável do objeto atual. O objeto clonado <> </> *> propriedade será <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> mesmo se a fonte <> </> *> propriedade <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  id: CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz a instância de um clone modificável (cópia em profundidade) especificado <xref href=&quot;System.Windows.Freezable&quot;> </xref> usando os valores da propriedade atual."
  syntax:
    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O <xref href=&quot;System.Windows.Freezable&quot;> </xref> a ser clonado."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  id: CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria uma cópia do software do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O método CopyBackBuffer é chamado por clientes como o sistema de impressão e a <xref:System.Windows.Media.Imaging.RenderTargetBitmap>classe.</xref:System.Windows.Media.Imaging.RenderTargetBitmap>       Opcionalmente, substitua o método CopyBackBuffer para implementar uma lógica personalizada e retornar <xref:System.Windows.Media.Imaging.BitmapSource>.</xref:System.Windows.Media.Imaging.BitmapSource> diferentes Por exemplo, você pode retornar um espaço reservado <xref:System.Windows.Media.Imaging.BitmapSource>se retorna a implementação do padrão CopyBackBuffer `null`.</xref:System.Windows.Media.Imaging.BitmapSource>"
  syntax:
    content: protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();
    parameters: []
    return:
      type: System.Windows.Media.Imaging.BitmapSource
      description: "Um <xref href=&quot;System.Windows.Media.Imaging.BitmapSource&quot;> </xref> que é uma cópia do software do atual estado do buffer de fundo; caso contrário, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o buffer de fundo não pode ser lido."
  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  id: CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Quando implementada em uma classe derivada, cria uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe derivada."
  remarks: "Se você derivar do <xref:System.Windows.Interop.D3DImage>classe, você deve substituir o método CreateInstanceCore para habilitar a clonagem correto.</xref:System.Windows.Interop.D3DImage> A implementação padrão executa um `return new D3DImage()`, que não esteja correto, se a instância é uma classe diferente."
  syntax:
    content: protected override System.Windows.Freezable CreateInstanceCore ();
    parameters: []
    return:
      type: System.Windows.Freezable
      description: "A nova instância."
  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Finalize
  id: Finalize
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Libera recursos e executa outras operações de limpeza antes do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> é recuperada pela coleta de lixo."
  remarks: "Esse método substitui <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> Código do aplicativo não deve chamar esse método; um objeto `Finalize` método é invocado automaticamente durante a coleta de lixo, a menos que a finalização pelo coletor de lixo foi desabilitada por uma chamada para o <xref:System.GC.SuppressFinalize%2A>método.</xref:System.GC.SuppressFinalize%2A>       Para obter mais informações, consulte [métodos Finalize e destruidores](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [limpeza de recursos não gerenciados](~/add/includes/ajax-current-ext-md.md), e [substituindo o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Torna o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> não modificável ou determina se ele pode ser feito não modificável."
  remarks: "O <xref:System.Windows.Interop.D3DImage>classe não permite congelamento porque as alterações são sempre possíveis devido à disponibilidade de buffer frontal.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: protected override sealed bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "Não tem nenhum efeito."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>em todos os casos."
  overload: System.Windows.Interop.D3DImage.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  id: GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz a instância de um clone congelado especificada <xref href=&quot;System.Windows.Freezable&quot;> </xref> usando valores de propriedade base (não animado)."
  syntax:
    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "A instância para copiar."
  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz a instância atual um clone congelado especificada <xref href=&quot;System.Windows.Freezable&quot;> </xref>. Se o objeto tem propriedades de dependência animada, seus valores atuais de animado serão copiados."
  syntax:
    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O <xref href=&quot;System.Windows.Freezable&quot;> </xref> para copiar e congelar."
  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Height
  id: Height
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O valor da altura pode mudar quando um novo buffer de fundo é atribuído por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Height { get; }
    return:
      type: System.Double
      description: "A altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em unidades de medida. Uma unidade de medida é 1/96 polegada."
  overload: System.Windows.Interop.D3DImage.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  id: IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém um valor que indica se existe um buffer frontal."
  remarks: "Ocasionalmente, o buffer frontal ficará indisponível. Esta falta de disponibilidade pode ser causada pelo bloqueio de tela, aplicativos Direct3D exclusivos de tela inteira, troca de usuário ou outras atividades do sistema. Quando isso ocorrer, o aplicativo do WPF é notificado manipulando o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Como seu aplicativo responde ao buffer frontal fique indisponível depende se o WPF está habilitado para voltar a renderização por software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que usa um parâmetro que especifica se WPF voltará para renderização por software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Para obter mais informações, consulte os comentários na <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>      <a name=&quot;dependencyPropertyInfo_IsFrontBufferAvailable&quot;></a># # Informações de propriedade de dependência | | |   |-|-|   | Campo de identificador | <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>"
  example:
  - "The following code example shows how to check the IsFrontBufferAvailable property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#2](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#2)]"
  syntax:
    content: public bool IsFrontBufferAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se existir um buffer frontal. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  id: IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ocorre quando o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>alterações de propriedade.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  remarks: "Tratar IsFrontBufferAvailableChanged para ser notificado quando muda o status de buffer frontal. Como seu aplicativo responde ao buffer frontal fique indisponível depende se o WPF está habilitado para voltar a renderização por software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que usa um parâmetro que especifica se WPF voltará para renderização por software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Para obter mais informações, consulte os comentários na <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  id: IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Identifica o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>DependencyProperty.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Lock
  id: Lock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Bloqueia o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e permite operações no buffer de fundo."
  remarks: "Chame o método de bloqueio para alterar o buffer de fundo chamando o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>e <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>métodos.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Enquanto o <xref:System.Windows.Interop.D3DImage>é bloqueado, seu aplicativo também pode processar para a superfície de Direct3D atribuída para o buffer de fundo.</xref:System.Windows.Interop.D3DImage>      > [!NOTE] > Método Lock o bloqueia quando o sistema de processamento está lendo o buffer de fundo para atualizar o buffer frontal. Use o <xref:System.Windows.Interop.D3DImage.TryLock%2A>método para evitar bloqueio indefinidamente.</xref:System.Windows.Interop.D3DImage.TryLock%2A>"
  example:
  - "The following code example shows how to call the Lock method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Lock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Lock*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A contagem de bloqueio é igual a <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Metadata
  id: Metadata
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém os metadados associados com a origem da imagem."
  syntax:
    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }
    return:
      type: System.Windows.Media.ImageMetadata
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>em todos os casos."
  overload: System.Windows.Interop.D3DImage.Metadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelHeight
  id: PixelHeight
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  remarks: "O valor de PixelHeight pode mudar quando um novo buffer de fundo é atribuído por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelHeight property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelHeight { get; }
    return:
      type: System.Int32
      description: "A altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  overload: System.Windows.Interop.D3DImage.PixelHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelWidth
  id: PixelWidth
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  remarks: "O valor de PixelWidth pode mudar quando um novo buffer de fundo é atribuído por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelWidth property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelWidth { get; }
    return:
      type: System.Int32
      description: "A largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  overload: System.Windows.Interop.D3DImage.PixelWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Atribui uma superfície Direct3D como a origem do buffer de fundo."
  remarks: "Chame o método SetBackBuffer para atribuir uma superfície Direct3D para o buffer de fundo.      > [!NOTE] > Desempenho depende muito das configurações da superfície Direct3D. Para obter mais informações, consulte [considerações sobre desempenho de Direct3D9 e interoperabilidade do WPF](~/add/includes/ajax-current-ext-md.md).       Chamar a sobrecarga de SetBackBuffer é idêntico ao chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com a `enableSoftwareFallback` parâmetro definido como `false`.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando você chama SetBackBuffer ou chamada <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>com o `enableSoftwareFallback` parâmetro definido como `false`, o sistema de processamento libera sua referência para o buffer de fundo quando o buffer frontal ficará indisponível e nada é exibido.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando o buffer frontal está disponível novamente, o sistema de processamento gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento para notificar o aplicativo do WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Você pode criar um manipulador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar renderização novamente com uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar o processamento, você deve chamar SetBackBuffer.       A lista a seguir mostra as configurações do buffer de fundo necessária para o `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` multi-amostras é permitida em `IDirect3DSurface9Ex` superfícies apenas."
  example:
  - "The following code example shows how to call the SetBackBuffer method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "O tipo da superfície do Direct3D. Deve ser um válido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "A superfície do Direct3D para atribuir como o buffer de fundo."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> não foi bloqueado por uma chamada para o <> </> *> ou <> </> *> métodos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>backBufferType</code>não é válido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Os parâmetros de criação para <code> backBuffer </code> não atende aos requisitos para o <code> backBufferType </code>- ou -o <code> backBuffer </code> dispositivo não é válido."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Atribui uma superfície Direct3D como a origem do buffer de fundo."
  remarks: "Quando você chama o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>sobrecarga ou chamar a sobrecarga de SetBackBuffer com o `enableSoftwareFallback` parâmetro definido como `false`, o sistema de processamento libera sua referência para o buffer de fundo quando o buffer principal fica indisponível, e nada é exibido.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando o buffer frontal está disponível novamente, o sistema de processamento gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>evento para notificar o aplicativo do WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Você pode criar um manipulador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar renderização novamente com uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar o processamento, você deve chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Quando você chama SetBackBuffer com o `enableSoftwareFallback` parâmetro definido como `true`, o sistema de processamento retém sua referência para o buffer de fundo quando o buffer principal fica indisponível, portanto, não há necessidade de chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando o buffer frontal está disponível novamente.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Pode haver situações em que o dispositivo do usuário se torna indisponível.  Quando isso ocorrer, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>para liberar a referência do WPF para o buffer de fundo.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Se você precisar redefinir o dispositivo, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com `backBuffer` definida como `null`e, em seguida, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>novamente com `backBuffer` definido como uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       A lista a seguir mostra as configurações do buffer de fundo necessária para o `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` multi-amostras é permitida em `IDirect3DSurface9Ex` superfícies apenas."
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "O tipo da superfície do Direct3D. Deve ser um válido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "A superfície do Direct3D para atribuir como o buffer de fundo."
    - id: enableSoftwareFallback
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para retornar a renderização por software; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  id: TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tenta bloquear o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e aguarda a duração especificada."
  syntax:
    content: public bool TryLock (System.Windows.Duration timeout);
    parameters:
    - id: timeout
      type: System.Windows.Duration
      description: "A duração de espera para o aquisição do bloqueio."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o bloqueio foi adquirido; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.TryLock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>é definido como <xref:System.Windows.Duration.Automatic*>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A contagem de bloqueio é igual a <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Unlock
  id: Unlock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Diminui a contagem de bloqueio para o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Quando a contagem de bloqueio para o <xref:System.Windows.Interop.D3DImage>chegar a zero, o <xref:System.Windows.Interop.D3DImage>está totalmente desbloqueado.</xref:System.Windows.Interop.D3DImage> </xref:System.Windows.Interop.D3DImage> O <xref:System.Windows.Interop.D3DImage>está marcado para renderização se a imagem tiver sido alterada áreas que foram especificadas por chamadas anteriores para o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>método.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> </xref:System.Windows.Interop.D3DImage>       Quando as alterações são confirmadas e processamento ocorre, chamadas adicionais para o <xref:System.Windows.Interop.D3DImage.Lock%2A>Bloco de métodos até que o thread de processamento copiou o conteúdo do buffer de fundo no buffer frontal.</xref:System.Windows.Interop.D3DImage.Lock%2A> Essa sincronização evita artefatos de exibição, como divisão.      > [!NOTE] > Não atualizar a superfície do Direct3D enquanto o <xref:System.Windows.Interop.D3DImage>está desbloqueado.</xref:System.Windows.Interop.D3DImage>"
  example:
  - "The following code example shows how to call the Unlock method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Unlock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Unlock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Width
  id: Width
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O valor de largura pode mudar quando um novo buffer de fundo é atribuído por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Width { get; }
    return:
      type: System.Double
      description: "A largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em unidades de medida. Uma unidade de medida é 1/96 polegada."
  overload: System.Windows.Interop.D3DImage.Width*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.ImageSource
  isExternal: false
  name: System.Windows.Media.ImageSource
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Interop.D3DImage.#ctor
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
- uid: System.Windows.Int32Rect
  parent: System.Windows
  isExternal: false
  name: Int32Rect
  nameWithType: Int32Rect
  fullName: System.Windows.Int32Rect
- uid: System.Windows.Interop.D3DImage.Clone
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
- uid: System.Windows.Interop.D3DImage
  parent: System.Windows.Interop
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
- uid: System.Windows.Freezable
  parent: System.Windows
  isExternal: false
  name: Freezable
  nameWithType: Freezable
  fullName: System.Windows.Freezable
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
- uid: System.Windows.Media.Imaging.BitmapSource
  parent: System.Windows.Media.Imaging
  isExternal: false
  name: BitmapSource
  nameWithType: BitmapSource
  fullName: System.Windows.Media.Imaging.BitmapSource
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
- uid: System.Windows.Interop.D3DImage.Finalize
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.Height
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Interop.D3DImage.Lock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
- uid: System.Windows.Interop.D3DImage.Metadata
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
- uid: System.Windows.Media.ImageMetadata
  parent: System.Windows.Media
  isExternal: false
  name: ImageMetadata
  nameWithType: ImageMetadata
  fullName: System.Windows.Media.ImageMetadata
- uid: System.Windows.Interop.D3DImage.PixelHeight
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Interop.D3DImage.PixelWidth
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
- uid: System.Windows.Interop.D3DResourceType
  parent: System.Windows.Interop
  isExternal: false
  name: D3DResourceType
  nameWithType: D3DResourceType
  fullName: System.Windows.Interop.D3DResourceType
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
- uid: System.Windows.Duration
  parent: System.Windows
  isExternal: false
  name: Duration
  nameWithType: Duration
  fullName: System.Windows.Duration
- uid: System.Windows.Interop.D3DImage.Unlock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
- uid: System.Windows.Interop.D3DImage.Width
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
- uid: System.Windows.Interop.D3DImage.#ctor*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage.D3DImage
- uid: System.Windows.Interop.D3DImage.AddDirtyRect*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect
  nameWithType: D3DImage.AddDirtyRect
- uid: System.Windows.Interop.D3DImage.Clone*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone
  nameWithType: D3DImage.Clone
- uid: System.Windows.Interop.D3DImage.CloneCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore
  nameWithType: D3DImage.CloneCore
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue
  nameWithType: D3DImage.CloneCurrentValue
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore
  nameWithType: D3DImage.CloneCurrentValueCore
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer
  nameWithType: D3DImage.CopyBackBuffer
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore
  nameWithType: D3DImage.CreateInstanceCore
- uid: System.Windows.Interop.D3DImage.Finalize*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize
  nameWithType: D3DImage.Finalize
- uid: System.Windows.Interop.D3DImage.FreezeCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore
  nameWithType: D3DImage.FreezeCore
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore
  nameWithType: D3DImage.GetAsFrozenCore
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore
- uid: System.Windows.Interop.D3DImage.Height*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.Lock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock
  nameWithType: D3DImage.Lock
- uid: System.Windows.Interop.D3DImage.Metadata*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
- uid: System.Windows.Interop.D3DImage.PixelHeight*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
- uid: System.Windows.Interop.D3DImage.PixelWidth*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer
  nameWithType: D3DImage.SetBackBuffer
- uid: System.Windows.Interop.D3DImage.TryLock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock
  nameWithType: D3DImage.TryLock
- uid: System.Windows.Interop.D3DImage.Unlock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock
  nameWithType: D3DImage.Unlock
- uid: System.Windows.Interop.D3DImage.Width*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
