### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "Representa uma propriedade que pode ser definida por meio de métodos, como estilos, associação de dados, animação e herança."
  remarks: "Um DependencyProperty suporta os seguintes recursos no [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-a propriedade pode ser definida em um estilo. Para obter mais informações, consulte [estilos e modelagem](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode ser definida por meio de associação de dados. Para obter mais informações sobre propriedades de dependência de associação de dados, consulte [como: associar as propriedades de dois controles](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode ser definida com uma referência de recurso dinâmico. Para obter mais informações, consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode herdar seu valor automaticamente de um elemento pai na árvore de elementos. Para obter mais informações, consulte [herança de valor de propriedade](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode ser animada. Para obter mais informações, consulte [visão geral de animação](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode relatar quando o valor anterior da propriedade foi alterado e o valor da propriedade pode ser forçado. Para obter mais informações, consulte [retornos de chamada de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md).      -A propriedade informa ao [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], como se a alteração de um valor de propriedade deve exigir o sistema de layout para recompor a visualização de um elemento.      -A propriedade recebe suporte a [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Por exemplo, a propriedade pode ser editada no **propriedades** janela.       Para saber mais sobre as propriedades de dependência, consulte [visão geral de propriedades de dependência](~/add/includes/ajax-current-ext-md.md). Se você quiser propriedades em seus tipos personalizados para dar suporte os recursos da lista anterior, você deve criar uma propriedade de dependência.  Para saber como criar propriedades de dependência personalizadas, consulte [propriedades personalizadas de dependência](~/add/includes/ajax-current-ext-md.md).       Uma propriedade anexada é uma propriedade que permite que qualquer objeto de informações de relatório para o tipo que define a propriedade anexada. Em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], qualquer tipo que herda de <xref:System.Windows.DependencyObject>pode usar uma propriedade anexada, independentemente se o tipo herda do tipo que define a propriedade.</xref:System.Windows.DependencyObject> Uma propriedade anexada é um recurso do [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] idioma.  Para definir uma propriedade anexada no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], use o *ownerType*.* propertyName* sintaxe. É um exemplo de uma propriedade anexada a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>propriedade.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Se você deseja criar uma propriedade que pode ser usada em todos os <xref:System.Windows.DependencyObject>tipos, em seguida, você deve criar uma propriedade anexada.</xref:System.Windows.DependencyObject> Para saber mais sobre propriedades anexadas, incluindo como criá-los, consulte [visão geral de propriedades anexado](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a># # Uso do atributo XAML ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> # # XAML valores `dependencyPropertyName` uma cadeia de caracteres que especifica o <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>da propriedade de dependência desejado.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       Isso pode ser precedido por um prefixo de namespace XML, se a propriedade não está no namespace XML padrão (para obter detalhes, consulte [Namespaces XAML e o mapeamento de Namespace para WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    Uma cadeia de caracteres que especifica um tipo de proprietário de uma propriedade de dependência, um ponto (.) e <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> `ownerType`também pode ser precedido por um prefixo de namespace XML. Esse uso é específico para estilos de associação tardia e modelos, em que o proprietário da propriedade de dependência deve ser especificado para analisar o contexto porque o `TargetType` ainda não é conhecido. Para obter mais informações, consulte [estilos e modelagem](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Uma cadeia de caracteres que especifica o proprietário de uma propriedade anexada, um ponto (.), o nome da propriedade anexada. `attachedPropertyOwnerType`também pode ser precedido por um prefixo de namespace XML."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Adiciona outro tipo como um proprietário de uma propriedade de dependência que já foi registrado."
  remarks: "Esse método permite que o sistema de propriedade reconhecer uma propriedade de dependência em um tipo que não se registrou essa determinada propriedade de dependência inicialmente.       Normalmente, AddOwner é usado para adicionar propriedades de dependência para classes que não expõem essa propriedade de dependência por meio da herança de classes gerenciada (herança de classe causaria o wrapper de propriedades seja herdada pela classe derivada e, portanto, deve fornecer acesso geral da tabela de membros para a propriedade de dependência já). AddOwner permite que o sistema de propriedade reconhecer uma propriedade de dependência em um tipo que não se registrou essa propriedade de dependência inicialmente.       Esta assinatura não permite a especificação de metadados.  Quando você usar esse método, os metadados são gerados automaticamente para o novo <xref:System.Windows.DependencyProperty>e seu tipo de proprietário.</xref:System.Windows.DependencyProperty> Os metadados gerada automaticamente são o resultado dos metadados mesclado de todos os tipos base que têm esta propriedade definida. Se nenhum metadado mesclado estiver disponível, os metadados padrão para a propriedade é usado. Se a propriedade é registrada com o uso de <xref:System.Windows.DependencyProperty.RegisterAttached%2A>método e, em seguida, os metadados padrão é o mesmo que os metadados que é criado quando <xref:System.Windows.DependencyProperty.RegisterAttached%2A>foi chamado.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> Caso contrário, o <xref:System.Windows.PropertyMetadata>objeto é criado com o <xref:System.Windows.PropertyMetadata.DefaultValue%2A>propriedade definida como padrão do tipo de propriedade e todas as outras propriedades do <xref:System.Windows.PropertyMetadata>é definido como `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Use o <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>assinatura se você deseja fornecer metadados para a versão da propriedade de dependência conforme adicionados para o tipo fornecido.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       O valor de retorno desse método é normalmente usado para declarar e expor a propriedade de dependência, armazenando um identificador de propriedade de dependência. O identificador fornece acesso para a propriedade de dependência para chamar o sistema de propriedade [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] em relação à propriedade de dependência, particularmente à medida que ele existe na classe adicionando proprietário. O mesmo nome de propriedade para o proprietário original e o proprietário adicionado deve ser usado para indicar a funcionalidade semelhante. Você deve usar o <xref:System.Windows.DependencyProperty>retornar o valor do método AddOwner para definir o identificador de propriedade de dependência e também declarar [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade para propriedades de dependência que são adicionadas aos tipos usando AddOwner.</xref:System.Windows.DependencyProperty>       A metodologia de AddOwner recomendada acima é usada ao criar as propriedades de dependência são declaradas em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Por exemplo, ambos <xref:System.Windows.Controls.Border>e <xref:System.Windows.Controls.Control>definem um `BorderBrush` propriedade de dependência, que tem uma funcionalidade semelhante.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Define o `BorderBrush` propriedade para o sistema de propriedade chamando AddOwner baseia-se o proprietário original <xref:System.Windows.Controls.Border>e seu registrado <xref:System.Windows.Controls.Border.BorderBrushProperty>identificador de propriedade de dependência.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> O AddOwner retornar o valor é usado para estabelecer um nova estático <xref:System.Windows.DependencyProperty>campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para essa propriedade no proprietário adicional e um `BorderBrush` wrapper de propriedade também está declarado.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "O tipo a ser adicionado como um proprietário dessa propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Uma referência ao valor original <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador que identifica a propriedade de dependência. Esse identificador deve ser exposto pela classe adicionando como um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Adiciona outro tipo como um proprietário de uma propriedade de dependência que já foi registrado, fornecendo metadados de propriedade de dependência para a propriedade de dependência, como será mostrado no tipo de proprietário fornecidos."
  remarks: "Esse método permite que o sistema de propriedade reconhecer uma propriedade de dependência em um tipo que não se registrou essa determinada propriedade de dependência inicialmente.       O valor de retorno desse método é usado para declarar e expor a propriedade de dependência, especialmente, se houver sobre a adição de classe proprietário. Em geral, o mesmo nome de propriedade para o proprietário original e o proprietário adicionado deve ser usado para indicar a funcionalidade semelhante. É uma boa prática para expor os identificadores, bem como novos [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade para propriedades de dependência que são adicionadas aos tipos usando <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>       O <xref:System.Windows.DependencyProperty.AddOwner%2A>metodologia recomendada acima é usada ao criar [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] declarado em [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Por exemplo, ambos <xref:System.Windows.Controls.Border>e <xref:System.Windows.Controls.Control>definem um `BorderBrush` propriedade de dependência, que tem uma funcionalidade semelhante.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Define o `BorderBrush` propriedade para o sistema de propriedade chamando <xref:System.Windows.DependencyProperty.AddOwner%2A>no proprietário original <xref:System.Windows.Controls.Border>e seu registrado <xref:System.Windows.Controls.Border.BorderBrushProperty>identificador de propriedade de dependência.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> O <xref:System.Windows.DependencyProperty.AddOwner%2A>retornar o valor é usado para estabelecer um estático <xref:System.Windows.DependencyProperty>campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para essa propriedade no proprietário adicional e um `BorderBrush` wrapper de propriedade também está declarado.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Identificador de propriedade de dependência do proprietário adicionado deve ser usado para operações como <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> No entanto, as operações de tipo específico que envolvem tipos ou instâncias da classe que foi adicionado como proprietário com diferentes metadados ainda retornam o mesmo que resultados esperados original (não adicionado do proprietário) identificador de propriedade de dependência é especificado em chamadas para métodos como <xref:System.Windows.DependencyObject.GetValue%2A>ou <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> Os metadados para o proprietário adicionado é adicionas pelo AddOwner chamar a mesmo, não necessariamente referenciado exclusivamente pelo campo de identificador de classe adicionando proprietário. No entanto, é recomendável para expor o identificador, bem como novo [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade para propriedades de dependência que são adicionadas aos tipos usando AddOwner, porque isso não for feito cria discrepância entre o [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] e [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] representações de suas propriedades.       Os metadados fornecidos são mesclados com os metadados de propriedade para a propriedade de dependência conforme ela existe no proprietário da base. Quaisquer características que foram especificadas nos metadados de base original serão mantido. Somente essas características que foram alteradas especificamente os novos metadados substituirá as características dos metadados de base. Algumas características, como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, serão substituídos se forem especificados em novos metadados.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outras, como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> Por fim, o comportamento de mesclagem depende do tipo de metadados de propriedade que está sendo usado para a substituição, portanto, o comportamento descrito aqui é para as classes de metadados de propriedade existentes usadas pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades de dependência. Para obter detalhes, consulte [metadados de propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [metadados de propriedade do Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "O tipo a ser adicionado como proprietário desta propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados que qualifica a propriedade de dependência conforme ela existe no tipo fornecido."
    return:
      type: System.Windows.DependencyProperty
      description: "Uma referência ao valor original <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador que identifica a propriedade de dependência. Esse identificador deve ser exposto pela classe adicionando como um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém os metadados padrão da propriedade de dependência."
  remarks: "Os metadados padrão são os metadados da propriedade que está disponível para esse objeto em particular ou um objeto de um tipo derivado onde nenhum metadado alternativo fornecido pelo explícito <xref:System.Windows.DependencyProperty.Register%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chame.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Se o proprietário original aplicado metadados para o primeiro <xref:System.Windows.DependencyProperty.Register%2A>chamada que estabeleceu a propriedade de dependência, e que os metadados são retornados como DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A>       Se nenhum metadado foi aplicado no original <xref:System.Windows.DependencyProperty.Register%2A>chamar, em seguida, são gerados os metadados de padrão de dentro de <xref:System.Windows.DependencyProperty.Register%2A>chamada e esse valor é retornado como o DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       A principal finalidade de ter metadados padrão associados a um <xref:System.Windows.DependencyProperty>é fornecer um valor padrão para essa propriedade em qualquer <xref:System.Windows.DependencyObject>ou um tipo derivado.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       Para propriedades de via, o tipo de metadados retornado por essa propriedade não pode ser convertido para tipos derivados de <xref:System.Windows.PropertyMetadata>tipo, mesmo se a propriedade foi registrada originalmente com um tipo derivado de metadados.</xref:System.Windows.PropertyMetadata> Se você quiser que os metadados originalmente registrados, incluindo seu tipo derivado possivelmente metadados original, chamar <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>em vez disso, passando o registro original tipo como um parâmetro.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       Para propriedades anexadas, o tipo de metadados retornado por essa propriedade corresponderá o tipo de dado no original <xref:System.Windows.DependencyProperty.RegisterAttached%2A>método de registro.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "Os metadados padrão da propriedade de dependência."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna um código hash para este <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "O sistema de propriedade usa seu próprio identificador exclusivo <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, e o valor dessa propriedade é retornado por GetHashCode.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "O código hash para este <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna os metadados para essa propriedade de dependência conforme ela existe em um tipo existente especificado."
  remarks: "Especificar o tipo ou uma referência de objeto a ser usado como o tipo é necessário porque os metadados podem variar com o registro original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas que alterar os metadados da propriedade de dependência conforme ela existe em um tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo específico do qual recuperar os metadados da propriedade de dependência."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados de propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna os metadados para essa propriedade de dependência conforme ela existe na instância do objeto especificado."
  remarks: "Especificar o tipo ou uma referência de objeto é necessária porque os metadados de qualquer propriedade de dependência podem variar com o registro original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas que podem refinar os metadados da propriedade conforme ela existe em um tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Quando você solicita metadados de propriedade com base em uma instância, você está passando apenas a instância para que seu tipo pode ser avaliado internamente. Metadados de propriedade de dependência não variam por instância. sempre é consistente para qualquer combinação de propriedades de tipo determinado."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Um objeto de dependência é verificado para determinar qual versão de um tipo específico da propriedade de dependência de metadados devem vir do tipo."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados de propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna os metadados para essa propriedade de dependência conforme ela existe em um tipo especificado."
  remarks: "Especificar o tipo ou uma referência de objeto é necessária porque os metadados de qualquer propriedade de dependência podem variar com o registro original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas que podem refinar os metadados da propriedade conforme ela existe em um tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Um objeto específico que registra o tipo de objeto de dependência da qual os metadados de propriedade de dependência é desejado."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados de propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um valor gerado internamente que identifica exclusivamente a propriedade de dependência."
  remarks: "Esse valor não é um inteiro, um [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. Em geral, não é necessário usar esse valor de índice, e não existe índice acesso às tabelas de todas as propriedades de dependência. Propriedades de dependência em vez disso, devem ser referenciadas por seus campos de identificador.       GlobalIndex é usada internamente para acesso mais rápido às estruturas de dados que usam o GlobalIndex como um índice de matriz com base em zero. Um uso semelhante pode ter aplicativos para designers ou ferramentas."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Um identificador numérico exclusivo."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Determina se um valor especificado é aceitável para o tipo da propriedade de dependência, como verificado em relação ao tipo de propriedade fornecido no registro de propriedade de dependência original."
  remarks: "Um valor de `null` é um tipo válido de propriedade de dependência de tipo de referência, ou para um <xref:System.Nullable%601>propriedade de dependência e retornaria `true` para esses casos.</xref:System.Nullable%601> Em casos em que a propriedade de dependência é uma referência nem nem um <xref:System.Nullable%601>tipo, IsValidType retornará `false` para um valor nulo em vez de gerar uma exceção.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "O valor para verificar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor especificado é o tipo de propriedade registrada ou um tipo derivado aceitável; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Determina se o valor fornecido é aceita para o tipo de propriedade por meio de verificação de tipo básico e também potencialmente se ele está dentro do intervalo permitido de valores para esse tipo."
  remarks: "Para uma propriedade de dependência, um intervalo de valores para esse tipo permitido pode ser especificado por meio de um <xref:System.Windows.ValidateValueCallback>que é fornecido no registro de propriedade de dependência.</xref:System.Windows.ValidateValueCallback>       Este método chama <xref:System.Windows.DependencyProperty.IsValidType%2A>internamente.</xref:System.Windows.DependencyProperty.IsValidType%2A> Se a propriedade de dependência em questão não possuir <xref:System.Windows.ValidateValueCallback>em seguida, chamar este método é efetivamente equivalente a chamar <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback> Se a propriedade de dependência tem um <xref:System.Windows.ValidateValueCallback>e se <xref:System.Windows.DependencyProperty.IsValidType%2A>poderia ter retornado `true`, o valor retornado será conforme implementado no retorno de chamada.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Um valor nulo é um valor válido para propriedades de dependência de tipo de referência, ou para um <xref:System.Nullable%601>propriedade de dependência e retornaria `true` para esses casos.</xref:System.Nullable%601> Em casos em que a propriedade de dependência é uma referência nem nem um <xref:System.Nullable%601>tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A>retornará `false` para um valor nulo em vez de gerar uma exceção.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "O valor para verificar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor é aceitável e é do tipo correto ou um tipo derivado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o nome da propriedade de dependência."
  remarks: "Essa propriedade obtém o nome fornecido como o `name` parâmetro durante o registro de propriedade de dependência. Esse nome é imutável e não pode ser `null` ou uma cadeia de caracteres vazia. Os registros de nome duplicado do mesmo tipo de proprietário não são permitidos e lançará uma exceção ao tentar registrar a duplicata.      > [!IMPORTANT] > O nome de uma propriedade de dependência devem seguir a convenção de correspondência, o nome de seu identificador de propriedade de dependência menos o sufixo &quot;Property&quot;. Para obter detalhes, consulte [propriedades de dependência personalizadas](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "O nome da propriedade."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Especifica metadados alternativo para essa propriedade de dependência quando ele está presente em instâncias de um tipo especificado, substituindo os metadados existentes para a propriedade de dependência conforme ela foi herdada de tipos base."
  remarks: "Metadados de propriedade de dependência devem ser substituído antes do sistema de propriedade usa a propriedade de dependência. Isso é igual ao tempo que instâncias específicas são criadas usando a classe que registra a propriedade de dependência. Chamadas para OverrideMetadata só devem ser executadas dentro de construtores estáticos do tipo que fornece a próprio como o `forType` parâmetro deste método, ou por meio de instanciação semelhante. Tentativa de alterar os metadados depois que houver instâncias do tipo proprietário não gerará exceções, mas resultará em comportamentos inconsistente no sistema de propriedade.       Depois que os metadados para uma substituição de determinada classe derivada é estabelecido com esse método, as tentativas subsequentes para substituir os metadados sobre essa mesma classe derivada gerará uma exceção.       Os metadados fornecidos são mesclados com os metadados de propriedade para a propriedade de dependência conforme ela existe no proprietário da base. Quaisquer características que foram especificadas nos metadados de base original serão mantido; somente essas características que foram alteradas especificamente os novos metadados substituirá as características dos metadados de base. Algumas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>são substituídos, se especificado nos metadados de novo.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outras, como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> Por fim, o comportamento de mesclagem depende do tipo de metadados de propriedade que está sendo usado para a substituição, portanto, o comportamento descrito aqui é para as classes de metadados de propriedade existentes usadas pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades de dependência. Para obter detalhes, consulte [metadados de propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [metadados de propriedade do Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo de onde essa propriedade de dependência é herdada e onde os metadados alternativo fornecido serão aplicado."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados a serem aplicados para a propriedade de dependência no tipo de substituição."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi feita uma tentativa para substituir os metadados em uma propriedade de dependência somente leitura (que a operação não pode ser feita usando essa assinatura)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Metadados já foi estabelecido para a propriedade de dependência conforme ela existe no tipo fornecido."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Fontes alternam metadados para uma propriedade de dependência somente leitura quando ele está presente em instâncias de um tipo especificado, substituindo os metadados que foi fornecido no registro de propriedade de dependência inicial. Você deve passar o <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> para a propriedade de dependência somente leitura para não gerar uma exceção."
  remarks: "Esta assinatura fornece implementação subjacente para um identificador de propriedade de dependência somente leitura (<xref:System.Windows.DependencyPropertyKey>) método.</xref:System.Windows.DependencyPropertyKey> Se substituir os metadados para uma propriedade de dependência de leitura / gravação, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Metadados de propriedade de dependência devem ser substituído antes do sistema de propriedade usa a propriedade de dependência. Isso é igual ao tempo que são criados objetos específicos para a classe que registra a propriedade de dependência. Chamadas para <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>só deve ser executada dentro de construtores estáticos do tipo que fornece a próprio como o `forType` parâmetro deste método, ou por meio de instanciação semelhante.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Tentativa de alterar os metadados depois que houver instâncias do tipo proprietário não gerará exceções, mas resultará em comportamentos inconsistente no sistema de propriedade.       Depois que os metadados para uma substituição de determinada classe derivada é estabelecido com esse método, as tentativas subsequentes para substituir os metadados sobre essa mesma classe derivada gerará uma exceção.       Os metadados fornecidos são mesclados com os metadados de propriedade para a propriedade de dependência conforme ela existe no proprietário da base. Quaisquer características que foram especificadas nos metadados de base original serão mantido; somente essas características que foram alteradas especificamente os novos metadados substituirá as características dos metadados de base. Algumas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>são substituídos, se especificado nos metadados de novo.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outras, como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> O comportamento de mesclagem depende do tipo de metadados de propriedade que está sendo usado para a substituição. Para obter detalhes, consulte [metadados de propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [metadados de propriedade do Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo de onde essa propriedade de dependência é herdada e onde os metadados alternativo fornecido serão aplicado."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados a serem aplicados para a propriedade de dependência no tipo de substituição."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "A chave de acesso para uma propriedade de dependência somente leitura."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o tipo do objeto que registrou a propriedade de dependência com o sistema de propriedade ou adicionado a mesmo como proprietário da propriedade."
  remarks: "Esse valor foi fornecido durante o registro de propriedade. O proprietário será o tipo do registro original no caso de um <xref:System.Windows.DependencyProperty>identificador gerado a partir de um <xref:System.Windows.DependencyProperty.Register%2A>chamada ou o tipo que adicionou em si como proprietário no caso de um <xref:System.Windows.DependencyProperty>identificador gerado a partir de um <xref:System.Windows.DependencyProperty.AddOwner%2A>chame.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       OwnerType em qualquer dado <xref:System.Windows.DependencyProperty>é imutável e não pode ser `null` em <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> válido</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "O tipo do objeto que registrou a propriedade ou adicionado a mesmo como proprietário da propriedade."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o tipo que usa a propriedade de dependência para seu valor."
  remarks: "Essa propriedade informa o tipo de valor da propriedade conforme declarado pelo registro original de propriedade, por meio de `propertyType` parâmetro. Semelhante do <xref:System.Windows.DependencyProperty.Name%2A>, o tipo de propriedade de uma propriedade de dependência é imutável depois do registro.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "O <xref:System.Type>do valor da propriedade.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um valor que indica se a propriedade de dependência é identificado por esse <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> instância é uma propriedade de dependência somente leitura."
  remarks: "Propriedades de dependência somente leitura são registradas no sistema de propriedade chamando o <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>método em vez do <xref:System.Windows.DependencyProperty.Register%2A>método.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Propriedades anexadas também podem ser registradas como somente leitura; consulte <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Propriedades de dependência somente leitura exigem um <xref:System.Windows.DependencyPropertyKey>identificador em vez de <xref:System.Windows.DependencyProperty>identificador para executar operações de metadados, como substituir os metadados ou definir o valor.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Se você tiver obtido uma coleção de <xref:System.Windows.DependencyProperty>identificadores por meio de uma chamada para <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>ou outro [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] que expõe identificadores, verifique o valor de ReadOnly antes de tentar chamar <xref:System.Windows.DependencyObject.SetValue%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>usando esse identificador de propriedade de dependência como um parâmetro de entrada para verificar se a propriedade de dependência que representa o identificador não é somente leitura.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Se o valor de ReadOnly for `true` em uma propriedade de dependência, não há nenhuma maneira programática para obter uma referência para o <xref:System.Windows.DependencyPropertyKey>identificador de propriedade de dependência, a partir de metadados ou o <xref:System.Windows.DependencyProperty>identificador; o identificador deve estar disponível como um campo estático para chamar <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>em relação a uma propriedade de dependência somente leitura.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       Quando você cria uma propriedade de dependência personalizada e registrá-lo como somente leitura, você deve definir apenas um acessador get para a [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] propriedade wrapper. Caso contrário, sua classe terá um modelo de objeto confuso para o wrapper de propriedade em comparação com o acesso para a propriedade de dependência de backup. Para obter detalhes, consulte [propriedades de dependência personalizadas](~/add/includes/ajax-current-ext-md.md) ou [propriedades de dependência somente leitura](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência é somente leitura; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade de dependência com o nome da propriedade especificado, o tipo de propriedade e o tipo de proprietário."
  remarks: "Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar. O nome deve ser exclusivo no namespace de registro do tipo de proprietário."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade de dependência com o nome da propriedade especificado, o tipo de propriedade, tipo de proprietário e metadados de propriedade."
  remarks: "Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade de dependência com o nome da propriedade especificado, o tipo de propriedade, tipo de proprietário, metadados de propriedade e um retorno de chamada de validação do valor da propriedade."
  remarks: "Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a um retorno de chamada que deve executar qualquer validação personalizada do valor da propriedade de dependência além da validação de tipo comum."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade anexada com o nome da propriedade especificado, o tipo de propriedade e o tipo de proprietário."
  remarks: "Uma propriedade anexada é um conceito de propriedade definido por [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]implementa propriedades anexadas como propriedades de dependência. Porque o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades anexadas são propriedades de dependência, elas podem ter metadados aplicado que podem ser usado pelo sistema de propriedades gerais para operações, como relatórios de características de layout. Para obter mais informações, consulte [visão geral de propriedades anexado](~/add/includes/ajax-current-ext-md.md).       Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade anexada com o nome da propriedade especificado, o tipo de propriedade, tipo de proprietário e metadados de propriedade."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência. Isso pode incluir o valor padrão, bem como outras características."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade anexada com o tipo de propriedade especificado, o tipo de proprietário, o metadados de propriedade e o retorno de chamada de validação de valor para a propriedade."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência. Isso pode incluir o valor padrão, bem como outras características."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a um retorno de chamada que deve executar qualquer validação personalizada do valor da propriedade de dependência além da validação de tipo comum."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência deve ser usado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo em sua classe. Esse identificador, em seguida, é usado para fazer referência à propriedade de dependência posteriormente, para operações como definindo seu valor por meio de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade anexada somente leitura, com o tipo de propriedade especificado, o tipo de proprietário e metadados de propriedade."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência deve ser usada para definir o valor de um campo somente leitura estático na classe, o que é usado para referenciar a propriedade de dependência mais tarde."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade anexada somente leitura, com o tipo de propriedade especificado, o tipo de proprietário, metadados de propriedade e um retorno de chamada de validação."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a um retorno de chamada criados pelo usuário que deve executar qualquer validação personalizada do valor da propriedade de dependência além da validação de tipo comum."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência deve ser usada para definir o valor de um campo somente leitura estático na classe, o que é usado para referenciar a propriedade de dependência."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade de dependência somente leitura, com o tipo de propriedade especificado, o tipo de proprietário e metadados de propriedade."
  remarks: "Esse método retorna o tipo <xref:System.Windows.DependencyPropertyKey>, enquanto que <xref:System.Windows.DependencyProperty.RegisterAttached%2A>retorna o tipo de <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normalmente, as chaves que representam as propriedades somente leitura não são feitas públicas, porque as chaves podem ser usadas para definir o valor de propriedade de dependência chamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> O design de classe afetará seus requisitos, mas geralmente é recomendável limitar o acesso e a visibilidade de qualquer <xref:System.Windows.DependencyPropertyKey>somente às partes do seu código que são necessárias para definir a propriedade de dependência como parte da lógica do aplicativo ou classe.</xref:System.Windows.DependencyPropertyKey> Também é recomendável que você exponha um identificador de propriedade de dependência para a propriedade de dependência somente leitura, expondo o valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>como um `public static readonly` campo em sua classe</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Propriedades de dependência somente leitura são um bastante cenário típico ambas as existentes no [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] e para cenários de personalização, porque outros [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] recursos podem exigir uma propriedade de dependência, mesmo se essa propriedade não se destina a ser configuráveis por chamadores. Você pode usar o valor da propriedade de dependência somente leitura como base para outras operações de sistema de propriedade que usam uma propriedade de dependência, como basear um <xref:System.Windows.Trigger>na propriedade de dependência em um estilo.</xref:System.Windows.Trigger>       Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência deve ser usada para definir o valor de um campo somente leitura estático na classe, o que é usado para referenciar a propriedade de dependência."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registra uma propriedade de dependência somente leitura, com o tipo de propriedade especificado, o tipo de proprietário, metadados de propriedade e um retorno de chamada de validação."
  remarks: "Esse método retorna o tipo <xref:System.Windows.DependencyPropertyKey>, enquanto que <xref:System.Windows.DependencyProperty.RegisterAttached%2A>retorna o tipo de <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normalmente, as chaves que representam as propriedades somente leitura não são feitas públicas, porque as chaves podem ser usadas para definir o valor de propriedade de dependência chamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> O design de classe afetará seus requisitos, mas geralmente é recomendável limitar o acesso e a visibilidade de qualquer <xref:System.Windows.DependencyPropertyKey>somente às partes do seu código que são necessárias para definir a propriedade de dependência como parte da lógica do aplicativo ou classe.</xref:System.Windows.DependencyPropertyKey> Também é recomendável que você exponha um identificador de propriedade de dependência para a propriedade de dependência somente leitura, expondo o valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>como um `public static readonly` campo em sua classe</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Propriedades de dependência somente leitura são um cenário bastante comum. Você pode usar o valor da propriedade de dependência somente leitura como base para outras operações de sistema de propriedade que usam uma propriedade de dependência, como basear um <xref:System.Windows.Trigger>na propriedade de dependência em um estilo.</xref:System.Windows.Trigger>       Para obter mais informações sobre o registro de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       A validação de uma propriedade de dependência somente leitura pode ser menos importante. O nível de acesso não público que você especificar para a chave reduz a probabilidade para entrada inválida arbitrária."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registrar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está registrando a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados de propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a um retorno de chamada criados pelo usuário que deve executar qualquer validação personalizada do valor da propriedade de dependência além da validação de tipo comum."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência deve ser usada para definir o valor de um campo somente leitura estático na classe, o que é usado para referenciar a propriedade de dependência mais tarde."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna a representação de cadeia de caracteres da propriedade de dependência."
  remarks: "Essa implementação retorna o <xref:System.Windows.DependencyProperty.Name%2A>o valor da propriedade.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "A representação de cadeia de caracteres da propriedade de dependência."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Especifica um valor estático que é usado pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema de propriedade em vez de <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para indicar que a propriedade existe, mas não tem o valor definido pelo sistema de propriedades."
  remarks: "UnsetValue é um valor de sentinela que é usado para cenários onde o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema de propriedade é não é possível determinar um solicitado <xref:System.Windows.DependencyProperty>valor.</xref:System.Windows.DependencyProperty> UnsetValue é usado em vez de `null`, pois `null` pode ser um valor de propriedade válido, bem como uma opção válida (e usados com frequência) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue nunca é retornada sem <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Quando você chama <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>em uma propriedade de dependência em um <xref:System.Windows.DependencyObject>instância, uma das opções a seguir se aplica: - uma propriedade de dependência tem um valor padrão estabelecido em metadados e esse valor será retornado.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Esse valor pode vir de <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Algum outro valor foi estabelecido pelo sistema de propriedade e o valor padrão não é mais relevante. Para obter detalhes, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md).       Definindo um <xref:System.Windows.PropertyMetadata.DefaultValue%2A>de UnsetValue não é especificamente permitido.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>Retorna UnsetValue quando a propriedade solicitada não foi definida localmente.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue tem um significado especial quando usado como o valor de retorno de <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> Para obter detalhes, consulte [retornos de chamada de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md).       Se você estiver associando a um banco de dados, observe que não é equivalente a UnsetValue <xref:System.DBNull.Value>, de maneira semelhante a como <xref:System.DBNull.Value>não é equivalente a um valor nulo true.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o retorno de chamada de validação do valor para a propriedade de dependência."
  remarks: "Essa propriedade conterá `null` para qualquer propriedade de dependência com nenhum retorno de chamada de validação registrado.       Validar o valor de retornos de chamada devem agir de forma estática: validação aplicada por meio de <xref:System.Windows.ValidateValueCallback>não é possível determinar se o valor fornecido é válido para qualquer instância específica.</xref:System.Windows.ValidateValueCallback> O retorno de chamada somente pode determinar se todos os objetos que possuem a propriedade de dependência devem ou não devem aceitar o valor fornecido como válido. Se você precisar executar a validação que depende de saber os valores de outras propriedades de dependência em uma instância específica, use um <xref:System.Windows.CoerceValueCallback>em vez disso.</xref:System.Windows.CoerceValueCallback> O <xref:System.Windows.CoerceValueCallback>é registrado como parte dos metadados de propriedade de dependência, em vez de diretamente dentro do identificador de propriedade de dependência.</xref:System.Windows.CoerceValueCallback> Para obter detalhes, consulte [retornos de chamada de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "O retorno de chamada de validação de valor para essa propriedade de dependência, conforme fornecido para o <code> validateValueCallback </code> parâmetro no registro de propriedade de dependência original."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
