### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "Encapsula um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo."
  remarks: "Aplicativo é uma classe que encapsula [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] funcionalidade específica do aplicativo, incluindo o seguinte:- **tempo de vida do aplicativo**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> </xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      - **Janela de escopo do aplicativo, a propriedade e o gerenciamento de recursos**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A> <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A> <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A> <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> </xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      - **Processamento de código de parâmetro de linha de comando e saída**: <xref:System.Windows.Application.Startup?displayProperty=fullName>, <xref:System.Windows.Application.Exit?displayProperty=fullName> <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       Aplicativo implementa o padrão de singleton para fornecer acesso compartilhado para sua janela, propriedade e os serviços de escopo do recurso. Consequentemente, apenas uma instância da classe de aplicativo pode ser criada por <xref:System.AppDomain>.</xref:System.AppDomain>       Você pode implementar um aplicativo usando a marcação, marcação e code-behind ou código. Se o aplicativo é implementado com marcação, se a marcação ou marcação e code-behind, o arquivo de marcação deve ser configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` item.      > [!NOTE] > Um aplicativo autônomo não requer um objeto de aplicativo; é possível implementar um personalizado `static` método de ponto de entrada (`Main`) que abre uma janela sem criar uma instância do aplicativo. No entanto, [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] requer um objeto de aplicativo."
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Application&quot;> </xref> classe."
  remarks: "Apenas uma instância do <xref:System.Windows.Application>classe pode ser criada por <xref:System.AppDomain>, para garantir o acesso compartilhado a um único conjunto de dados de janela, a propriedade e o recurso de escopo do aplicativo.</xref:System.AppDomain> </xref:System.Windows.Application> Consequentemente, o construtor padrão da <xref:System.Windows.Application>classe detecta se a instância que está sendo inicializada é a primeira instância de um <xref:System.AppDomain>; se não, é um <xref:System.InvalidOperationException>é gerada.</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       O <xref:System.Windows.Application>objeto atual <xref:System.AppDomain>é exposto estático <xref:System.Windows.Application.Current%2A>propriedade.</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Mais de uma instância do <xref href=&quot;System.Windows.Application&quot;> </xref> classe é criada por <xref href=&quot;System.AppDomain&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando um aplicativo se torna o aplicativo de primeiro plano."
  remarks: "Um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo que tem um ou mais janelas abertas é ativado (se torna o aplicativo de primeiro plano) quando uma das janelas é ativada pela primeira vez desde que o aplicativo foi iniciado ou quando uma do windows está ativada, enquanto o aplicativo está inativo: especificamente, a ativação ocorre quando:-um aplicativo abre a primeira janela.      -Um usuário alterna para o aplicativo usando ALT + TAB ou usando o Gerenciador de tarefas.      -Um usuário clica no botão de barra de tarefas para uma das janelas em um aplicativo.       Aplicativos que precisam detectar quando elas ativaram podem manipular o evento ativado.       Depois que um aplicativo é ativado pela primeira vez, pode ser desativado e reativado muitas vezes durante seu ciclo de vida. Se o estado ou o comportamento de um aplicativo depende de seu estado de ativação, pode lidar com ativado e o <xref:System.Windows.Application.Deactivated>estado de eventos para determinar qual ativação é in.</xref:System.Windows.Application.Deactivated>       Depois que um aplicativo se torna ativo, ativado não ocorrerá novamente até que o aplicativo é desativado, independentemente de quantas janelas dentro de um aplicativo são ativadas enquanto o aplicativo estiver ativo.       Ativado não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o <xref href=&quot;System.Windows.Application&quot;> </xref> objeto atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  remarks: "<xref:System.Windows.Application>é uma por-<xref:System.AppDomain> tipo singleton que implementa a propriedade Current para fornecer acesso compartilhado para a <xref:System.Windows.Application>instância atual <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Application> </xref:System.AppDomain></xref:System.Windows.Application> Esse design garante estado gerenciado pelo <xref:System.Windows.Application>, incluindo recursos compartilhados e estado, está disponível a partir de um local compartilhado, único.</xref:System.Windows.Application>       Essa propriedade é thread-safe e está disponível de qualquer thread."
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "O <xref href=&quot;System.Windows.Application&quot;> </xref> objeto atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando um aplicativo deixa de ser o aplicativo de primeiro plano."
  remarks: "Um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo que tem um ou mais janelas abertas desativa (parar de ser o aplicativo de primeiro plano) quando um usuário faz o seguinte:-alterna para outro aplicativo usando ALT + TAB ou usando o Gerenciador de tarefas.      -Clica no botão de barra de tarefas para uma janela em outro aplicativo.       Aplicativos que precisam detectar desativação podem manipular o evento de desativado.       Depois que um aplicativo é ativado pela primeira vez, pode ser desativado e reativado muitas vezes durante seu ciclo de vida. Se o estado ou o comportamento de um aplicativo depende de seu estado de ativação, pode lidar com ambos os desativado e <xref:System.Windows.Application.Activated>eventos para determinar qual estado é in.</xref:System.Windows.Application.Activated>       Desativado não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma exceção é lançada por um aplicativo, mas não tratada."
  remarks: "Por padrão, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] captura exceções sem tratamento, notifica os usuários da exceção de uma caixa de diálogo (do qual eles podem relatar a exceção) e desliga automaticamente um aplicativo.       No entanto, se um aplicativo precisa executar exceções sem tratamento personalizado de processamento de um local centralizado, você deve tratar DispatcherUnhandledException.       DispatcherUnhandledException é gerado por um <xref:System.Windows.Application>para cada exceção sem tratamento por código em execução no thread da interface do usuário principal.</xref:System.Windows.Application>       Se uma exceção não é tratada no plano de fundo [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] thread (um thread com seu próprio <xref:System.Windows.Threading.Dispatcher>) ou um thread de trabalho em segundo plano (um segmento sem um <xref:System.Windows.Threading.Dispatcher>), a exceção não será refletida no principal [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> Consequentemente, DispatcherUnhandledException não será gerado. Nessas circunstâncias, você precisará escrever código para fazer o seguinte: 1.  Lidar com exceções no thread em segundo plano.      2.  Essas exceções para o principal de expedição [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.      3.  Relançá-los no principal [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] segmento sem tratamento-los para permitir DispatcherUnhandledException a ser gerado.       Para obter mais informações, consulte o [modelo de Threading](~/add/includes/ajax-current-ext-md.md) visão geral.       O manipulador de eventos DispatcherUnhandledException é passado um <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>argumento que contém informações contextuais sobre a exceção, incluindo:-a exceção (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      -A <xref:System.Windows.Threading.Dispatcher>da qual ele se originou (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       Você pode usar essas informações para determinar se uma exceção é recuperável ou não. Uma exceção recuperável pode ser um <xref:System.IO.FileNotFoundException>, por exemplo, enquanto uma exceção irrecuperável pode ser um <xref:System.StackOverflowException>, por exemplo.</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       Quando você processar uma exceção sem tratamento do DispatcherUnhandledException, e você não deseja [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] para continuar o processamento, você precisará definir o <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>propriedade `true`.</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       Ao contrário de outros eventos que <xref:System.Windows.Application>gera, DispatcherUnhandledException não tem uma implementação de virtual protegida correspondente (OnDispatcherUnhandledException).</xref:System.Windows.Application> Consequentemente, classes que derivam <xref:System.Windows.Application>sempre deve registrar um manipulador de eventos com DispatcherUnhandledException para processar exceções não manipuladas.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre imediatamente antes de um aplicativo é desligado e não pode ser cancelado."
  remarks: "Um aplicativo pode desligar por qualquer uma das seguintes razões: - o <xref:System.Windows.Application.Shutdown%2A>método de <xref:System.Windows.Application>objeto é chamado, explicitamente ou conforme determinado pelo <xref:System.Windows.Application.ShutdownMode%2A>propriedade.</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -O usuário encerra a sessão por logoff ou desligamento.       Você pode detectar quando o encerramento do aplicativo ocorre ao manipular o evento de saída e executar qualquer processamento adicional conforme necessário.       Você também pode lidar com a saída para verificar ou alterar o código de saída do aplicativo quando você não precisa chamar <xref:System.Windows.Application.Shutdown%2A>explicitamente.</xref:System.Windows.Application.Shutdown%2A> O código de saída é exposto a <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>propriedade o <xref:System.Windows.ExitEventArgs>argumento que é passado para o manipulador de eventos de saída.</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Quando o aplicativo é interrompido, o código de saída é passado para o sistema operacional para processamento posterior.       Se seu aplicativo lida com o <xref:System.Windows.Application.SessionEnding>eventos e subsequentemente cancela a ele, a saída não será gerado e o aplicativo continua sendo executado de acordo com o modo de desligamento.</xref:System.Windows.Application.SessionEnding>       O código de saída pode ser definido de um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)], embora o valor será ignorado.       Para [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)], saída é gerada nas seguintes circunstâncias: - um [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] é navegado para fora.      -Em [!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)], quando a guia que está hospedando o [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] está fechado.      -Quando o navegador for fechado.       Em todos os casos, o valor de <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>propriedade será ignorada.</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] recursos, como um <xref href=&quot;System.Windows.Style&quot;> </xref> ou <xref href=&quot;System.Windows.Media.Brush&quot;> </xref>, com a chave especificada e gera uma exceção se o recurso solicitado não foi encontrado (consulte [recursos XAML](~/add/includes/ajax-current-ext-md.md))."
  remarks: "FindResource procurará primeiro em recursos de escopo de aplicativo para o recurso especificado. Recursos de escopo de aplicativo são gerenciados pelo <xref:System.Windows.Application>e são expostas a partir do <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Se o recurso especificado não foi encontrado no conjunto de recursos de escopo do aplicativo, FindResource seguida pesquisará os recursos do sistema. Recursos do sistema são recursos de shell definidos pelo usuário e incluem cores, fontes e configurações de shell. Esses são expostos a partir de <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters>tipos, respectivamente, como propriedades estáticas.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Para usar FindResource para adquiri-los, esses tipos também expõem propriedades de chave de recurso que são projetadas para ser passado para FindResource; Por exemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Como FindResource retorna um objeto, você deve converter o valor retornado para o tipo apropriado, se o recurso foi encontrado.      > [!IMPORTANT] > Se você chamar esse método para uma chave que não pode ser encontrada, uma exceção será lançada. Se você não deseja tratar exceções resultantes da chamada FindResource, chame <xref:System.Windows.Application.TryFindResource%2A> <xref:System.Windows.Application.TryFindResource%2A>retorna um `null` referência quando um recurso solicitado não foi encontrado e não gerará uma exceção.</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       Esse método é thread-safe e pode ser chamado de qualquer thread."
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O nome do recurso para localizar."
    return:
      type: System.Object
      description: "O objeto do recurso solicitado. Se o recurso solicitado não for encontrado, um <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref> é gerada."
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "O recurso não pode ser encontrado."
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando um navegador no aplicativo começa a navegação até um fragmento de conteúdo, navegação ocorre imediatamente se o fragmento desejado estiver no conteúdo atual, ou após a fonte [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] conteúdo foi carregado se o fragmento desejado estiver em outro conteúdo."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna um fluxo de recursos para um arquivo de dados de conteúdo que está localizado no local especificado <xref:System.Uri>(consulte [recursos de aplicativo do WPF, conteúdo e arquivos de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é thread-safe."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "Relativa <xref:System.Uri>que mapeia para um recurso flexível.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Um <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contém um arquivo de dados de conteúdo que está localizado em <xref:System.Uri>.</xref:System.Uri> especificado Se não for encontrado um recurso flexível, null será retornado."
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>que é passado para GetContentStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>que é passado para GetContentStream é um absoluto <xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Recupera um cookie para o local especificado por <xref:System.Uri>.</xref:System.Uri>"
  remarks: "GetCookie recupera um cookie para o <xref:System.Uri>.</xref:System.Uri> especificado Se o cookie não pode ser recuperado, uma <xref:System.ComponentModel.Win32Exception>é gerada.</xref:System.ComponentModel.Win32Exception> Você precisa escrever o código para analisar a cadeia de caracteres do cookie em uma lista de pares nome/valor.       Para obter uma visão geral de cookies em [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], consulte [visão geral de navegação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "O <xref:System.Uri>que especifica o local para o qual um cookie foi criado.</xref:System.Uri>"
    return:
      type: System.String
      description: "Um <xref:System.String>valor, se o cookie existe; caso contrário, um <xref href=&quot;System.ComponentModel.Win32Exception&quot;> </xref> é gerada.</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Um [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] erro é gerado pelo <xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;> </xref> função (chamada de GetCookie) se houver um problema ao tentar recuperar o cookie especificado."
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna um fluxo de recursos para um arquivo de dados do site de origem que está localizado no local especificado <xref:System.Uri>(consulte [recursos de aplicativo do WPF, conteúdo e arquivos de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é thread-safe."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "O <xref:System.Uri>que mapeia para um recurso flexível no site de origem.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Um <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contém um fluxo de recursos para um arquivo de dados do site de origem que está localizado em <xref:System.Uri>.</xref:System.Uri> especificado Se o recurso flexível não for encontrado, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> é retornado."
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>que é passado para GetRemoteStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>que é passado para GetRemoteStream é não relativo ou absoluto, mas não no `pack://siteoforigin:,,,/` formulário.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retorna um fluxo de recursos para um arquivo de dados do recurso que está localizado no local especificado <xref:System.Uri>(consulte [recursos de aplicativo do WPF, conteúdo e arquivos de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é thread-safe."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "O <xref:System.Uri>que mapeia para um recurso inserido.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Um <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contém um fluxo de recursos para o arquivo de dados do recurso que está localizado em <xref:System.Uri>.</xref:System.Uri> especificado"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>que é passado para GetResourceStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>que é passado para GetResourceStream é não relativo ou absoluto, mas não no `pack://application:,,,/` formulário.</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <xref:System.Uri>que é passado para GetResourceStream não pode ser encontrado.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o conteúdo que foi navegado por um navegador no aplicativo foi carregado, analisado e começou a renderização."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>      > [!NOTE] > Escutar eventos no conteúdo navegado, como o <xref:System.Windows.FrameworkElement.Loaded>evento em <xref:System.Windows.Controls.Page>antes de acessar propriedades do conteúdo navegado.</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Carrega um [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] arquivo está localizado no local especificado [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]e o converte em uma instância do objeto que é especificado pelo elemento raiz da [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] arquivo."
  remarks: "Você deverá converter explicitamente o valor de retorno para o mesmo tipo que o elemento raiz da [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] arquivo.       O [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] arquivo pode ser um arquivo de código do aplicativo (configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] item de página) ou um arquivo de dados do aplicativo (um arquivo de recurso, o arquivo de conteúdo ou o site de origem de arquivo, consulte [recursos de aplicativo do WPF, conteúdo e arquivos de dados](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] > Esse método não é thread-safe."
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "Um <xref:System.Uri>que mapeia para um parente [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] arquivo.</xref:System.Uri>"
    return:
      type: System.Object
      description: "Uma instância do elemento raiz especificado pelo arquivo XAML é carregado."
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>é nulo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "O arquivo não é um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] arquivo."
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Carrega um [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] arquivo está localizado no local especificado [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] e o converte em uma instância do objeto que é especificado pelo elemento raiz da [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] arquivo."
  remarks: "O [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] arquivo pode ser um arquivo de código do aplicativo (configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] item de página) ou um arquivo de dados do aplicativo (um arquivo de recurso, o arquivo de conteúdo ou o site de origem de arquivo, consulte [recursos de aplicativo do WPF, conteúdo e arquivos de dados](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] > Esse método não é thread-safe."
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "Um objeto do mesmo tipo que o elemento raiz da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] arquivo."
    - id: resourceLocator
      type: System.Uri
      description: "Um <xref:System.Uri>que mapeia para um parente [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] arquivo.</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>é nulo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>é de um tipo que não coincide com o elemento raiz da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] arquivo."
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a janela principal do aplicativo."
  remarks: "MainWindow é automaticamente definido com uma referência para o primeiro <xref:System.Windows.Window>objeto a ser instanciado em <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Window>       Você pode especificar uma janela principal diferente definindo MainWindow atribuir outro <xref:System.Windows.Application.Windows%2A>objeto à propriedade MainWindow.</xref:System.Windows.Application.Windows%2A>       Se o <xref:System.Windows.Application.ShutdownMode%2A>propriedade o <xref:System.Windows.Application>objeto é definido como <xref:System.Windows.ShutdownMode>, fechar a janela principal faz com que o aplicativo seja desligado.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       É possível definir a propriedade MainWindow de [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)], se a janela principal do aplicativo não é a janela que é produzida, definindo o <xref:System.Windows.Application.StartupUri%2A>propriedade [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].</xref:System.Windows.Application.StartupUri%2A> Duas limitações do [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] abordagem são:-você pode especificar um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-somente <xref:System.Windows.Window>ou um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-somente <xref:System.Windows.Navigation.NavigationWindow>como a janela principal.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -Você deve definir o <xref:System.Windows.UIElement.Visibility%2A>propriedade da janela que você especificar, caso contrário, ele não será mostrado.</xref:System.Windows.UIElement.Visibility%2A>       A referência ao primeiro <xref:System.Windows.Window>objeto a ser instanciado também é adicionado como o primeiro item para o <xref:System.Windows.Application.Windows%2A>coleção.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Se MainWindow subsequentemente é definida com uma referência a outro <xref:System.Windows.Window>, a posição do item com a referência para a janela principal será alterado, enquanto a ordem dos itens em <xref:System.Windows.Application.Windows%2A>permanece o mesmo.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Consequentemente, sempre use MainWindow para referir-se a janela principal, em vez do primeiro item na <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A>      > [!NOTE] > Se a janela principal é um <xref:System.Windows.Navigation.NavigationWindow>, e você precisa de acesso específico para <xref:System.Windows.Navigation.NavigationWindow>membros, você precisará converter o valor da MainWindow para <xref:System.Windows.Navigation.NavigationWindow>.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow>   >> Essa propriedade está disponível somente do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "Um <xref href=&quot;System.Windows.Window&quot;> </xref> que é designada como a janela principal do aplicativo."
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindow é definido por um aplicativo que está hospedado em um navegador, como um [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o conteúdo que está sendo navegado por um navegador no aplicativo foi encontrado, embora ele pode não ter concluído o carregamento."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma nova navegação é solicitada por um navegador no aplicativo."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando ocorre um erro enquanto estiver navegando por um navegador no aplicativo para o conteúdo solicitado."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre periodicamente durante um download que está sendo gerenciado por um navegador no aplicativo para fornecer informações de andamento de navegação."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o <xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;> </xref> é chamado de método de um navegador no aplicativo, ou quando uma nova navegação é solicitada por um navegador, enquanto uma navegação atual está em andamento."
  remarks: "Um navegador é um <xref:System.Windows.Navigation.NavigationWindow>ou <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Activated&quot;> </xref> eventos."
  remarks: "OnActivated gera o <xref:System.Windows.Application.Activated>evento.</xref:System.Windows.Application.Activated>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnActivated.</xref:System.Windows.Application> O método substituído deve chamar OnActivated na classe base se <xref:System.Windows.Application.Activated>precisa ser gerado.</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Um <xref:System.EventArgs>que contém os dados de evento.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Deactivated&quot;> </xref> eventos."
  remarks: "OnDeactivated gera o <xref:System.Windows.Application.Deactivated>evento.</xref:System.Windows.Application.Deactivated>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnDeactivated.</xref:System.Windows.Application> O método substituído deve chamar OnDeactivated na classe base se <xref:System.Windows.Application.Deactivated>precisa ser gerado.</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Um <xref:System.EventArgs>que contém os dados de evento.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Exit&quot;> </xref> eventos."
  remarks: "OnExit gera o <xref:System.Windows.Application.Exit>evento.</xref:System.Windows.Application.Exit>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir o método OnExit.</xref:System.Windows.Application> O método substituído deve chamar OnExit na classe base se <xref:System.Windows.Application.Exit>precisa ser gerado.</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "Um <xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.FragmentNavigation&quot;> </xref> eventos."
  remarks: "OnFragmentNavigation gera o <xref:System.Windows.Application.FragmentNavigation>evento.</xref:System.Windows.Application.FragmentNavigation>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnFragmentNavigation.</xref:System.Windows.Application> O método substituído deve chamar OnFragmentNavigation na classe base se <xref:System.Windows.Application.FragmentNavigation>precisa ser gerado.</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.LoadCompleted&quot;> </xref> eventos."
  remarks: "OnLoadCompleted gera o <xref:System.Windows.Application.LoadCompleted>evento.</xref:System.Windows.Application.LoadCompleted>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnLoadCompleted.</xref:System.Windows.Application> O método substituído deve chamar OnLoadCompleted na classe base se <xref:System.Windows.Application.LoadCompleted>precisa ser gerado.</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Navigated&quot;> </xref> eventos."
  remarks: "OnNavigated gera o <xref:System.Windows.Application.Navigated>evento.</xref:System.Windows.Application.Navigated>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnNavigated.</xref:System.Windows.Application> O método substituído deve chamar OnNavigated na classe base se <xref:System.Windows.Application.Navigated>precisa ser gerado.</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Navigating&quot;> </xref> eventos."
  remarks: "OnNavigating gera o <xref:System.Windows.Application.Navigating>evento.</xref:System.Windows.Application.Navigating>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnNavigating.</xref:System.Windows.Application> O método substituído deve chamar OnNavigating na classe base se <xref:System.Windows.Application.Navigating>precisa ser gerado.</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationFailed&quot;> </xref> eventos."
  remarks: "OnNavigationFailed gera o <xref:System.Windows.Application.NavigationFailed>evento.</xref:System.Windows.Application.NavigationFailed>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnNavigationFailed.</xref:System.Windows.Application> O método substituído deve chamar OnNavigationFailed na classe base se <xref:System.Windows.Application.NavigationFailed>precisa ser gerado.</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationProgress&quot;> </xref> eventos."
  remarks: "OnNavigationProgress gera o <xref:System.Windows.Application.NavigationProgress>evento.</xref:System.Windows.Application.NavigationProgress>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnNavigationProgress.</xref:System.Windows.Application> O método substituído deve chamar explicitamente OnNavigationProgress na classe base se <xref:System.Windows.Application.NavigationProgress>precisa ser gerado.</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationStopped&quot;> </xref> eventos."
  remarks: "OnNavigationStopped gera o <xref:System.Windows.Application.NavigationStopped>evento.</xref:System.Windows.Application.NavigationStopped>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnNavigationStopped.</xref:System.Windows.Application> O método substituído deve chamar OnNavigationStopped na classe base se <xref:System.Windows.Application.NavigationStopped>precisa ser gerado.</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Um <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.SessionEnding&quot;> </xref> eventos."
  remarks: "OnSessionEnding gera o <xref:System.Windows.Application.SessionEnding>evento.</xref:System.Windows.Application.SessionEnding>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnSessionEnding.</xref:System.Windows.Application> O método substituído deve chamar OnSessionEnding na classe base se <xref:System.Windows.Application.SessionEnding>precisa ser gerado.</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "Um <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Startup&quot;> </xref> eventos."
  remarks: "OnStartup gera o <xref:System.Windows.Application.Startup>evento.</xref:System.Windows.Application.Startup>       Um tipo que deriva de <xref:System.Windows.Application>podem substituir OnStartup.</xref:System.Windows.Application> O método substituído deve chamar OnStartup na classe base, se o <xref:System.Windows.Application.Startup>evento precisa ser gerado.</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "Um <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref> que contém os dados de evento."
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém uma coleção de propriedades de escopo do aplicativo."
  remarks: "<xref:System.Windows.Application>expõe um dicionário por meio de propriedades que você pode usar para armazenar as propriedades de escopo do aplicativo.</xref:System.Windows.Application> Isso permite que você compartilhar o estado entre todo o código em um <xref:System.AppDomain>uma forma thread-safe, sem a necessidade de escrever seu próprio código de estado.</xref:System.AppDomain>       Propriedades armazenadas nas propriedades devem ser convertidas para o tipo apropriado retornado.       Propriedade TheProperties é thread-safe e está disponível de qualquer thread."
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "Um <xref:System.Collections.IDictionary>que contém as propriedades de escopo de aplicativo.</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o <xref:System.Reflection.Assembly>que fornece o pacote de [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] para recursos em um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] application.</xref:System.Reflection.Assembly>"
  remarks: "Por padrão, [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] recursos são resolvidos em tempo de execução em relação ao assembly de entrada, que é identificado pelo valor retornado do <xref:System.Reflection.Assembly.GetEntryAssembly%2A>método.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       O assembly de entrada é o assembly que é retornado por <xref:System.Reflection.Assembly.GetEntryAssembly%2A>e pode ser o seguinte:-o assembly executável no domínio de aplicativo padrão.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      -O primeiro conjunto a ser executada chamando <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       Nos casos a seguir, no entanto, um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assembly não é possível obter uma referência para o assembly de entrada: - um não gerenciado hosts de aplicativo (nativa) a [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assembly.      -A hosts de aplicativo gerenciado a [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assembly carregando-o em um novo domínio de aplicativo usando um método diferente de <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       Em ambos os casos, <xref:System.Reflection.Assembly.GetEntryAssembly%2A>retorna `null`e o [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] recursos do assembly não podem ser resolvidos.</xref:System.Reflection.Assembly.GetEntryAssembly%2A> Nesses casos, ResourceAssembly pode ser definida, apenas uma vez, com uma referência ao assembly que deve ser usado para resolver os recursos.       ResourceAssembly só pode ser definida uma vez porque é improvável que o conjunto de recursos será alterado após o [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assembly está carregado.      > [!NOTE] > ResourceAssembly não pode ser definida quando um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assembly pode descobrir o assembly de entrada — ou seja, quando <xref:System.Reflection.Assembly.GetEntryAssembly%2A>retorna uma referência a um assembly em vez de `null`.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       Essa propriedade é thread-safe e está disponível de qualquer thread.       ResourceAssembly é introduzido no .NET Framework versão 3.5.  Para obter mais informações, consulte [versões e dependências](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "Uma referência para o <xref:System.Reflection.Assembly>que fornece o pacote de [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] para recursos em um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] application.</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicativo tem um assembly de entrada ou ResourceAssembly já foi definido."
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma coleção de recursos de escopo do aplicativo, como pincéis e estilos."
  remarks: "A propriedade de recursos pode ser usada para compartilhar recursos entre o windows e os elementos de um aplicativo. Além disso, a propriedade de recursos está incluída no caminho de pesquisa de recurso, que é atravessado na seguinte ordem: 1.  Elementos de 2.  3 do Windows.  4 de recursos.  Sistema Consequentemente, [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] elementos podem associar aos recursos de escopo do aplicativo. Além disso, se alterar de recursos, o sistema de recurso garante que elemento propriedades que estão associadas a esses recursos são atualizadas automaticamente para refletir a alteração.       Recursos de escopo do aplicativo fornecem uma maneira simples para dar suporte a um tema consistente em seu aplicativo. Você pode criar facilmente um tema em [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] usando o `Application.Resources` marca. No entanto, se seu aplicativo dá suporte a vários temas, que podem conter um grande número de elementos de tema, talvez seja mais fácil de gerenciá-los usando um <xref:System.Windows.ResourceDictionary>instância para cada tema.</xref:System.Windows.ResourceDictionary> Dessa forma, um novo tema pode ser aplicado, definindo a propriedade de recursos para o <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> apropriado       Há duas considerações a fazer ao usar os recursos. Primeiro, o dicionário *chave* é um objeto, então você precisa utilizar exatamente a mesma instância de objeto quando estiver definindo e obter um valor de propriedade (Observe que a chave diferencia maiusculas de minúsculas quando usando uma cadeia de caracteres). Segundo, o dicionário *valor* é um objeto, então você precisará converter o valor para o tipo desejado ao obter um valor de propriedade.       Recursos é thread-safe e está disponíveis de qualquer thread."
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "Um <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref> objeto que contém zero ou mais recursos de escopo do aplicativo."
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo."
  remarks: "<xref:System.Windows.Application.Run%2A>é chamado para iniciar um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicativo.</xref:System.Windows.Application.Run%2A> Se você definir o <xref:System.Windows.Application>usando code-behind e marcação ou marcação, <xref:System.Windows.Application.Run%2A>será chamado implicitamente.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> No entanto, se você definir o <xref:System.Windows.Application>usando o código, você precisa chamar explicitamente <xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application>       Quando <xref:System.Windows.Application.Run%2A>é chamado, <xref:System.Windows.Application>anexa um novo <xref:System.Windows.Threading.Dispatcher>de instância para o [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> Em seguida, o <xref:System.Windows.Threading.Dispatcher>do objeto <xref:System.Windows.Threading.Dispatcher.Run%2A>método é chamado, o que inicia uma bomba de mensagem para processar mensagens do windows.</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> Por fim, o <xref:System.Windows.Threading.Dispatcher>objeto chamadas a <xref:System.Windows.Application>do objeto a <xref:System.Windows.Application.OnStartup%2A>método para gerar o <xref:System.Windows.Application.Startup>evento.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> Consequentemente, o modelo de execução do aplicativo tiver sido estabelecido no momento em que você os manipula <xref:System.Windows.Application.Startup>, no ponto em que o aplicativo é considerado para estar em execução.</xref:System.Windows.Application.Startup>       Um aplicativo é interrompido quando <xref:System.Windows.Application.Shutdown%2A>é chamado; o valor da <xref:System.Windows.Application.ShutdownMode%2A>propriedade determina quando <xref:System.Windows.Application.Shutdown%2A>é chamado e se ele ocorre automaticamente ou você precisa explicitamente chamar proprietário.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>pode ser chamado somente do thread que cria o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> Além disso, <xref:System.Windows.Application.Run%2A>não pode ser chamado de um [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "O <xref:System.Int32>código de saída do aplicativo que é retornado para o sistema operacional quando o aplicativo é desligado.</xref:System.Int32> Por padrão, o valor de código de saída é 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Execução é chamada de um aplicativo hospedado em navegador (por exemplo, um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])."
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo e abre a janela especificada."
  remarks: "Essa sobrecarga estende o <xref:System.Windows.Application.Run%2A>método para abrir a janela especificada após o início de um aplicativo em execução.</xref:System.Windows.Application.Run%2A>       Se você definir um código <xref:System.Windows.Application>que abre uma janela quando ele inicia a execução, você chamar explicitamente a execução.</xref:System.Windows.Application>       Se você criar seu <xref:System.Windows.Application>usando marcação, ou marcação e code-behind, você pode automaticamente abrir uma janela durante usando qualquer uma das seguintes técnicas: - declarativamente, definindo <xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application>      -Programaticamente, manipulando <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup>"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "Um <xref href=&quot;System.Windows.Window&quot;> </xref> que é aberto automaticamente quando um aplicativo é iniciado."
    return:
      type: System.Int32
      description: "O <xref:System.Int32>código de saída do aplicativo que é retornado para o sistema operacional quando o aplicativo é desligado.</xref:System.Int32> Por padrão, o valor de código de saída é 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>é chamado de um aplicativo hospedado em navegador (por exemplo, um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]).</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o usuário termina o [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] sessão por logoff ou desligar o sistema operacional."
  remarks: "Por padrão, um aplicativo é desligado quando o [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] término da sessão, que ocorre quando um usuário fizer logoff ou desligado. Quando isso acontece, [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)] solicita que cada aplicativo aberto para desligar. No entanto, é possível que um aplicativo pode não estar pronto para ser desligado quando isso ocorre. Por exemplo, um aplicativo pode ter dados em um estado inconsistente ou no meio de uma operação demorada. Nessas situações, ele pode ser desejável para impedir que a sessão final e pode ser mais interessante para permitir que os usuários a opção de decidir se deseja ou não permitir que a sessão terminar.       Você pode detectar quando uma sessão termina ao manipular o evento SessionEnding. Se um aplicativo precisar impedir que a sessão final, o <xref:System.Windows.SessionEndingCancelEventArgs>argumento que é passado para o manipulador de eventos expõe o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>que você definir para `true` (o valor padrão é `false`).</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       Se SessionEnding é sem tratamento ou é tratado sem terem sido canceladas, <xref:System.Windows.Application.Shutdown%2A>é chamado e o <xref:System.Windows.Application.Exit>é gerado.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Para obter mais informações sobre por que a sessão está terminando, um aplicativo pode inspecionar <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, que é um do <xref:System.Windows.ReasonSessionEnding>valores (<xref:System.Windows.ReasonSessionEnding> e <xref:System.Windows.ReasonSessionEnding>).</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       SessionEnding não é gerado por aplicativos de console.       SessionEnding é gerado apenas no thread que cria o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>       SessionEnding não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Cria um cookie para o local especificado por <xref:System.Uri>.</xref:System.Uri>"
  remarks: "Um cookie é uma parte arbitrária de dados que podem ser armazenados por um aplicativo no computador cliente durante as sessões do aplicativo (cookies de sessão) ou nas sessões do aplicativo (cookies persistentes). Você pode criar dois tipos de cookies chamando SetCookie.       Dados do cookie normalmente assumem a forma de um par nome/valor no seguinte formato: `Name=Value` você passar uma cadeia de caracteres desse formato para SetCookie, juntamente com o <xref:System.Uri>do local para o qual o cookie deve ser definido (normalmente, o domínio de aplicativo).</xref:System.Uri>       Se um cookie é um cookie de sessão ou um cookie persistente depende se a cadeia de caracteres de cookie que você passa para SetCookie inclui uma data de expiração. A cadeia de caracteres para um cookie de sessão não inclui uma data de expiração. A cadeia de caracteres para um cookie persistente faz e deve estar no seguinte formato: `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT` cookies persistentes são armazenados no atual [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] pasta de arquivos temporários da Internet da instalação até expirarem, caso em que eles são excluídos. Você pode excluir um cookie persistente do seu aplicativo, definindo sua data de expiração para um valor de data/hora no passado.       Para obter uma visão geral de cookies em [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], consulte [visão geral de navegação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "O <xref:System.Uri>que especifica o local para o qual o cookie deve ser criado.</xref:System.Uri>"
    - id: value
      type: System.String
      description: "O <xref:System.String>que contém os dados do cookie.</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Um [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] erro é gerado pelo <xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;> </xref> função (chamada de SetCookie) se houver um problema ao tentar criar o cookie especificado."
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Um aplicativo é desligado."
  remarks: "Quando chamado de desligamento, um aplicativo é interrompido. Você pode manipular o <xref:System.Windows.Application.Exit>evento para detectar quando um aplicativo está prestes a parar a execução, para executar qualquer processamento apropriado.</xref:System.Windows.Application.Exit>       Desligamento é chamado implicitamente pelo [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] nas seguintes situações: - quando <xref:System.Windows.Application.ShutdownMode%2A>é definida como <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -Quando o <xref:System.Windows.Application.ShutdownMode%2A>é definida como <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -Quando um usuário encerra uma sessão e o <xref:System.Windows.Application.SessionEnding>evento é sem tratamento, ou tratado sem cancelamento.</xref:System.Windows.Application.SessionEnding>       Chamar explicitamente o desligamento faz com que um aplicativo desligar, independentemente do <xref:System.Windows.Application.ShutdownMode%2A>configuração.</xref:System.Windows.Application.ShutdownMode%2A> No entanto, se <xref:System.Windows.Application.ShutdownMode%2A>for definido como <xref:System.Windows.ShutdownMode>, você deve chamar o desligamento para encerrar um aplicativo.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      > [!IMPORTANT] > Desligamento quando for chamado, o aplicativo será desligado independentemente se o <xref:System.Windows.Window.Closing>eventos de todas as janelas abertas é cancelado.</xref:System.Windows.Window.Closing>       Esse método pode ser chamado somente do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Um aplicativo que retorna o código de saída especificado para o sistema operacional será desligado."
  remarks: "Você pode manipular o <xref:System.Windows.Application.Exit>evento para definir um código de saída.</xref:System.Windows.Application.Exit> No entanto, se você chamar explicitamente <xref:System.Windows.Application.Shutdown%2A>, e você manipular <xref:System.Windows.Application.Exit>somente para definir um código de saída, você pode chamar desligamento em vez disso.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Esse método pode ser chamado somente do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "Um código de saída inteiro para um aplicativo. O código de saída padrão é 0."
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a condição que faz com que o <xref:System.Windows.Application.Shutdown*>método a ser chamado.</xref:System.Windows.Application.Shutdown*>"
  remarks: "Aplicativos de interromper a execução apenas quando o <xref:System.Windows.Application.Shutdown%2A>é chamado de método do aplicativo.</xref:System.Windows.Application.Shutdown%2A> Desligar pode ocorrer implicitamente ou explicitamente, conforme especificado pelo valor da propriedade ShutdownMode.       Se você definir ShutdownMode como <xref:System.Windows.ShutdownMode>, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] chama implicitamente <xref:System.Windows.Application.Shutdown%2A>quando a última janela em um aplicativo for fechado, mesmo se todas as janelas atualmente instanciadas são definidas como a janela principal (consulte <xref:System.Windows.Application.MainWindow%2A>).</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       Um ShutdownMode de <xref:System.Windows.ShutdownMode>faz com que [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]implicitamente chamar <xref:System.Windows.Application.Shutdown%2A>quando o <xref:System.Windows.Application.MainWindow%2A>fecha, mesmo que outras janelas estão abertas no momento.</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       O tempo de vida de alguns aplicativos não pode ser quando a janela principal ou a última janela for fechada, ou não ser dependente no windows em todos os dependente. Para esses cenários, você precisa definir a propriedade ShutdownMode como <xref:System.Windows.ShutdownMode>, que requer uma explícita <xref:System.Windows.Application.Shutdown%2A>chamada de método para interromper o aplicativo.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> Caso contrário, o aplicativo continua em execução em segundo plano.       ShutdownMode pode ser configurado de forma declarativa de [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ou por meio de programação de código.       Essa propriedade está disponível somente do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "Um <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref> valor de enumeração. O valor padrão é <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>."
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o <xref:System.Windows.Application.Run*>método o <xref href=&quot;System.Windows.Application&quot;> </xref> objeto é chamado.</xref:System.Windows.Application.Run*>"
  remarks: "Um típico [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicativo pode executar uma variedade de tarefas de inicialização quando ele é iniciado, incluindo:-processar parâmetros de linha de comando.      -Abrindo a janela principal.      -Inicializar recursos de escopo do aplicativo.      -Inicializar propriedades de escopo do aplicativo.       Você pode especificar declarativamente a janela principal e os recursos de escopo de aplicativo usando [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] (<xref:System.Windows.Application.StartupUri%2A> e <xref:System.Windows.Application.Resources%2A>, respectivamente).</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> Às vezes, no entanto, os recursos ou a janela principal do seu aplicativo só pode ser determinada por meio de programação em tempo de execução. Além disso, as propriedades de escopo do aplicativo e os parâmetros de linha de comando podem somente ser usados por programação. Inicialização através de programação que pode ser executada ao tratar o evento de inicialização, incluindo o seguinte: - adquirir e processar parâmetros de linha de comando, que estão disponíveis no <xref:System.Windows.StartupEventArgs.Args%2A>propriedade o <xref:System.Windows.StartupEventArgs>classe que é passado para o manipulador de eventos de inicialização.</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -Inicializar os recursos de escopo de aplicativo usando o <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A>      -Inicializar as propriedades de escopo de aplicativo usando o <xref:System.Windows.Application.Properties%2A>propriedade.</xref:System.Windows.Application.Properties%2A>      -Criar uma instância e Mostrar janelas uma (ou mais).      > [!NOTE] > Parâmetros de linha de comando também podem ser obtidos chamando estático <xref:System.Environment.GetCommandLineArgs%2A>método o <xref:System.Environment>objeto.</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> No entanto, <xref:System.Environment.GetCommandLineArgs%2A>requer confiança total para executar.</xref:System.Environment.GetCommandLineArgs%2A>       Se você definir <xref:System.Windows.Application.StartupUri%2A>usando [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)], a janela principal que é criada não está disponível em um a <xref:System.Windows.Application.MainWindow%2A>propriedade ou o <xref:System.Windows.Application.Windows%2A>propriedade do <xref:System.Windows.Application>do objeto até depois que o evento de inicialização é processado.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> Se você precisar acessar a janela principal durante a inicialização, você precisa criar manualmente um novo objeto de janela do seu manipulador de eventos de inicialização.      > [!NOTE] > Se seu aplicativo usa <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>para especificar uma política de credencial, você precisará definir <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>após a inicialização é gerado; caso contrário, [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] define como uma política interna padrão diretamente após o evento de inicialização que foi gerado.</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       Os argumentos de linha de comando que são passados para o manipulador de eventos de inicialização não são o mesmo que o [!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)] consultar parâmetros de cadeia de caracteres que são passados para um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]."
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] que é mostrada quando um aplicativo é iniciado automaticamente."
  remarks: "Você pode usar StartupUri para carregar automaticamente um [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recurso quando um aplicativo é iniciado.       A tabela a seguir mostra os tipos de [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recursos que podem ser carregados, o tipo de janela são abertas em e o tipo de aplicativo que esses recursos podem ser definidos como StartupUri.      | Tipo | Janela | Tipo de aplicativo |   |----------|------------|----------------------|   | <xref:System.Windows.Window>| <xref:System.Windows.Window>| Autônomo somente |   | <xref:System.Windows.Navigation.NavigationWindow>| <xref:System.Windows.Navigation.NavigationWindow>| Autônomo somente |   | <xref:System.Windows.Controls.Page>| <xref:System.Windows.Navigation.NavigationWindow>| Autônomo/online |   | <xref:System.Windows.Controls.UserControl>| <xref:System.Windows.Navigation.NavigationWindow>| Autônomo/online |   | <xref:System.Windows.Documents.FlowDocument>| <xref:System.Windows.Navigation.NavigationWindow>| Autônomo/online |   | <xref:System.Windows.Navigation.PageFunction%601>| <xref:System.Windows.Navigation.NavigationWindow>| Autônomo/online |       Normalmente, você define a propriedade StartupUri declarativamente em [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> No entanto, você pode definir StartupUri programaticamente, tais como de um <xref:System.Windows.Application.Startup>manipulador de eventos, que é útil se para aplicativos que podem carregar apenas o necessário [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recursos em tempo de execução.</xref:System.Windows.Application.Startup> Por exemplo, um aplicativo pode aguardar até que o tempo de execução para carregar seus recursos, se o nome do [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recursos são armazenados em um arquivo de configuração.       Se você definir StartupUri declarativamente ou programaticamente, correspondente [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] não é possível carregar o recurso até depois que o <xref:System.Windows.Application.Startup>evento é manipulado.</xref:System.Windows.Application.Startup> Consequentemente, você não terá acesso à janela resultante da <xref:System.Windows.Application.Windows%2A>propriedade ou a <xref:System.Windows.Application.MainWindow%2A>propriedade ao manipular <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "Um <xref:System.Uri>que se refere ao [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] que é aberto automaticamente quando um aplicativo é iniciado.</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartupUri é definida com um valor nulo."
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Consultas de uma propriedade de ambiente especificada está disponível no escopo atual."
  remarks: "Esse membro é uma implementação de membro de interface explícita. Ele pode ser usado somente quando o <xref:System.Windows.Application>instância é convertida em um <xref:System.Windows.Markup.IQueryAmbient>interface.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "O nome da propriedade ambiente solicitado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de ambiente solicitada está disponível. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pesquisa o recurso especificado."
  remarks: "TryFindResource primeiro examinará os recursos de escopo de aplicativo para o recurso especificado. Recursos de escopo de aplicativo são gerenciados pelo <xref:System.Windows.Application>e são expostas a partir do <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Se o recurso especificado não foi encontrado no conjunto de recursos de escopo do aplicativo, TryFindResource seguida pesquisará os recursos do sistema. Recursos do sistema são recursos de shell definidos pelo usuário e incluem cores, fontes e configurações de shell. Esses são expostos a partir de <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters>tipos, respectivamente, como propriedades estáticas.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Para usar TryFindResource para adquiri-los, esses tipos também expõem propriedades de chave de recurso que são projetadas para ser passado para TryFindResource; Por exemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Como TryFindResource retorna um objeto, você deve converter o valor retornado para o tipo apropriado, se o recurso foi encontrado.       Esse método é thread-safe e pode ser chamado de qualquer thread."
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O nome do recurso para localizar."
    return:
      type: System.Object
      description: "O objeto do recurso solicitado. Se o recurso solicitado não for encontrado, uma referência nula é retornada."
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o windows instanciado em um aplicativo."
  remarks: "Um <xref:System.Windows.Window>referência é automaticamente adicionada ao Windows como uma janela é instanciada no [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] thread; windows que são criados pelo trabalho de threads não são adicionados.</xref:System.Windows.Window> Um <xref:System.Windows.Window>referência é automaticamente removida após sua <xref:System.Windows.Window.Closing>evento foi tratado e antes de sua <xref:System.Windows.Window.Closed>é gerado.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       Por padrão, o primeiro item adicionado à propriedade Windows torna-se <xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       Essa propriedade está disponível somente do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "Um <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> que contém referências a todos os objetos de janela atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
