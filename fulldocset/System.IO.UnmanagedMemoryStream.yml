### YamlMime:ManagedReference
items:
- uid: System.IO.UnmanagedMemoryStream
  id: UnmanagedMemoryStream
  children:
  - System.IO.UnmanagedMemoryStream.#ctor
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.CanRead
  - System.IO.UnmanagedMemoryStream.CanSeek
  - System.IO.UnmanagedMemoryStream.CanWrite
  - System.IO.UnmanagedMemoryStream.Capacity
  - System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  - System.IO.UnmanagedMemoryStream.Flush
  - System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Length
  - System.IO.UnmanagedMemoryStream.Position
  - System.IO.UnmanagedMemoryStream.PositionPointer
  - System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.ReadByte
  - System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  - System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream
  fullName: System.IO.UnmanagedMemoryStream
  type: Class
  summary: "Fornece acesso aos blocos de memória não gerenciados do código gerenciado."
  remarks: "Esta classe dá suporte ao acesso de memória não gerenciada usando o modelo existente com base em fluxo e não requer que o conteúdo na memória não gerenciada ser copiados para o heap.      > [!IMPORTANT] > Este tipo implementa o <xref:System.IDisposable>interface.</xref:System.IDisposable> Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A>método em um `try` / `catch` bloco.</xref:System.IDisposable.Dispose%2A> Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção &quot;Usando um objeto que implementa IDisposable&quot; o <xref:System.IDisposable>tópico da interface.</xref:System.IDisposable>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the UnmanagedMemoryStream class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/t-system.io.unmanagedmem_1.cs)]"
  syntax:
    content: 'public class UnmanagedMemoryStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor
  id: '#ctor'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe."
  syntax:
    content: protected UnmanagedMemoryStream ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O usuário não tem a permissão necessária."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  id: '#ctor(System.Byte*,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe usando o comprimento de memória e o local especificado."
  remarks: "Este construtor cria uma nova instância do <xref:System.IO.UnmanagedMemoryStream>de classe e, por padrão, define o <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>propriedade `false` e o <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>propriedade `true`.</xref:System.IO.UnmanagedMemoryStream.CanRead%2A> </xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream> O <xref:System.IO.UnmanagedMemoryStream.Length%2A>propriedade é definida como o valor da `length` parâmetro e não pode ser alterado.</xref:System.IO.UnmanagedMemoryStream.Length%2A>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_4_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Um ponteiro para um local de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O tamanho de memória a ser usado."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O usuário não tem a permissão necessária."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe em um buffer de seguro com um deslocamento e comprimento especificados."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "O buffer para conter o fluxo de memória não gerenciada."
    - id: offset
      type: System.Int64
      description: "A posição de bytes no buffer no qual iniciar o fluxo de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O comprimento do fluxo de memória não gerenciada."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe usando o local especificado, o tamanho de memória, a quantidade total de memória e os valores de acesso de arquivo."
  remarks: "O `length` parâmetro define a quantidade de memória atual em uso. Se a leitura ou anexar dados no fluxo, o `length` valor deve ser igual à quantidade de dados válido no fluxo a ser lido do ou preservado. Se gravar no fluxo, esse valor deve ser zero.       O `capacity` parâmetro indica a quantidade de memória total disponível. Esse valor pode descrever uma região que seja maior que o comprimento especificado, ou indicar uma região que pode ser anexada à. Qualquer tentativa de gravar além esse valor falhará.       O `access` conjuntos de parâmetros de <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, e <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>Propriedades.</xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Observe que especificar <xref:System.IO.FileAccess>não garante que o fluxo será gravável.</xref:System.IO.FileAccess> Os parâmetros de acesso permitem que o implementador criar um objeto cuja implementação pode corresponder o fluxo real que é exposto."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/62930bcb-5dff-4d38-8341-_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Um ponteiro para um local de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O tamanho de memória a ser usado."
    - id: capacity
      type: System.Int64
      description: "A quantidade total de memória atribuída ao fluxo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O usuário não tem a permissão necessária."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is greater than the <code>capacity</code> value."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe em um buffer de seguro com um deslocamento especificado, o comprimento e o acesso ao arquivo."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "O buffer para conter o fluxo de memória não gerenciada."
    - id: offset
      type: System.Int64
      description: "A posição de bytes no buffer no qual iniciar o fluxo de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O comprimento do fluxo de memória não gerenciada."
    - id: access
      type: System.IO.FileAccess
      description: "O modo de acesso de arquivo para o fluxo de memória não gerenciada."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanRead
  id: CanRead
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se um fluxo oferece suporte à leitura."
  remarks: "Essa propriedade indica se o objeto do fluxo atual oferece suporte à leitura."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanRead property before attempting to display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Se o objeto foi criado por um construtor com um <code> access </code> parâmetro que não inclua o fluxo de leitura e se o fluxo está fechado; caso contrário, <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  id: CanSeek
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se um fluxo oferece suporte à busca."
  remarks: "Essa propriedade indica se o objeto do fluxo atual oferece suporte à busca."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Se o fluxo está fechado; Caso contrário, <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  id: CanWrite
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se um fluxo oferece suporte à gravação."
  remarks: "Essa propriedade indica se o objeto do fluxo atual oferece suporte à gravação."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanWrite property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Se o objeto foi criado por um construtor com um <code> access </code> valor de parâmetro que oferece suporte à gravação ou foi criada por um construtor que tinha sem parâmetros, ou se o fluxo está fechado; caso contrário, <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Capacity
  id: Capacity
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o comprimento do fluxo (tamanho) ou a quantidade total de memória atribuída a um fluxo (capacidade)."
  remarks: "Essa propriedade retorna o `capacity` valor fornecido para o construtor. Se nenhum `capacity` valor foi especificado quando o fluxo foi inicializado, essa propriedade retorna o comprimento do fluxo."
  syntax:
    content: public long Capacity { get; }
    return:
      type: System.Int64
      description: "O tamanho ou a capacidade do fluxo."
  overload: System.IO.UnmanagedMemoryStream.Capacity*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Libera os recursos não gerenciados usados pelo <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> e, opcionalmente, libera os recursos gerenciados."
  remarks: "Este método é chamado pelo público <xref:System.ComponentModel.Component.Dispose%2A>método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>invoca o método Dispose protegido com o `disposing` parâmetro definido como `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>chama Dispose com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.UnmanagedMemoryStream>referências.</xref:System.IO.UnmanagedMemoryStream> Este método chama o <xref:System.ComponentModel.Component.Dispose%2A>método de cada objeto referenciado.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.IO.UnmanagedMemoryStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Flush
  id: Flush
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Substitui o <xref:System.IO.Stream.Flush*>método para que nenhuma ação é executada.</xref:System.IO.Stream.Flush*>"
  remarks: "Esse método não realiza nenhuma ação para esta classe, mas é incluído como parte do que a <xref:System.IO.Stream>classe base.</xref:System.IO.Stream> Desde que todos os dados são gravados para a memória RAM, esse método é redundante."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Substitui o &lt;xref:System.IO.Stream.FlushAsync%2A?displayProperty=fullName&gt; método para que a operação será cancelada se especificado, mas nenhuma outra ação é executada.       Disponível a partir do[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Se a operação não for cancelada, o <xref:System.IO.UnmanagedMemoryStream>chama o <xref:System.IO.UnmanagedMemoryStream.Flush%2A>método, o que significa que nenhuma ação executada.</xref:System.IO.UnmanagedMemoryStream.Flush%2A> </xref:System.IO.UnmanagedMemoryStream>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento. O valor padrão é <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação assíncrona de liberação."
  overload: System.IO.UnmanagedMemoryStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe usando um ponteiro para um local de memória não gerenciada."
  remarks: "Esse método é equivalente a <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A>construtor.</xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> Dá suporte a métodos que precisam inicializar o ponteiro antes de definir variáveis de fluxo e, portanto, não é possível chamar o construtor com parâmetros. Esses métodos devem usar o construtor padrão, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, inicialize o ponteiro e, em seguida, chamar o método Initialize.</xref:System.IO.UnmanagedMemoryStream.%23ctor>"
  syntax:
    content: protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Um ponteiro para um local de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O tamanho de memória a ser usado."
    - id: capacity
      type: System.Int64
      description: "A quantidade total de memória atribuída ao fluxo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O usuário não tem a permissão necessária."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> classe em um buffer de seguro com um deslocamento especificado, o comprimento e o acesso ao arquivo."
  syntax:
    content: protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "O buffer para conter o fluxo de memória não gerenciada."
    - id: offset
      type: System.Int64
      description: "A posição de bytes no buffer no qual iniciar o fluxo de memória não gerenciada."
    - id: length
      type: System.Int64
      description: "O comprimento do fluxo de memória não gerenciada."
    - id: access
      type: System.IO.FileAccess
      description: "O modo de acesso de arquivo para o fluxo de memória não gerenciada."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Length
  id: Length
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o comprimento dos dados em um fluxo."
  remarks: "Se inalterado desde que o fluxo foi inicializado, essa propriedade retornará o valor de comprimento fornecido ao construtor. Se ocorreram alterações no fluxo, esta propriedade reflete as alterações para o comprimento dos dados."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "O comprimento dos dados no fluxo."
  overload: System.IO.UnmanagedMemoryStream.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Position
  id: Position
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém ou define a posição atual em um fluxo."
  remarks: "Quando um fluxo é inicializado, essa propriedade é definida como zero.       Embora você possa definir a posição do fluxo além da capacidade do fluxo, você não poderá acessar essa área usando o <xref:System.IO.UnmanagedMemoryStream.Read%2A>e <xref:System.IO.UnmanagedMemoryStream.Write%2A>métodos.</xref:System.IO.UnmanagedMemoryStream.Write%2A> </xref:System.IO.UnmanagedMemoryStream.Read%2A> <xref:System.IO.UnmanagedMemoryStream.Read%2A>retornará 0 e <xref:System.IO.UnmanagedMemoryStream.Write%2A>lançará um <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.UnmanagedMemoryStream.Write%2A></xref:System.IO.UnmanagedMemoryStream.Read%2A> Esse suporte é principalmente para compatibilidade com operações básicas de fluxo de design e código."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A posição atual no fluxo."
  overload: System.IO.UnmanagedMemoryStream.Position*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A posição é definida como um valor que é menor que zero ou a posição é maior do que <xref:System.Int32.MaxValue>ou resultados no estouro quando adicionado ao ponteiro atual.</xref:System.Int32.MaxValue>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  id: PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém ou define um ponteiro de bytes em um fluxo com base na posição atual no fluxo."
  remarks: "Para retornar um ponteiro para o fluxo inteiro, defina a <xref:System.IO.UnmanagedMemoryStream.Position%2A>propriedade como zero e, em seguida, chame essa propriedade.</xref:System.IO.UnmanagedMemoryStream.Position%2A>"
  syntax:
    content: public byte* PositionPointer { get; set; }
    return:
      type: System.Byte*
      description: "Um ponteiro de bytes."
  overload: System.IO.UnmanagedMemoryStream.PositionPointer*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "A posição atual é maior do que a capacidade do fluxo."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A posição está sendo conjunto não é uma posição válida no fluxo atual."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O ponteiro está sendo definido como um valor menor do que a posição inicial do fluxo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo foi inicializado para uso com <xref:System.Runtime.InteropServices.SafeBuffer>.</xref:System.Runtime.InteropServices.SafeBuffer> A propriedade PositionPointer só é válida para fluxos que são inicializados com um <xref:System.Byte>ponteiro.</xref:System.Byte>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê o número especificado de bytes na matriz especificada."
  remarks: "O `offset` parâmetro fornece o deslocamento de byte no `array` parâmetro (o índice de buffer) no qual começar a ler e o `count` parâmetro fornece o número máximo de bytes a ser lido do fluxo. O valor retornado é o número real de bytes lidos ou zero se o fim do fluxo for atingido. Se a operação de leitura for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.       O método de leitura retorna zero somente depois de atingir o final do fluxo. Caso contrário, o leitura sempre lê pelo menos um byte do fluxo antes de retornar. Se nenhum dado está disponível no fluxo após uma chamada para leitura, o método será bloqueado até que pelo menos um byte de dados pode ser retornado. Uma implementação está livre para retornar menos bytes que solicitado, mesmo que não foi atingido o fim do fluxo."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Quando este método retorna, contém a matriz de bytes especificada com os valores entre `offset` e (`offset`  +  `count` - 1) substituídos pelos bytes lidos da origem atual. Esse parâmetro é passado não inicializado."
    - id: offset
      type: System.Int32
      description: "O deslocamento de bytes baseado em zero em `buffer` no qual começar a armazenar os dados lidos do fluxo atual."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem lidos do fluxo atual."
    return:
      type: System.Int32
      description: "O número total de bytes lidos no buffer. Isso pode ser menor que o número de bytes solicitado se que muitos bytes não estão disponíveis no momento ou zero (0) se o fim do fluxo foi atingido."
  overload: System.IO.UnmanagedMemoryStream.Read*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The <xref:System.IO.UnmanagedMemoryStream.CanRead*> property is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is set to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>offset</code> parameter is less than zero.  \n  \n \\- or -  \n  \n The <code>count</code> parameter is less than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O comprimento da matriz de buffer menos a <code> offset </code> parâmetro é menor do que o <code> count </code> parâmetro."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê de forma assíncrona o número de bytes especificado na matriz especificada.       Disponível a partir do[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Se ocorrer uma exceção durante a operação de leitura, ele será definido como o <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>da propriedade da tarefa retornada.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "O buffer para gravar os dados."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `buffer` no qual começar a gravar dados no fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem lidos."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento. O valor padrão é <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operação de leitura de uma tarefa que representa o assíncrona. O valor de <code> TResult </code> parâmetro contém o número total de bytes lidos no buffer. O valor do resultado pode ser menor que o número de bytes solicitado se o número de bytes disponíveis atualmente é menor que o número solicitado, ou pode ser 0 (zero) se o fim do fluxo foi atingido."
  overload: System.IO.UnmanagedMemoryStream.ReadAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  id: ReadByte
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um byte de um fluxo e avança a posição dentro do fluxo por um byte ou retornará -1 se estiver no final do fluxo."
  remarks: "Use este método para retornar valores inteiros do fluxo."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "O byte sem sinal é convertido em um <xref:System.Int32>objeto ou -1 se estiver no final do fluxo.</xref:System.Int32>"
  overload: System.IO.UnmanagedMemoryStream.ReadByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The current position is at the end of the stream."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define a posição atual do fluxo atual como o valor especificado."
  remarks: "Para obter mais informações sobre a busca, consulte <xref:System.IO.FileStream.Seek%2A>.</xref:System.IO.FileStream.Seek%2A>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin loc);
    parameters:
    - id: offset
      type: System.Int64
      description: "O ponto relativo a `origin` para iniciar a busca de."
    - id: loc
      type: System.IO.SeekOrigin
      description: "Especifica o início, fim ou a posição atual como um ponto de referência para `origin`, usando um valor do tipo <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "A nova posição no fluxo."
  overload: System.IO.UnmanagedMemoryStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Foi feita uma tentativa de buscar antes do início do fluxo."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> offset </code> valor é maior que o tamanho máximo do fluxo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>loc</code>não é válido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define o comprimento de um fluxo para um valor especificado."
  remarks: "Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo é truncado. Se o valor especificado é maior que o tamanho atual do fluxo, o fluxo é expandido. Se o fluxo é expandido, o conteúdo do fluxo entre o antigo e os novos tamanhos é indefinido.       Um fluxo deve oferecer suporte a gravar tanto buscando SetLength funcione."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "O comprimento do fluxo."
  overload: System.IO.UnmanagedMemoryStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The specified <code>value</code> exceeds the capacity of the stream.  \n  \n \\- or -  \n  \n The specified <code>value</code> is negative."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava um bloco de bytes no fluxo atual usando dados de um buffer."
  remarks: "Gravação ocorre na posição atual no fluxo."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_3_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A matriz de bytes da qual copiar bytes para o fluxo atual."
    - id: offset
      type: System.Int32
      description: "O deslocamento do buffer no qual começar a copiar bytes para o fluxo atual."
    - id: count
      type: System.Int32
      description: "O número de bytes a serem gravados no fluxo atual."
  overload: System.IO.UnmanagedMemoryStream.Write*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The <code>count</code> value is greater than the capacity of the stream.  \n  \n \\- or -  \n  \n The position is at the end of the stream capacity."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um dos parâmetros especificados é menor que zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> offset </code> parâmetro menos o comprimento do <code> buffer </code> parâmetro é menor do que o <code> count </code> parâmetro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro do fluxo pelo número de bytes gravados e monitora solicitações de cancelamento.       Disponível a partir do[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Se ocorrer uma exceção durante a operação de gravação, ele será definido como o <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>da propriedade da tarefa retornada.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "O buffer para gravar dados."
    - id: offset
      type: System.Int32
      description: "O deslocamento de bytes de base zero no `buffer` da qual começar a copiar bytes para o fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem gravados."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento. O valor padrão é <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação de gravação assíncrona."
  overload: System.IO.UnmanagedMemoryStream.WriteAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava um byte para a posição atual no fluxo de arquivo."
  remarks: ''
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Um valor de bytes gravado no fluxo."
  overload: System.IO.UnmanagedMemoryStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The current position is at the end of the capacity of the stream."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fornecido <code> value </code> faz com que o fluxo exceder sua capacidade máxima."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IndexOutOfRangeException
  isExternal: true
  name: System.IndexOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.UnmanagedMemoryStream.#ctor
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
- uid: System.Runtime.InteropServices.SafeBuffer
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeBuffer
  nameWithType: SafeBuffer
  fullName: System.Runtime.InteropServices.SafeBuffer
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.CanRead
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
- uid: System.IO.UnmanagedMemoryStream.Flush
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Length
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.UnmanagedMemoryStream.#ctor*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream
- uid: System.IO.UnmanagedMemoryStream.CanRead*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
- uid: System.IO.UnmanagedMemoryStream.CanSeek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose
  nameWithType: UnmanagedMemoryStream.Dispose
- uid: System.IO.UnmanagedMemoryStream.Flush*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush
  nameWithType: UnmanagedMemoryStream.Flush
- uid: System.IO.UnmanagedMemoryStream.FlushAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync
  nameWithType: UnmanagedMemoryStream.FlushAsync
- uid: System.IO.UnmanagedMemoryStream.Initialize*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize
  nameWithType: UnmanagedMemoryStream.Initialize
- uid: System.IO.UnmanagedMemoryStream.Length*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read
  nameWithType: UnmanagedMemoryStream.Read
- uid: System.IO.UnmanagedMemoryStream.ReadAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync
  nameWithType: UnmanagedMemoryStream.ReadAsync
- uid: System.IO.UnmanagedMemoryStream.ReadByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte
  nameWithType: UnmanagedMemoryStream.ReadByte
- uid: System.IO.UnmanagedMemoryStream.Seek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek
  nameWithType: UnmanagedMemoryStream.Seek
- uid: System.IO.UnmanagedMemoryStream.SetLength*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength
  nameWithType: UnmanagedMemoryStream.SetLength
- uid: System.IO.UnmanagedMemoryStream.Write*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write
  nameWithType: UnmanagedMemoryStream.Write
- uid: System.IO.UnmanagedMemoryStream.WriteAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync
  nameWithType: UnmanagedMemoryStream.WriteAsync
- uid: System.IO.UnmanagedMemoryStream.WriteByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte
  nameWithType: UnmanagedMemoryStream.WriteByte
