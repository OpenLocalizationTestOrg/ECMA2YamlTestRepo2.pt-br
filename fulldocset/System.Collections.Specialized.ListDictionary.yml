### YamlMime:ManagedReference
items:
- uid: System.Collections.Specialized.ListDictionary
  id: ListDictionary
  children:
  - System.Collections.Specialized.ListDictionary.#ctor
  - System.Collections.Specialized.ListDictionary.#ctor(System.Collections.IComparer)
  - System.Collections.Specialized.ListDictionary.Add(System.Object,System.Object)
  - System.Collections.Specialized.ListDictionary.Clear
  - System.Collections.Specialized.ListDictionary.Contains(System.Object)
  - System.Collections.Specialized.ListDictionary.CopyTo(System.Array,System.Int32)
  - System.Collections.Specialized.ListDictionary.Count
  - System.Collections.Specialized.ListDictionary.GetEnumerator
  - System.Collections.Specialized.ListDictionary.IsFixedSize
  - System.Collections.Specialized.ListDictionary.IsReadOnly
  - System.Collections.Specialized.ListDictionary.IsSynchronized
  - System.Collections.Specialized.ListDictionary.Item(System.Object)
  - System.Collections.Specialized.ListDictionary.Keys
  - System.Collections.Specialized.ListDictionary.Remove(System.Object)
  - System.Collections.Specialized.ListDictionary.SyncRoot
  - System.Collections.Specialized.ListDictionary.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Specialized.ListDictionary.Values
  langs:
  - csharp
  name: ListDictionary
  nameWithType: ListDictionary
  fullName: System.Collections.Specialized.ListDictionary
  type: Class
  summary: "Implementa <xref uid=&quot;langword_csharp_IDictionary&quot; name=&quot;IDictionary&quot; href=&quot;&quot;> </xref> usando uma lista individualmente vinculada. Recomendado para coleções que normalmente contêm menos de 10 itens."
  remarks: "Isso é uma implementação simple de <xref:System.Collections.IDictionary>usando uma lista individualmente vinculada.</xref:System.Collections.IDictionary> É menor e mais rápido do que um <xref:System.Collections.Hashtable>se o número de elementos é 10 ou menos.</xref:System.Collections.Hashtable> Isso não deve ser usado se o desempenho for importante para um grande número de elementos.       Itens em um ListDictionary não estão em qualquer ordem garantida. código não deve depender da ordem atual. O ListDictionary é implementado para rápida recuperação de chave; a ordem interna real de itens é dependente de implementação e pode mudar em versões futuras do produto.       Membros, como <xref:System.Collections.Specialized.ListDictionary.Item%2A>, <xref:System.Collections.Specialized.ListDictionary.Add%2A>, <xref:System.Collections.Specialized.ListDictionary.Remove%2A>, e <xref:System.Collections.Specialized.ListDictionary.Contains%2A>são O (`n`) operações, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A> </xref:System.Collections.Specialized.ListDictionary.Contains%2A> </xref:System.Collections.Specialized.ListDictionary.Remove%2A> </xref:System.Collections.Specialized.ListDictionary.Add%2A> </xref:System.Collections.Specialized.ListDictionary.Item%2A>       Uma chave não pode ser `null`, mas um valor possível.       O `foreach` instrução de linguagem c# (`for each` no Visual Basic) retorna um objeto do tipo dos elementos na coleção. Como cada elemento ListDictionary é um par chave/valor, o tipo de elemento não é o tipo de chave ou o tipo do valor. Em vez disso, o tipo de elemento é <xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> Por exemplo: [!code-cs [System.Collections.Specialized.ListDictionary2#3](~/add/codesnippet/csharp/t-system.collections.spe_9_1.cs)][!code-cpp[System.Collections.Specialized.ListDictionary2#3](~/add/codesnippet/cpp/t-system.collections.spe_9_1.cpp)][!code-vb[System.Collections.Specialized.ListDictionary2#3](~/add/codesnippet/visualbasic/t-system.collections.spe_9_1.vb) ] o `foreach` instrução é um wrapper em torno de enumerador, que só permite ler, gravar não à coleção.    "
  example:
  - "The following code example demonstrates several of the properties and methods of ListDictionary.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/cpp/t-system.collections.spe_9_2.cpp)]\n [!code-cs[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/csharp/t-system.collections.spe_9_2.cs)]\n [!code-vb[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/visualbasic/t-system.collections.spe_9_2.vb)]"
  syntax:
    content: 'public class ListDictionary : System.Collections.IDictionary'
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.#ctor
  id: '#ctor'
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: ListDictionary()
  nameWithType: ListDictionary.ListDictionary()
  fullName: System.Collections.Specialized.ListDictionary.ListDictionary()
  type: Constructor
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Cria um vazio <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> usando o comparador padrão."
  remarks: "O comparador determina se duas chaves são iguais. Todas as chaves em um <xref:System.Collections.Specialized.ListDictionary>devem ser exclusivos.</xref:System.Collections.Specialized.ListDictionary> O comparador padrão é a implementação da chave de <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Este construtor é uma operação de (1)."
  example:
  - "The following code example demonstrates several of the properties and methods of <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/cpp/m-system.collections.spe_8_1.cpp)]\n [!code-cs[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/csharp/m-system.collections.spe_8_1.cs)]\n [!code-vb[System.Collections.Specialized.ListDictionary2#1](~/add/codesnippet/visualbasic/m-system.collections.spe_8_1.vb)]"
  syntax:
    content: public ListDictionary ();
    parameters: []
  overload: System.Collections.Specialized.ListDictionary.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.#ctor(System.Collections.IComparer)
  id: '#ctor(System.Collections.IComparer)'
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: ListDictionary(IComparer)
  nameWithType: ListDictionary.ListDictionary(IComparer)
  fullName: System.Collections.Specialized.ListDictionary.ListDictionary(IComparer)
  type: Constructor
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Cria um vazio <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> usando o comparador especificado."
  remarks: "O comparador determina se duas chaves são iguais. Todas as chaves em um <xref:System.Collections.Specialized.ListDictionary>devem ser exclusivos.</xref:System.Collections.Specialized.ListDictionary> O comparador padrão é a implementação da chave de <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       O comparador personalizado permite que esses cenários como fazer pesquisas com cadeias de caracteres de maiusculas e minúsculas.       Este construtor é uma operação de (1)."
  syntax:
    content: public ListDictionary (System.Collections.IComparer comparer);
    parameters:
    - id: comparer
      type: System.Collections.IComparer
      description: "O <xref:System.Collections.IComparer>a ser usado para determinar se duas chaves são iguais.</xref:System.Collections.IComparer>       - ou - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar o comparador padrão, que é a implementação de cada chave de &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Specialized.ListDictionary.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: ListDictionary.Add(Object,Object)
  fullName: System.Collections.Specialized.ListDictionary.Add(Object,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Adiciona uma entrada com a chave especificada e o valor para o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  remarks: "Um objeto que não tem nenhuma correlação entre seu estado e seu valor de código de hash, normalmente, não deve ser usado como chave. Por exemplo, objetos de cadeia de caracteres são melhores que objetos de StringBuilder para uso como chaves.       Você também pode usar o <xref:System.Collections.Specialized.ListDictionary.Item%2A>propriedade para adicionar novos elementos, definindo o valor de uma chave que não existe no <xref:System.Collections.Specialized.ListDictionary>; por exemplo, `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Collections.Specialized.ListDictionary.Item%2A> No entanto, se a chave especificada já existe no <xref:System.Collections.Specialized.ListDictionary>, a definição de <xref:System.Collections.Specialized.ListDictionary.Item%2A>propriedade substitui o valor antigo.</xref:System.Collections.Specialized.ListDictionary.Item%2A> </xref:System.Collections.Specialized.ListDictionary> Por outro lado, o método Add não modifica os elementos existentes.       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A>"
  example:
  - "The following code example adds to and removes elements from a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/cpp/m-system.collections.spe_26_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/visualbasic/m-system.collections.spe_26_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/csharp/m-system.collections.spe_26_1.cs)]"
  syntax:
    content: public void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "A chave de entrada a ser adicionada."
    - id: value
      type: System.Object
      description: "O valor da entrada a ser adicionada. O valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Já existe uma entrada com a mesma chave no <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Clear
  id: Clear
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Clear()
  nameWithType: ListDictionary.Clear()
  fullName: System.Collections.Specialized.ListDictionary.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Remove todas as entradas do <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  remarks: "<xref:System.Collections.Specialized.ListDictionary.Count%2A>é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.</xref:System.Collections.Specialized.ListDictionary.Count%2A>       Esse método é uma operação de (1)."
  example:
  - "The following code example adds to and removes elements from a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/cpp/m-system.collections.spe_43_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/visualbasic/m-system.collections.spe_43_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/csharp/m-system.collections.spe_43_1.cs)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Collections.Specialized.ListDictionary.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: ListDictionary.Contains(Object)
  fullName: System.Collections.Specialized.ListDictionary.Contains(Object)
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Determina se o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> contém uma chave específica."
  remarks: "Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A>       Começando com o .NET Framework 2.0, esse método usa objetos da coleção <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>métodos em `key` para determinar se `item` existe.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> Nas versões anteriores do .NET Framework, isso foi feito por meio de <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>métodos do `item` parâmetro nos objetos na coleção.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example searches for an element in a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Contains#1](~/add/codesnippet/cpp/m-system.collections.spe_22_1.cpp)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Contains#1](~/add/codesnippet/csharp/m-system.collections.spe_22_1.cs)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Contains#1](~/add/codesnippet/visualbasic/m-system.collections.spe_22_1.vb)]"
  syntax:
    content: public bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "A chave a ser localizado no <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> contém uma entrada com a chave; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: ListDictionary.CopyTo(Array,Int32)
  fullName: System.Collections.Specialized.ListDictionary.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Copia o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> entradas para um unidimensional <xref:System.Array>instância no índice especificado.</xref:System.Array>"
  remarks: "Os elementos são copiados para o <xref:System.Array>na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Specialized.ListDictionary>.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Array>       Para copiar somente as chaves de <xref:System.Collections.Specialized.ListDictionary>, use `ListDictionary.Keys.CopyTo`.</xref:System.Collections.Specialized.ListDictionary>       Para copiar somente os valores no <xref:System.Collections.Specialized.ListDictionary>, use `ListDictionary.Values.CopyTo`.</xref:System.Collections.Specialized.ListDictionary>       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A>"
  example:
  - "The following code example copies the elements of a <xref:System.Collections.Specialized.ListDictionary> to an array.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_CopyTo#1](~/add/codesnippet/cpp/9aabfe2b-669c-468b-9ada-_1.cpp)]\n [!code-cs[System.Collections.Specialized.ListDictionary_CopyTo#1](~/add/codesnippet/csharp/9aabfe2b-669c-468b-9ada-_1.cs)]\n [!code-vb[System.Collections.Specialized.ListDictionary_CopyTo#1](~/add/codesnippet/visualbasic/9aabfe2b-669c-468b-9ada-_1.vb)]"
  syntax:
    content: public void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "O unidimensional <xref:System.Array>que é o destino do <xref:System.Collections.DictionaryEntry>objetos copiados do <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.DictionaryEntry> </xref:System.Array> O <xref:System.Array>devem ter a indexação com base em zero.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "O índice de base zero no `array` no qual a cópia começa."
  overload: System.Collections.Specialized.ListDictionary.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>é menor que zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>é multidimensional.       o número de elementos na origem - ou - <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> é maior que o espaço disponível do <code>index</code> até o final do destino <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "O tipo da fonte de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> não pode ser convertido automaticamente para o tipo de destino <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Count
  id: Count
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Count
  nameWithType: ListDictionary.Count
  fullName: System.Collections.Specialized.ListDictionary.Count
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém o número de pares chave/valor contidos no <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  remarks: "Recuperar o valor dessa propriedade é uma operação de (1)."
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/p-system.collections.spe_2_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/p-system.collections.spe_2_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/p-system.collections.spe_2_1.cs)]"
  syntax:
    content: public int Count { get; }
    return:
      type: System.Int32
      description: "O número de pares chave/valor contidos no <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: ListDictionary.GetEnumerator()
  fullName: System.Collections.Specialized.ListDictionary.GetEnumerator()
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Retorna um <xref:System.Collections.IDictionaryEnumerator>que itera por meio de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "O `foreach` instrução de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, usando `foreach` é recomendada, em vez de manipulação direta do enumerador.       Enumeradores podem ser usados para ler os dados na coleção, mas eles não podem ser usados para modificar a coleção subjacente.       Inicialmente, o enumerador está posicionado antes do primeiro elemento na coleção. <xref:System.Collections.IEnumerator.Reset%2A>também traz o enumerador de volta para essa posição.</xref:System.Collections.IEnumerator.Reset%2A>  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A>é indefinido.</xref:System.Collections.IEnumerator.Current%2A> Portanto, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A>para avançar o enumerador para o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Retorna o mesmo objeto até que o <xref:System.Collections.IEnumerator.MoveNext%2A>ou <xref:System.Collections.IEnumerator.Reset%2A>é chamado.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>define <xref:System.Collections.IEnumerator.Current%2A>para o próximo elemento.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>passa o final da coleção, o enumerador está posicionado após o último elemento da coleção e <xref:System.Collections.IEnumerator.MoveNext%2A>retorna `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando o enumerador está nessa posição, chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A>também retornam `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se a última chamada <xref:System.Collections.IEnumerator.MoveNext%2A>retornado `false`, <xref:System.Collections.IEnumerator.Current%2A>é indefinido.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Definir <xref:System.Collections.IEnumerator.Current%2A>para o primeiro elemento da coleção novamente, você pode chamar <xref:System.Collections.IEnumerator.Reset%2A>seguido pelo <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Um enumerador permanece válido desde que a coleção permaneça inalterada. Se forem feitas alterações à coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado irrecuperavelmente e seu comportamento é indefinido.       O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de thread-safe.  Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.       Esse método é uma operação de (1)."
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/m-system.collections.spe_6_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/m-system.collections.spe_6_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/m-system.collections.spe_6_1.cs)]"
  syntax:
    content: public System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Specialized.ListDictionary.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: ListDictionary.IsFixedSize
  fullName: System.Collections.Specialized.ListDictionary.IsFixedSize
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> tem um tamanho fixo."
  remarks: "<xref:System.Collections.Specialized.ListDictionary>implementa a propriedade IsFixedSize porque ele é necessário para o <xref:System.Collections.IDictionary?displayProperty=fullName>interface.</xref:System.Collections.IDictionary?displayProperty=fullName></xref:System.Collections.Specialized.ListDictionary>       Uma coleção com um tamanho fixo não permite a adição ou remoção de elementos após a criação da coleção, mas permite a modificação de elementos existentes.       Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e remoção de elementos; Portanto, se forem feitas alterações à coleção subjacente, incluindo a adição ou remoção de elementos, a coleção de tamanho fixo reflete as alterações.       Recuperar o valor dessa propriedade é uma operação de (1)."
  syntax:
    content: public bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "Essa propriedade sempre retorna <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: ListDictionary.IsReadOnly
  fullName: System.Collections.Specialized.ListDictionary.IsReadOnly
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> é somente leitura."
  remarks: "<xref:System.Collections.Specialized.ListDictionary>implementa a propriedade IsReadOnly porque ele é necessário para o <xref:System.Collections.IDictionary?displayProperty=fullName>interface.</xref:System.Collections.IDictionary?displayProperty=fullName></xref:System.Collections.Specialized.ListDictionary>       Uma coleção que é somente leitura não permite a adição, remoção ou modificação de elementos após a criação da coleção.       Uma coleção que é somente leitura é simplesmente uma coleção com um wrapper que impede a modificação da coleção; Portanto, se forem feitas alterações à coleção subjacente, a coleção somente leitura reflete as alterações.       Recuperar o valor dessa propriedade é uma operação de (1)."
  syntax:
    content: public bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "Essa propriedade sempre retorna <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: ListDictionary.IsSynchronized
  fullName: System.Collections.Specialized.ListDictionary.IsSynchronized
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref> é sincronizado (thread-safe)."
  remarks: "<xref:System.Collections.Specialized.ListDictionary>implementa a propriedade IsSynchronized porque ele é necessário para o <xref:System.Collections.ICollection?displayProperty=fullName>interface.</xref:System.Collections.ICollection?displayProperty=fullName></xref:System.Collections.Specialized.ListDictionary>       Classes derivadas podem fornecer uma versão sincronizada do <xref:System.Collections.Specialized.ListDictionary>usando o <xref:System.Collections.Specialized.ListDictionary.SyncRoot%2A>propriedade.</xref:System.Collections.Specialized.ListDictionary.SyncRoot%2A> </xref:System.Collections.Specialized.ListDictionary>       Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Specialized.ListDictionary.SyncRoot%2A> during the entire enumeration.  \n  \n [!code-cs[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/csharp/p-system.collections.spe_6_1.cs)]\n [!code-cpp[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/cpp/p-system.collections.spe_6_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/visualbasic/p-system.collections.spe_6_1.vb)]  \n  \n Retrieving the value of this property is an O(1) operation."
  syntax:
    content: public bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "Essa propriedade sempre retorna <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Item(Object)
  nameWithType: ListDictionary.Item(Object)
  fullName: System.Collections.Specialized.ListDictionary.Item(Object)
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém ou define o valor associado com a chave especificada."
  remarks: "Esta propriedade fornece a capacidade de acessar um elemento específico na coleção usando a seguinte sintaxe: `myCollection[key]`.       Você também pode usar a propriedade do Item para adicionar novos elementos, definindo o valor de uma chave que não existe no <xref:System.Collections.Specialized.ListDictionary>; por exemplo, `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Specialized.ListDictionary> No entanto, se a chave especificada já existe na <xref:System.Collections.Specialized.ListDictionary>, definindo a propriedade de Item substitui o valor antigo.</xref:System.Collections.Specialized.ListDictionary> Em contraste, o <xref:System.Collections.Specialized.ListDictionary.Add%2A>método não modifica os elementos existentes.</xref:System.Collections.Specialized.ListDictionary.Add%2A>       Uma chave não pode ser `null`, mas um valor possível. Para distinguir entre `null` que é retornado porque a chave especificada não foi encontrada e `null` que é retornado porque o valor da chave especificada é `null`, use o <xref:System.Collections.Specialized.ListDictionary.Contains%2A>método para determinar se a chave existe na lista.</xref:System.Collections.Specialized.ListDictionary.Contains%2A>       A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar a propriedade do Item. Visual Basic implementa um Item como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A>"
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/p-system.collections.spe_11_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/p-system.collections.spe_11_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/p-system.collections.spe_11_1.cs)]"
  syntax:
    content: public object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "A chave cujo valor a ser obtido ou definido."
    return:
      type: System.Object
      description: "O valor associado com a chave especificada. Se a chave especificada não for encontrada, a tentativa de obtê-lo retorna <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, e a tentativa de definir a ele cria uma nova entrada usando a chave especificada."
  overload: System.Collections.Specialized.ListDictionary.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Keys
  id: Keys
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Keys
  nameWithType: ListDictionary.Keys
  fullName: System.Collections.Specialized.ListDictionary.Keys
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um <xref:System.Collections.ICollection>que contém as chaves de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "A ordem dos valores no <xref:System.Collections.ICollection>não for especificado, mas é a mesma ordem que os valores associados no <xref:System.Collections.ICollection>retornado pelo <xref:System.Collections.Specialized.ListDictionary.Values%2A>método.</xref:System.Collections.Specialized.ListDictionary.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       Retornado <xref:System.Collections.ICollection>não é uma cópia estática; em vez disso, o que <xref:System.Collections.ICollection>faz referência a chaves no original <xref:System.Collections.Specialized.ListDictionary>.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Portanto, as alterações para o <xref:System.Collections.Specialized.ListDictionary>continuam a ser refletido em <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Specialized.ListDictionary>       Recuperar o valor dessa propriedade é uma operação de (1)."
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/p-system.collections.spe_28_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/p-system.collections.spe_28_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/p-system.collections.spe_28_1.cs)]"
  syntax:
    content: public System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "Um <xref:System.Collections.ICollection>que contém as chaves de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Specialized.ListDictionary.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: ListDictionary.Remove(Object)
  fullName: System.Collections.Specialized.ListDictionary.Remove(Object)
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Remove a entrada com a chave especificada do <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  remarks: "Se o <xref:System.Collections.Specialized.ListDictionary>não contém um elemento com a chave especificada, o <xref:System.Collections.Specialized.ListDictionary>permanece inalterado.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Collections.Specialized.ListDictionary> Nenhuma exceção é lançada.       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Specialized.ListDictionary.Count%2A>.</xref:System.Collections.Specialized.ListDictionary.Count%2A>"
  example:
  - "The following code example adds to and removes elements from a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/cpp/m-system.collections.spe_21_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/visualbasic/m-system.collections.spe_21_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_AddRemove#1](~/add/codesnippet/csharp/m-system.collections.spe_21_1.cs)]"
  syntax:
    content: public void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "A chave da entrada a ser removido."
  overload: System.Collections.Specialized.ListDictionary.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.SyncRoot
  id: SyncRoot
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: SyncRoot
  nameWithType: ListDictionary.SyncRoot
  fullName: System.Collections.Specialized.ListDictionary.SyncRoot
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um objeto que pode ser usado para sincronizar o acesso a <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  remarks: "Classes derivadas podem fornecer sua própria versão sincronizada de <xref:System.Collections.Specialized.ListDictionary>usando a propriedade SyncRoot.</xref:System.Collections.Specialized.ListDictionary> O código de sincronização deve executar operações no SyncRoot do <xref:System.Collections.Specialized.ListDictionary>, não diretamente no <xref:System.Collections.Specialized.ListDictionary>.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Collections.Specialized.ListDictionary> Isso garante que a operação correta de coleções que são derivados de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <xref:System.Collections.Specialized.ListDictionary>objeto.</xref:System.Collections.Specialized.ListDictionary>       Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration.  \n  \n [!code-cs[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/csharp/p-system.collections.spe_1_1.cs)]\n [!code-cpp[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/cpp/p-system.collections.spe_1_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary2#2](~/add/codesnippet/visualbasic/p-system.collections.spe_1_1.vb)]  \n  \n Retrieving the value of this property is an O(1) operation."
  syntax:
    content: public object SyncRoot { get; }
    return:
      type: System.Object
      description: "Um objeto que pode ser usado para sincronizar o acesso a <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>."
  overload: System.Collections.Specialized.ListDictionary.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ListDictionary.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Specialized.ListDictionary.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Retorna um <xref:System.Collections.IEnumerator>que itera por meio de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "O `foreach` instrução de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, usando `foreach` é recomendada, em vez de manipulação direta do enumerador.       Enumeradores podem ser usados para ler os dados na coleção, mas eles não podem ser usados para modificar a coleção subjacente.       Inicialmente, o enumerador está posicionado antes do primeiro elemento na coleção. <xref:System.Collections.IEnumerator.Reset%2A>também traz o enumerador de volta para essa posição.</xref:System.Collections.IEnumerator.Reset%2A> AT isso posicionar, chamando <xref:System.Collections.IEnumerator.Current%2A>lança uma exceção.</xref:System.Collections.IEnumerator.Current%2A> Portanto, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A>para avançar o enumerador para o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Retorna o mesmo objeto até que o <xref:System.Collections.IEnumerator.MoveNext%2A>ou <xref:System.Collections.IEnumerator.Reset%2A>é chamado.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>define <xref:System.Collections.IEnumerator.Current%2A>para o próximo elemento.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>passa o final da coleção, o enumerador está posicionado após o último elemento da coleção e <xref:System.Collections.IEnumerator.MoveNext%2A>retorna `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando o enumerador está nessa posição, chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A>também retornam `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se a última chamada <xref:System.Collections.IEnumerator.MoveNext%2A>retornado `false`, chamar <xref:System.Collections.IEnumerator.Current%2A>lança uma exceção.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Definir <xref:System.Collections.IEnumerator.Current%2A>para o primeiro elemento da coleção novamente, você pode chamar <xref:System.Collections.IEnumerator.Reset%2A>seguido pelo <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Um enumerador permanece válido desde que a coleção permaneça inalterada. Se forem feitas alterações à coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado irrecuperavelmente e a próxima chamada ou <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A>gera um <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Se a coleção é modificada entre <xref:System.Collections.IEnumerator.MoveNext%2A>e <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A>retorna o elemento que está definido como, mesmo se o enumerador já é invalidado.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.       Esse método é uma operação de (1)."
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/98b866c7-b98f-4af5-b9e4-_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/98b866c7-b98f-4af5-b9e4-_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/98b866c7-b98f-4af5-b9e4-_1.cs)]"
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Specialized.ListDictionary.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Specialized.ListDictionary.Values
  id: Values
  parent: System.Collections.Specialized.ListDictionary
  langs:
  - csharp
  name: Values
  nameWithType: ListDictionary.Values
  fullName: System.Collections.Specialized.ListDictionary.Values
  type: Property
  assemblies:
  - System
  namespace: System.Collections.Specialized
  summary: "Obtém um <xref:System.Collections.ICollection>que contém os valores de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "A ordem dos valores no <xref:System.Collections.ICollection>não for especificado, mas é a mesma ordem que as chaves associadas no <xref:System.Collections.ICollection>retornado pelo <xref:System.Collections.Specialized.ListDictionary.Keys%2A>método.</xref:System.Collections.Specialized.ListDictionary.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       Retornado <xref:System.Collections.ICollection>não é uma cópia estática; em vez disso, o que <xref:System.Collections.ICollection>faz referência a valores no original <xref:System.Collections.Specialized.ListDictionary>.</xref:System.Collections.Specialized.ListDictionary> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Portanto, as alterações para o <xref:System.Collections.Specialized.ListDictionary>continuam a ser refletido em <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Specialized.ListDictionary>       Recuperar o valor dessa propriedade é uma operação de (1)."
  example:
  - "The following code example enumerates the elements of a <xref:System.Collections.Specialized.ListDictionary>.  \n  \n [!code-cpp[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/cpp/p-system.collections.spe_26_1.cpp)]\n [!code-vb[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/visualbasic/p-system.collections.spe_26_1.vb)]\n [!code-cs[System.Collections.Specialized.ListDictionary_Enumerator#1](~/add/codesnippet/csharp/p-system.collections.spe_26_1.cs)]"
  syntax:
    content: public System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "Um <xref:System.Collections.ICollection>que contém os valores de <xref href=&quot;System.Collections.Specialized.ListDictionary&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Specialized.ListDictionary.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.Collections.Specialized.ListDictionary.#ctor
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: ListDictionary()
  nameWithType: ListDictionary.ListDictionary()
  fullName: System.Collections.Specialized.ListDictionary.ListDictionary()
- uid: System.Collections.Specialized.ListDictionary.#ctor(System.Collections.IComparer)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: ListDictionary(IComparer)
  nameWithType: ListDictionary.ListDictionary(IComparer)
  fullName: System.Collections.Specialized.ListDictionary.ListDictionary(IComparer)
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Specialized.ListDictionary.Add(System.Object,System.Object)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Add(Object,Object)
  nameWithType: ListDictionary.Add(Object,Object)
  fullName: System.Collections.Specialized.ListDictionary.Add(Object,Object)
- uid: System.Collections.Specialized.ListDictionary.Clear
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Clear()
  nameWithType: ListDictionary.Clear()
  fullName: System.Collections.Specialized.ListDictionary.Clear()
- uid: System.Collections.Specialized.ListDictionary.Contains(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Contains(Object)
  nameWithType: ListDictionary.Contains(Object)
  fullName: System.Collections.Specialized.ListDictionary.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Specialized.ListDictionary.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: ListDictionary.CopyTo(Array,Int32)
  fullName: System.Collections.Specialized.ListDictionary.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Specialized.ListDictionary.Count
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Count
  nameWithType: ListDictionary.Count
  fullName: System.Collections.Specialized.ListDictionary.Count
- uid: System.Collections.Specialized.ListDictionary.GetEnumerator
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: GetEnumerator()
  nameWithType: ListDictionary.GetEnumerator()
  fullName: System.Collections.Specialized.ListDictionary.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Specialized.ListDictionary.IsFixedSize
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsFixedSize
  nameWithType: ListDictionary.IsFixedSize
  fullName: System.Collections.Specialized.ListDictionary.IsFixedSize
- uid: System.Collections.Specialized.ListDictionary.IsReadOnly
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsReadOnly
  nameWithType: ListDictionary.IsReadOnly
  fullName: System.Collections.Specialized.ListDictionary.IsReadOnly
- uid: System.Collections.Specialized.ListDictionary.IsSynchronized
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsSynchronized
  nameWithType: ListDictionary.IsSynchronized
  fullName: System.Collections.Specialized.ListDictionary.IsSynchronized
- uid: System.Collections.Specialized.ListDictionary.Item(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Item(Object)
  nameWithType: ListDictionary.Item(Object)
  fullName: System.Collections.Specialized.ListDictionary.Item(Object)
- uid: System.Collections.Specialized.ListDictionary.Keys
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Keys
  nameWithType: ListDictionary.Keys
  fullName: System.Collections.Specialized.ListDictionary.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Specialized.ListDictionary.Remove(System.Object)
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Remove(Object)
  nameWithType: ListDictionary.Remove(Object)
  fullName: System.Collections.Specialized.ListDictionary.Remove(Object)
- uid: System.Collections.Specialized.ListDictionary.SyncRoot
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: SyncRoot
  nameWithType: ListDictionary.SyncRoot
  fullName: System.Collections.Specialized.ListDictionary.SyncRoot
- uid: System.Collections.Specialized.ListDictionary.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ListDictionary.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Specialized.ListDictionary.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Specialized.ListDictionary.Values
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Values
  nameWithType: ListDictionary.Values
  fullName: System.Collections.Specialized.ListDictionary.Values
- uid: System.Collections.Specialized.ListDictionary.#ctor*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: ListDictionary
  nameWithType: ListDictionary.ListDictionary
- uid: System.Collections.Specialized.ListDictionary.Add*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Add
  nameWithType: ListDictionary.Add
- uid: System.Collections.Specialized.ListDictionary.Clear*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Clear
  nameWithType: ListDictionary.Clear
- uid: System.Collections.Specialized.ListDictionary.Contains*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Contains
  nameWithType: ListDictionary.Contains
- uid: System.Collections.Specialized.ListDictionary.CopyTo*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: CopyTo
  nameWithType: ListDictionary.CopyTo
- uid: System.Collections.Specialized.ListDictionary.Count*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Count
  nameWithType: ListDictionary.Count
- uid: System.Collections.Specialized.ListDictionary.GetEnumerator*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: GetEnumerator
  nameWithType: ListDictionary.GetEnumerator
- uid: System.Collections.Specialized.ListDictionary.IsFixedSize*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsFixedSize
  nameWithType: ListDictionary.IsFixedSize
- uid: System.Collections.Specialized.ListDictionary.IsReadOnly*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsReadOnly
  nameWithType: ListDictionary.IsReadOnly
- uid: System.Collections.Specialized.ListDictionary.IsSynchronized*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: IsSynchronized
  nameWithType: ListDictionary.IsSynchronized
- uid: System.Collections.Specialized.ListDictionary.Item*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Item
  nameWithType: ListDictionary.Item
- uid: System.Collections.Specialized.ListDictionary.Keys*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Keys
  nameWithType: ListDictionary.Keys
- uid: System.Collections.Specialized.ListDictionary.Remove*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Remove
  nameWithType: ListDictionary.Remove
- uid: System.Collections.Specialized.ListDictionary.SyncRoot*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: SyncRoot
  nameWithType: ListDictionary.SyncRoot
- uid: System.Collections.Specialized.ListDictionary.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: ListDictionary.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Specialized.ListDictionary.Values*
  parent: System.Collections.Specialized.ListDictionary
  isExternal: false
  name: Values
  nameWithType: ListDictionary.Values
