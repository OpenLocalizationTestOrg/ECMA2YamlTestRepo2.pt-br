### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyObject
  id: DependencyObject
  children:
  - System.Windows.DependencyObject.#ctor
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  langs:
  - csharp
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
  type: Class
  summary: "Representa um objeto que participa do sistema de propriedade de dependência."
  remarks: "O classe DependencyObject permite que [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] serviços do sistema de propriedade em suas classes derivadas muitos.       Função primária do sistema de propriedade é para calcular os valores das propriedades e para fornecer a notificação do sistema sobre os valores que foram alterados. Outra classe de chave que participa do sistema de propriedade é <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> <xref:System.Windows.DependencyProperty>Habilita o registro das propriedades de dependência para o sistema de propriedade e fornece informações sobre cada propriedade de dependência e identificação enquanto DependencyObject como uma classe base permite que os objetos para usar as propriedades de dependência.</xref:System.Windows.DependencyProperty>       Serviços de DependencyObject e características incluem o seguinte:-suporte à hospedagem de uma propriedade de dependência. Registrar uma propriedade de dependência chamando o <xref:System.Windows.DependencyProperty.Register%2A>método e armazenar o valor de retorno do método como um campo estático público na sua classe.</xref:System.Windows.DependencyProperty.Register%2A>      -Suporte à hospedagem de propriedade anexada. Registrar uma propriedade anexada ao chamar o <xref:System.Windows.DependencyProperty.RegisterAttached%2A>método e armazenar o valor de retorno do método como um campo estático público somente leitura na sua classe.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> (Também há requisitos adicionais de membro; Observe que isso representa um [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implementação específica para propriedades anexadas. Para obter detalhes, consulte [visão geral de propriedades anexado](~/add/includes/ajax-current-ext-md.md).) A propriedade anexada, em seguida, pode ser definida em qualquer classe derivada de DependencyObject.      -Obter, definir e limpar os métodos de utilitário para valores de qualquer propriedade de dependência que existe no DependencyObject.      -Metadados, forçar o suporte de valor, a propriedade alterada notificação e retornos de chamada de substituição de propriedade de dependência ou propriedades anexadas. Além disso, a classe DependencyObject facilita os metadados de propriedade por proprietário de uma propriedade de dependência.      -Uma classe base comum para classes derivadas de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, ou <xref:System.Windows.Media.Visual>.</xref:System.Windows.Media.Visual> </xref:System.Windows.Freezable> </xref:System.Windows.ContentElement> (<xref:System.Windows.UIElement>, outra classe de base do elemento, tem uma hierarquia de classe inclui <xref:System.Windows.Media.Visual>.)</xref:System.Windows.Media.Visual> </xref:System.Windows.UIElement>"
  example:
  - "The following example derives from DependencyObject to create a new abstract class. The class then registers an attached property and includes support members for that attached property.  \n  \n [!code-cs[WPFAquariumSln#DOMain](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#domain)]\n [!code-vb[WPFAquariumSln#DOMain](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#domain)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))]

      [System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))]

      public class DependencyObject : System.Windows.Threading.DispatcherObject
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements: []
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.DependencyObject.#ctor
  id: '#ctor'
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: DependencyObject()
  nameWithType: DependencyObject.DependencyObject()
  fullName: System.Windows.DependencyObject.DependencyObject()
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> classe."
  syntax:
    content: public DependencyObject ();
    parameters: []
  overload: System.Windows.DependencyObject.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  id: ClearValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ClearValue(DependencyProperty)
  nameWithType: DependencyObject.ClearValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Limpa o valor local de uma propriedade. A propriedade a ser apagado é especificada por um <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador."
  remarks: "Limpar o valor da propriedade chamando ClearValue não necessariamente dá uma propriedade de dependência o valor padrão especificado nos metadados de propriedade de dependência. Limpando a propriedade somente especificamente limpa qualquer valor local pode ter sido aplicada. Para obter mais informações, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example iterates all properties that have local values set on an object, then calls ClearValue to clear the values of each such property.  \n  \n [!code-cs[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/csharp/DPClearValue/default.xaml.cs#iteratelocalvaluesandclear)]\n [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/visualbasic/DPClearValue/default.xaml.vb#iteratelocalvaluesandclear)]"
  syntax:
    content: public void ClearValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade de dependência a ser limpo, identificado por um <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> referência de objeto."
  overload: System.Windows.DependencyObject.ClearValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tentativa de chamar ClearValue em um lacrado <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  id: ClearValue(System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ClearValue(DependencyPropertyKey)
  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Limpa o valor local de uma propriedade somente leitura. A propriedade a ser apagado é especificada por um <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref>."
  remarks: "Um <xref:System.Windows.DependencyPropertyKey>identifica uma propriedade de dependência somente leitura para operações do sistema de propriedade.</xref:System.Windows.DependencyPropertyKey> Classes que definem as propriedades de dependência somente leitura não devem expor essa chave com acesso público. Uma chave exposta publicamente deve fornecer um caminho de código público que negadas o caractere de somente leitura da propriedade, se métodos como <xref:System.Windows.DependencyObject.ClearValue%2A>ou <xref:System.Windows.DependencyObject.SetValue%2A>poderia ser chamado de fora da classe ou assembly, a chave de referência.</xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.ClearValue%2A>       Limpar o valor da propriedade chamando ClearValue não necessariamente dá uma propriedade de dependência o valor padrão especificado nos metadados de propriedade de dependência. O valor de compensação somente especificamente limpa qualquer valor local pode ter sido aplicada. Para obter mais informações, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void ClearValue (System.Windows.DependencyPropertyKey key);
    parameters:
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "A chave para a propriedade de dependência a ser apagada."
  overload: System.Windows.DependencyObject.ClearValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tentativa de chamar <xref:System.Windows.DependencyObject.ClearValue*>em um lacrado <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>.</xref:System.Windows.DependencyObject.ClearValue*>"
  platform:
  - net462
- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  id: CoerceValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: CoerceValue(DependencyProperty)
  nameWithType: DependencyObject.CoerceValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.CoerceValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Converte o valor da propriedade de dependência especificada. Isso é feito por invocar qualquer <xref href=&quot;System.Windows.CoerceValueCallback&quot;> </xref> especificada nos metadados de propriedade para a propriedade de dependência conforme ela existe em chamada de função <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  remarks: "Além do que está sendo invocada explicitamente por meio de chamada Valorforçado, o <xref:System.Windows.CoerceValueCallback>de uma dependência de propriedade é também chamada internamente sempre que o valor da propriedade de dependência está sendo avaliado novamente pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema de propriedade.</xref:System.Windows.CoerceValueCallback>       Quando você chama o método Valorforçado, você está invocando, por fim, o retorno de chamada de valor forçados para a propriedade que você especificar. Normalmente, você vai invocar Valorforçado somente se você souber que um retorno de chamada de valor forçados existe e se você souber os critérios do retorno de chamada de coerção.       É o cenário mais comum para chamar Valorforçado dentro de tratamento de classe ou retornos de chamada de alteração de propriedade de propriedades relacionadas que influenciam uns dos outros valores de uma maneira dependente. Para obter mais informações, consulte [retornos de chamada de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example calls CoerceValue within a <xref:System.Windows.PropertyChangedCallback> implementation that is used as the <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> for a different dependency properties on the same class. This is a common pattern for introducing true value dependencies between dependency properties.  \n  \n [!code-cs[DPCallbackOverride#OnPCCurrent](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#onpccurrent)]\n [!code-vb[DPCallbackOverride#OnPCCurrent](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#onpccurrent)]"
  syntax:
    content: public void CoerceValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O identificador para a propriedade de dependência forçar."
  overload: System.Windows.DependencyObject.CoerceValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Especificado <code> dp </code> ou seu valor eram inválido ou não existe."
  platform:
  - net462
- uid: System.Windows.DependencyObject.DependencyObjectType
  id: DependencyObjectType
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
  fullName: System.Windows.DependencyObject.DependencyObjectType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o <xref href=&quot;System.Windows.DependencyObjectType&quot;> </xref> que encapsula o [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tipo dessa instância."
  remarks: "Essa propriedade é útil se um objeto que é retornado de um método tem um tipo de valor de retorno de <xref:System.Windows.DependencyObject>e você deseja executar a propriedade sistema operações específicas nele dependendo de seu tipo.</xref:System.Windows.DependencyObject> Por exemplo é mais eficiente chamar <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29>usando o <xref:System.Windows.DependencyObjectType>em vez de [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tipo.</xref:System.Windows.DependencyObjectType> </xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> <xref:System.Windows.DependencyObjectType>facilita a pesquisa mais rápida.</xref:System.Windows.DependencyObjectType>"
  example:
  - "In the following pseudocode example, `MySubClass` anticipates that additional derived classes might change the default value of the `MyCustom` dependency property. The class implements a default constructor that can determine the actual derived class by taking advantage of polymorphism on the <xref:System.Windows.DependencyObjectType> value whenever that constructor is used as a derived class instantiator.  \n  \n `public DOClass() : base()`  \n  \n `{`  \n  \n `__customPropertyCache = (CustomDP)`  \n  \n `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  \n  \n `}`"
  syntax:
    content: public System.Windows.DependencyObjectType DependencyObjectType { get; }
    return:
      type: System.Windows.DependencyObjectType
      description: "Um <xref href=&quot;System.Windows.DependencyObjectType&quot;> </xref> que encapsula o [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tipo dessa instância."
  overload: System.Windows.DependencyObject.DependencyObjectType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: DependencyObject.Equals(Object)
  fullName: System.Windows.DependencyObject.Equals(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Determina se um fornecido <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> é equivalente à atual <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  remarks: "Essa implementação é apenas a igualdade de referência e não tenta avaliar a igualdade de valor das propriedades contidas."
  syntax:
    content: public override sealed bool Equals (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "O <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> para comparar com a instância atual."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se as duas instâncias forem iguais. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyObject.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyObject.GetHashCode()
  fullName: System.Windows.DependencyObject.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um código hash para este <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  syntax:
    content: public override sealed int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Um código de hash de inteiro de 32 bits com sinal."
  overload: System.Windows.DependencyObject.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator
  id: GetLocalValueEnumerator
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetLocalValueEnumerator()
  nameWithType: DependencyObject.GetLocalValueEnumerator()
  fullName: System.Windows.DependencyObject.GetLocalValueEnumerator()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Cria um enumerador especializado para determinar quais propriedades de dependência localmente definiu valores neste <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  remarks: "Um *valor local* é qualquer valor de propriedade de dependência que foi definido por <xref:System.Windows.DependencyObject.SetValue%2A>, ao contrário de outros aspectos do sistema de propriedades.</xref:System.Windows.DependencyObject.SetValue%2A>       O <xref:System.Windows.LocalValueEnumerator>obtido chamando GetLocalValueEnumerator pode ser usado para enumerar as propriedades que têm definidos localmente valor em uma <xref:System.Windows.DependencyObject>instância.</xref:System.Windows.DependencyObject> </xref:System.Windows.LocalValueEnumerator> Cada uma dessas propriedades é representada no enumerador por um <xref:System.Windows.LocalValueEntry>objeto, que tem propriedades que fazem referência a específica <xref:System.Windows.DependencyProperty>e seus valores.</xref:System.Windows.DependencyProperty> </xref:System.Windows.LocalValueEntry> Essa técnica de enumeração pelo definido localmente valores podem ser usados para a otimização ou para outros tratamento de valores locais, por exemplo, para determinar quais valores de propriedade de um <xref:System.Windows.DependencyObject>alteraria se eles foram limpas.</xref:System.Windows.DependencyObject>      > [!IMPORTANT] > Retornado <xref:System.Windows.LocalValueEnumerator>pode conter <xref:System.Windows.LocalValueEntry>registros de propriedades de dependência são somente leitura, ou onde os valores são calculados pelo sistema de propriedades de propriedades de dependência.</xref:System.Windows.LocalValueEntry> </xref:System.Windows.LocalValueEnumerator> Por exemplo, um elemento de estrutura visual que tem uma largura estabelecida por meio de layout relatará um valor local para <xref:System.Windows.FrameworkElement.ActualWidth%2A>.</xref:System.Windows.FrameworkElement.ActualWidth%2A> Se você estiver obtendo valores locais para redefini-los, verifique o <xref:System.Windows.DependencyProperty.ReadOnly%2A>valor o identificador de propriedade de cada <xref:System.Windows.LocalValueEntry>para verificar se o <xref:System.Windows.DependencyProperty>em questão não é somente leitura.</xref:System.Windows.DependencyProperty> </xref:System.Windows.LocalValueEntry> </xref:System.Windows.DependencyProperty.ReadOnly%2A>"
  example:
  - "The following example iterates all properties that have local values set on an object, then calls <xref:System.Windows.DependencyObject.ClearValue%2A> to clear the values of each such property.  \n  \n [!code-cs[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/csharp/DPClearValue/default.xaml.cs#iteratelocalvaluesandclear)]\n [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/add/codesnippet/visualbasic/DPClearValue/default.xaml.vb#iteratelocalvaluesandclear)]"
  syntax:
    content: public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();
    parameters: []
    return:
      type: System.Windows.LocalValueEnumerator
      description: "Um enumerador de valor local especializadas."
  overload: System.Windows.DependencyObject.GetLocalValueEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  id: GetValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: GetValue(DependencyProperty)
  nameWithType: DependencyObject.GetValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.GetValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna o valor efetivo atual de uma propriedade de dependência na instância de um <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  remarks: "O *valor efetivo* é o valor da propriedade que é retornado pelo sistema de propriedades para qualquer chamador que está solicitando o valor. O valor efetivo é o resultado do sistema propriedade tendo avaliada todas as entradas possíveis que integram a precedência de valor do sistema de propriedade. Isso inclui a coerção e animação. Para obter mais informações, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md).       Esse método retornará nunca <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> O <xref:System.Windows.DependencyProperty>é um valor de sentinela para o sistema de propriedade que é usado em várias capacidades internamente e ocasionalmente também expostas por meio de retornos de chamada de coerção.</xref:System.Windows.DependencyProperty>       Se você não tiver certeza qual deve ser o tipo da propriedade, você pode consultar o identificador da propriedade de dependência solicitado para determinar se há um determinado mais <xref:System.Windows.DependencyProperty.PropertyType%2A>que o valor de retorno pode ser convertido em.</xref:System.Windows.DependencyProperty.PropertyType%2A>"
  syntax:
    content: public object GetValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador de propriedade para recuperar o valor."
    return:
      type: System.Object
      description: "Retorna o valor efetivo atual."
  overload: System.Windows.DependencyObject.GetValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Especificado <code> dp </code> ou seu valor era inválido ou especificado <code> dp </code> não existe."
  platform:
  - net462
- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  id: InvalidateProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: InvalidateProperty(DependencyProperty)
  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.InvalidateProperty(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Novamente, avalia o valor efetivo para a propriedade de dependência especificada"
  remarks: "Quando você chama InvalidateProperty, qualquer aplicável e associado <xref:System.Windows.CoerceValueCallback>ou <xref:System.Windows.PropertyChangedCallback>funções registrado para essa propriedade de dependência pode ser invocada.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback>       Chamar InvalidateProperty em uma propriedade que tem seu valor local definido não terá efeito, porque o valor local tem precedência sobre outras entradas de sistema de propriedade, com exceção de animações. No entanto, você poderia chamar <xref:System.Windows.DependencyObject.ClearValue%2A>, em seguida, chame InvalidateProperty.</xref:System.Windows.DependencyObject.ClearValue%2A> Para obter mais informações, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md).       Chamar InvalidateProperty não é necessariamente aplicável para muitos cenários de propriedade de dependência. Se uma propriedade de dependência se torna invalidada devido a alterações de valor em qualquer um dos constituintes, o sistema de propriedade invalida e reavalia a propriedade de dependência automaticamente. No entanto, ainda existem alguns cenários apropriados onde InvalidateProperty é útil. Em particular, você pode usar InvalidateProperty dentro de forçados valor ou a propriedade alterada retorno de chamada para uma propriedade de dependência diferentes. Você também pode usar InvalidateProperty para forçar a reavaliação de uma associação em uma fonte de dados que não é capaz de implementar recomendada <xref:System.ComponentModel.INotifyPropertyChanged>mecanismo de notificação (talvez se o consumo de classes de dados que não pode ser derivado, ou onde os dados são um membro estático).</xref:System.ComponentModel.INotifyPropertyChanged>"
  example:
  - "The following example calls InvalidateProperty on a custom property, whenever properties that are involved in the invalidated property's calculations change. This is an alternative technique to calling the <xref:System.Windows.DependencyObject.CoerceValue%2A> method, because invalidating the property will also call any registered <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  \n  \n [!code-cs[PropertySystemEsoterics#InvalidateProperty](~/add/codesnippet/csharp/PropertySystemEsoterics/SDKSampleLibrary/class1.cs#invalidateproperty)]\n [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/add/codesnippet/visualbasic/PropertySystemEsoterics.sdksamplelibrary/class1.vb#invalidateproperty)]"
  syntax:
    content: public void InvalidateProperty (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador de propriedade para invalidar."
  overload: System.Windows.DependencyObject.InvalidateProperty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.IsSealed
  id: IsSealed
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
  fullName: System.Windows.DependencyObject.IsSealed
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um valor que indica se esta instância atualmente está lacrada (somente leitura)."
  remarks: "Esse valor é definido internamente."
  syntax:
    content: public bool IsSealed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esta instância for fechada; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyObject.IsSealed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Invocado sempre que o valor efetivo de qualquer propriedade de dependência sobre isso <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> foi atualizado. A propriedade de dependência específicas alterada é relatada nos dados do evento."
  remarks: "Esse método não deve geralmente detectar alterações de propriedade individuais ou executar invalidações de propriedades em uma base por caso. OnPropertyChanged em vez disso, é destinado modificações do padrão de invalidação geral, se for conhecidas certas informações sobre classificações de largura de propriedades. Por exemplo, alterações em um <xref:System.Windows.Freezable>alterações nos tipos de valor de <xref:System.Windows.Freezable>, ou pode ser subpropriedades, onde as alterações são dentro de outras <xref:System.Windows.Freezable>referências.</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> </xref:System.Windows.Freezable> O <xref:System.Windows.Freezable>implementação de substituição de OnPropertyChanged usa informações internas para determinar se as propriedades são subpropriedades e fornece lógica de classe base apropriada para ambos os casos.</xref:System.Windows.Freezable>       OnPropertyChanged potencialmente é chamado várias vezes durante a vida de um objeto. Portanto, você pode obter um melhor desempenho para o sistema de propriedade geral se você substituir os metadados de propriedades específicas e, em seguida, anexa <xref:System.Windows.CoerceValueCallback>ou <xref:System.Windows.PropertyChangedCallback>funções de propriedades individuais.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> No entanto, você usaria esse método se um <xref:System.Windows.DependencyObject>inclui um número significativo de propriedades de dependência inter-relacionados de valor, ou se ele inclui lógica, como o comportamento de renderização que deve ser executado novamente para vários casos de invalidações de propriedade de relacionados.</xref:System.Windows.DependencyObject>"
  syntax:
    content: protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "Dados de evento que contém o identificador de propriedade de dependência de interesse, os metadados para o tipo de propriedade e valores novos e antigos."
  overload: System.Windows.DependencyObject.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  id: ReadLocalValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ReadLocalValue(DependencyProperty)
  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ReadLocalValue(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna o valor de local de uma propriedade de dependência, se ele existir."
  remarks: "Você deve usar <xref:System.Windows.DependencyObject.GetValue%2A>para operações mais comuns de &quot;get&quot; para uma propriedade de dependência.</xref:System.Windows.DependencyObject.GetValue%2A> ReadLocalValue não retorna o valor efetivo para uma variedade de circunstâncias em que o valor localmente não foi definido.       Os valores que são definidos por estilos, temas, modelos, o valor padrão de metadados ou herança de valor de propriedade não são considerados valores local. No entanto, associações e outras expressões são considerados valores locais, depois que eles tenham sido avaliados.       Quando nenhum valor local é definido, esse método retorna <xref:System.Windows.DependencyProperty.UnsetValue>.</xref:System.Windows.DependencyProperty.UnsetValue>       Se o valor retornado for diferente de <xref:System.Windows.DependencyProperty.UnsetValue>, você pode consultar os metadados da propriedade de dependência solicitado para determinar se há um tipo mais específico que o valor de retorno pode ser convertido em.</xref:System.Windows.DependencyProperty.UnsetValue>"
  syntax:
    content: public object ReadLocalValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador de propriedade para recuperar o valor."
    return:
      type: System.Object
      description: "Retorna o valor local ou retorna o valor de sentinela <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> se nenhum valor local é definido."
  overload: System.Windows.DependencyObject.ReadLocalValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  id: SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetCurrentValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetCurrentValue(DependencyProperty,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Define o valor da propriedade de dependência sem alterar seu valor."
  remarks: "Esse método é usado por um componente que define programaticamente o valor de uma de suas próprias propriedades sem desabilitar o uso de um aplicativo declarado da propriedade. O método SetCurrentValue altera o valor efetivo de propriedade, mas os gatilhos existentes, associações de dados, e estilos continuarão a funcionar."
  syntax:
    content: public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O identificador para definir a propriedade de dependência."
    - id: value
      type: System.Object
      description: "O novo valor local."
  overload: System.Windows.DependencyObject.SetCurrentValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tentativa de modificar uma propriedade de dependência somente leitura ou uma propriedade em um lacrado <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>value</code>não era do tipo correto conforme registrado para o <code>dp</code> propriedade."
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  id: SetValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyProperty,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Define o valor de local de uma propriedade de dependência, especificado por seu identificador de propriedade de dependência."
  remarks: "Se o tipo fornecido não coincide com o tipo que é declarado para a propriedade de dependência conforme ela foi originalmente registrada, uma exceção será lançada. O `value` parâmetro sempre deve ser fornecido como o tipo apropriado.       As condições de exceção potencialmente são influenciadas pelo <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>retorno de chamada que existe no identificador de propriedade de dependência da propriedade de dependência que está sendo definido.</xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Caso contrário, o valor fornecido poderia estar falhando condições gerais de verificação de tipo (por exemplo, passando uma cadeia de caracteres quando o tipo nativo é Double)."
  syntax:
    content: public void SetValue (System.Windows.DependencyProperty dp, object value);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O identificador para definir a propriedade de dependência."
    - id: value
      type: System.Object
      description: "O novo valor local."
  overload: System.Windows.DependencyObject.SetValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tentativa de modificar uma propriedade de dependência somente leitura ou uma propriedade em um lacrado <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>value</code>não era do tipo correto conforme registrado para o <code>dp</code> propriedade."
  platform:
  - net462
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  id: SetValue(System.Windows.DependencyPropertyKey,System.Object)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: SetValue(DependencyPropertyKey,Object)
  nameWithType: DependencyObject.SetValue(DependencyPropertyKey,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyPropertyKey,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Define o valor de local de uma propriedade de dependência somente leitura, especificada pelo <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> identificador de propriedade de dependência."
  remarks: "Esta assinatura geralmente é usada quando você definir valores para propriedades de dependência somente leitura que são definidos por suas classes personalizadas. Em geral, SetValue é chamado apenas do tipo registrado a propriedade de dependência, que implementa a lógica interna que fornece o valor determinado para a propriedade de dependência. Para obter mais informações, consulte [propriedades de dependência somente leitura](~/add/includes/ajax-current-ext-md.md).       Se o tipo fornecido não coincide com o tipo que é declarado para a propriedade de dependência conforme ela foi originalmente registrada, uma exceção será lançada. O `value` parâmetro sempre deve ser fornecido como o tipo apropriado. As condições de exceção potencialmente são influenciadas pelo <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>retorno de chamada que existe no identificador de propriedade de dependência da propriedade de dependência que está sendo definido.</xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>"
  example:
  - "The following example defines a read-only dependency property, along with a `public static readonly` <xref:System.Windows.DependencyProperty> that provides necessary read-only exposure to property consumers, and the get accessor for the [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrapper.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public void SetValue (System.Windows.DependencyPropertyKey key, object value);
    parameters:
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "O <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> identificador da propriedade a ser definido."
    - id: value
      type: System.Object
      description: "O novo valor local."
  overload: System.Windows.DependencyObject.SetValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  id: ShouldSerializeProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  langs:
  - csharp
  name: ShouldSerializeProperty(DependencyProperty)
  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.ShouldSerializeProperty(DependencyProperty)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retorna um valor que indica se os processos de serialização devem serializar o valor da propriedade de dependência fornecido."
  remarks: "A implementação padrão retorna `true` para todos os casos em que uma propriedade de dependência tinha um valor local estabelecido em <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject>"
  syntax:
    content: protected virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O identificador para a propriedade de dependência deve ser serializado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência que é fornecida deve ser serializado valor; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyObject.ShouldSerializeProperty*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyObject.#ctor
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObject()
  nameWithType: DependencyObject.DependencyObject()
  fullName: System.Windows.DependencyObject.DependencyObject()
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue(DependencyProperty)
  nameWithType: DependencyObject.ClearValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyProperty)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue(DependencyPropertyKey)
  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)
  fullName: System.Windows.DependencyObject.ClearValue(DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: CoerceValue(DependencyProperty)
  nameWithType: DependencyObject.CoerceValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.CoerceValue(DependencyProperty)
- uid: System.Windows.DependencyObject.DependencyObjectType
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
  fullName: System.Windows.DependencyObject.DependencyObjectType
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyObject.Equals(System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: Equals(Object)
  nameWithType: DependencyObject.Equals(Object)
  fullName: System.Windows.DependencyObject.Equals(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.DependencyObject.GetHashCode
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyObject.GetHashCode()
  fullName: System.Windows.DependencyObject.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetLocalValueEnumerator()
  nameWithType: DependencyObject.GetLocalValueEnumerator()
  fullName: System.Windows.DependencyObject.GetLocalValueEnumerator()
- uid: System.Windows.LocalValueEnumerator
  parent: System.Windows
  isExternal: false
  name: LocalValueEnumerator
  nameWithType: LocalValueEnumerator
  fullName: System.Windows.LocalValueEnumerator
- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetValue(DependencyProperty)
  nameWithType: DependencyObject.GetValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.GetValue(DependencyProperty)
- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: InvalidateProperty(DependencyProperty)
  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.InvalidateProperty(DependencyProperty)
- uid: System.Windows.DependencyObject.IsSealed
  parent: System.Windows.DependencyObject
  isExternal: false
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
  fullName: System.Windows.DependencyObject.IsSealed
- uid: System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ReadLocalValue(DependencyProperty)
  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)
  fullName: System.Windows.DependencyObject.ReadLocalValue(DependencyProperty)
- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetCurrentValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetCurrentValue(DependencyProperty,Object)
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue(DependencyProperty,Object)
  nameWithType: DependencyObject.SetValue(DependencyProperty,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyProperty,Object)
- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue(DependencyPropertyKey,Object)
  nameWithType: DependencyObject.SetValue(DependencyPropertyKey,Object)
  fullName: System.Windows.DependencyObject.SetValue(DependencyPropertyKey,Object)
- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ShouldSerializeProperty(DependencyProperty)
  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)
  fullName: System.Windows.DependencyObject.ShouldSerializeProperty(DependencyProperty)
- uid: System.Windows.DependencyObject.#ctor*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject.DependencyObject
- uid: System.Windows.DependencyObject.ClearValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ClearValue
  nameWithType: DependencyObject.ClearValue
- uid: System.Windows.DependencyObject.CoerceValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: CoerceValue
  nameWithType: DependencyObject.CoerceValue
- uid: System.Windows.DependencyObject.DependencyObjectType*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObject.DependencyObjectType
- uid: System.Windows.DependencyObject.Equals*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: Equals
  nameWithType: DependencyObject.Equals
- uid: System.Windows.DependencyObject.GetHashCode*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyObject.GetHashCode
- uid: System.Windows.DependencyObject.GetLocalValueEnumerator*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetLocalValueEnumerator
  nameWithType: DependencyObject.GetLocalValueEnumerator
- uid: System.Windows.DependencyObject.GetValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: GetValue
  nameWithType: DependencyObject.GetValue
- uid: System.Windows.DependencyObject.InvalidateProperty*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: InvalidateProperty
  nameWithType: DependencyObject.InvalidateProperty
- uid: System.Windows.DependencyObject.IsSealed*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: IsSealed
  nameWithType: DependencyObject.IsSealed
- uid: System.Windows.DependencyObject.OnPropertyChanged*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: OnPropertyChanged
  nameWithType: DependencyObject.OnPropertyChanged
- uid: System.Windows.DependencyObject.ReadLocalValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ReadLocalValue
  nameWithType: DependencyObject.ReadLocalValue
- uid: System.Windows.DependencyObject.SetCurrentValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetCurrentValue
  nameWithType: DependencyObject.SetCurrentValue
- uid: System.Windows.DependencyObject.SetValue*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: SetValue
  nameWithType: DependencyObject.SetValue
- uid: System.Windows.DependencyObject.ShouldSerializeProperty*
  parent: System.Windows.DependencyObject
  isExternal: false
  name: ShouldSerializeProperty
  nameWithType: DependencyObject.ShouldSerializeProperty
