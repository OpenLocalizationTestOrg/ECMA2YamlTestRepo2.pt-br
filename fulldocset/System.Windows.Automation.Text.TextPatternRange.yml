### YamlMime:ManagedReference
items:
- uid: System.Windows.Automation.Text.TextPatternRange
  id: TextPatternRange
  children:
  - System.Windows.Automation.Text.TextPatternRange.AddToSelection
  - System.Windows.Automation.Text.TextPatternRange.Clone
  - System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  - System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  - System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  - System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  - System.Windows.Automation.Text.TextPatternRange.GetChildren
  - System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  - System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  - System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.Select
  - System.Windows.Automation.Text.TextPatternRange.TextPattern
  langs:
  - csharp
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
  type: Class
  summary: "Representa um intervalo de texto contínuo em uma <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> contêiner."
  remarks: "Um TextPatternRange pode representar um ponto de inserção, um subconjunto ou todo o texto em uma <xref:System.Windows.Automation.TextPattern>contêiner.</xref:System.Windows.Automation.TextPattern>       Um TextPatternRange se tornarão inválido se ocorrer um dos seguintes: o texto no <xref:System.Windows.Automation.TextPattern>alterações contêiner devido a alguma atividade de usuário, ou o <xref:System.Windows.Automation.ValuePattern.SetValue%2A>método <xref:System.Windows.Automation.ValuePattern>é usado para alterar programaticamente o valor do texto no <xref:System.Windows.Automation.TextPattern>contêiner.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.ValuePattern> </xref:System.Windows.Automation.ValuePattern.SetValue%2A> </xref:System.Windows.Automation.TextPattern>"
  syntax:
    content: public class TextPatternRange
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  id: AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Adiciona à coleção do texto realçado em um contêiner de texto que dá suporte a vários, seleções de separação."
  remarks: "Move o ponto de inserção de texto para a área da nova seleção.       Fornece um intervalo de texto degenerado move o ponto de inserção."
  syntax:
    content: public void AddToSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Se o provedor de texto não oferece suporte a várias seleções de disjunção (por exemplo, <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>deve ter um valor de <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  id: Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Recupera um novo <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> idêntico ao valor original <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> e herança de todas as propriedades do original."
  remarks: "Como alternativa, crie um novo <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>do <xref:System.Windows.Automation.TextPattern>e mover os dois pontos de extremidade para corresponder com os pontos de extremidade do intervalo de texto original.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.TextPattern.DocumentRange%2A>       O novo intervalo de pode ser manipulado de forma independente do original."
  example:
  - "[!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  \n  \n [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange Clone ();
    parameters: []
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "O novo intervalo de texto. Uma referência nula (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> em [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]) nunca é retornada."
  overload: System.Windows.Automation.Text.TextPatternRange.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  id: Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna um <xref:System.Boolean>valor que indica se o alcance (o <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ponto de extremidade para o <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ponto de extremidade) de um texto intervalo for igual a outro intervalo de texto.</xref:System.Boolean>"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  \n  \n [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]"
  syntax:
    content: public bool Compare (System.Windows.Automation.Text.TextPatternRange range);
    parameters:
    - id: range
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Um intervalo de texto a ser comparado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o alcance dos dois intervalos de texto é idêntico; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Automation.Text.TextPatternRange.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Se o intervalo que estão sendo comparado não são provenientes do mesmo fornecedor de texto."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna um <xref:System.Int32>que indica se dois intervalos de texto têm pontos de extremidade idênticos.</xref:System.Int32>"
  remarks: "Comparando os pontos de extremidade iniciais e final do mesmo intervalo de texto, você pode identificar se um intervalo de texto é degenerado ou se os pontos de extremidade estão na ordem de fluxo lógico de texto."
  example:
  - "[!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  \n  \n [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]"
  syntax:
    content: public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "O <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ou <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ponto de extremidade do chamador."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "O intervalo de destino para comparação."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "O <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ou <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> ponto de extremidade de destino."
    return:
      type: System.Int32
      description: "Retorna um valor negativo se o ponto de extremidade do chamador ocorre anteriormente no texto que o ponto de extremidade de destino.       Retorna zero se o ponto de extremidade do chamador está no mesmo local que o ponto de extremidade de destino.       Retorna um valor positivo se o ponto de extremidade do chamador ocorre posteriormente no texto que o ponto de extremidade de destino."
  overload: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Se o intervalo for uma referência nula (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> em [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Se o intervalo é de outro contêiner."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  id: ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Expande o intervalo de texto especificado <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>."
  remarks: "Se o intervalo já tiver uma quantidade exata das unidades especificadas permanece inalterado.       Em ordem para o método ExpandToEnclosingUnit será executada com êxito, uma sequência de ações é executada em segundo plano.      1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade, tornando o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>supérfluo de ponto de extremidade.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, &quot;{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto&quot; onde &quot;{&quot; e &quot;}&quot; é pontos de extremidade do intervalo de texto.      2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>para o início da solicitados `unit` limite.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>pelo número solicitado de `unit` limites.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade por solicitado `unit` limite.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Ajustes de intervalo por Move ExpandToEnclosingUnit &](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;ajustes de intervalo por Move ExpandToEnclosingUnit &&quot;) exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit () > [!NOTE] > essas etapas são necessárias porque é comum para leitores de tela ler uma palavra, frase ou todo o parágrafo em qualquer posição de cursor virtual ou o ponto de inserção.       ExpandToEnclosingUnit respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>de visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       ExpandToEnclosingUnit transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit>com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit>não é suportado pelo controle.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       A ordem, da unidade menor ao maior, é listada abaixo.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  \n  \n [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]"
  syntax:
    content: public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "A unidade textual."
  overload: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  id: FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna um subconjunto do intervalo de texto que tem o valor de atributo especificado."
  remarks: "Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>para verificar a visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>para pesquisar todo o documento.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  \n  \n [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "O atributo a ser pesquisado."
    - id: value
      type: System.Object
      description: "O valor do atributo a ser pesquisado. Esse valor deve corresponder ao tipo especificado para o atributo."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Um intervalo de texto com um atributo correspondente e um valor de atributo; Caso contrário, nulo (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> em [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  id: FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna um subconjunto do intervalo de texto que contém o texto especificado."
  remarks: "Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>para verificar a visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>para pesquisar todo o documento.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  \n  \n [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);
    parameters:
    - id: text
      type: System.String
      description: "A cadeia de caracteres de texto a ser pesquisado."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o último intervalo de texto que está ocorrendo deve ser retornado em vez da primeira. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o caso deve ser ignorado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Um intervalo de texto o texto especificado; correspondente Caso contrário, nulo (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> em [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  id: GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna o valor do atributo especificado no intervalo de texto completo."
  remarks: "Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>para verificar a visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>"
  example:
  - "[!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  \n  \n [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]"
  syntax:
    content: public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "O atributo de texto."
    return:
      type: System.Object
      description: "Retorna o valor do atributo especificado. Por exemplo, GetAttributeValue(TextPattern.FontNameAttribute) retornaria uma cadeia de caracteres que representa o nome da fonte, se exclusivos, do intervalo de texto ao GetAttributeValue(TextPattern.IsItalicAttribute) retornaria um valor booleano.       Retorna <xref href=&quot;System.Windows.Automation.TextPattern.MixedAttributeValue&quot;> </xref> se o valor do atributo especificado varia ao longo do intervalo de texto.       Retorna <xref href=&quot;System.Windows.Automation.AutomationElement.NotSupported&quot;> </xref> se o atributo especificado não é compatível com o provedor ou o controle."
  overload: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Se o atributo especificado não é válido."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  id: GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Recupera uma coleção de delimitadora retângulos para cada linha total ou parcialmente visível de texto em um intervalo de texto."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  \n  \n [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]"
  syntax:
    content: public System.Windows.Rect[] GetBoundingRectangles ();
    parameters: []
    return:
      type: System.Windows.Rect[]
      description: "Uma matriz de delimitadora retângulos para cada linha de total ou parcial de texto em um intervalo de texto.       Uma matriz vazia para um intervalo de texto de degeneração.       Uma matriz vazia para um intervalo de texto que tem as coordenadas da tela colocá-lo completamente fora da tela, rolado para fora da exibição ou obscurecida por uma janela de sobreposição."
  overload: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  id: GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Recupera uma coleção de todos os objetos inseridos que estão dentro do intervalo de texto."
  remarks: ''
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]\n[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement[] GetChildren ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement[]
      description: "Uma coleção de todos os objetos filho que estão dentro do intervalo. Também serão incluídos na coleção de filhos que sobrepõem o intervalo, mas não são totalmente delimitados por ele.       Retorna uma coleção vazia se não houver nenhum objeto filho."
  overload: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  id: GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna o mais interno <xref href=&quot;System.Windows.Automation.AutomationElement&quot;> </xref> que inclui o intervalo de texto."
  remarks: "O delimitador <xref:System.Windows.Automation.AutomationElement>, normalmente o provedor de texto que fornece o intervalo de texto.</xref:System.Windows.Automation.AutomationElement> No entanto, se o provedor de texto oferece suporte a elementos filho, como tabelas ou hiperlinks, o elemento de fechamento pode ser um descendente do provedor de texto."
  example:
  - "[!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  \n  \n [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement GetEnclosingElement ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement
      description: "O elemento interno colocar o chamador."
  overload: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  id: GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Retorna o texto sem formatação do intervalo de texto."
  remarks: "GetText respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>de visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Se `maxLength` for maior que o comprimento da extensão de texto do chamador, a cadeia de caracteres retornada será o texto sem formatação do intervalo de texto.       GetText não será afetado pela ordem de pontos de extremidade no fluxo de texto; sempre retornará o texto entre os pontos de extremidade de início e término do intervalo de texto na ordem de fluxo lógico de texto."
  example:
  - "[!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  \n  \n [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]"
  syntax:
    content: public string GetText (int maxLength);
    parameters:
    - id: maxLength
      type: System.Int32
      description: "O comprimento máximo da cadeia de caracteres para retornar. Use `-1` se nenhum limite é necessário."
    return:
      type: System.String
      description: "O texto sem formatação do intervalo de texto, possivelmente truncado em especificado <code> maxLength </code>."
  overload: System.Windows.Automation.Text.TextPatternRange.GetText*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Se <code> maxLength </code> é menor que -1."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  id: Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Move o intervalo de texto, o número especificado de unidades de texto."
  remarks: "Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o método Move executar com êxito.      1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>supérfluo de ponto de extremidade.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, &quot;{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto&quot; onde &quot;{&quot; e &quot;}&quot; é pontos de extremidade do intervalo de texto.      2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>para o início da solicitados `unit` limite.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  O intervalo é movido para frente ou para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>pelo número solicitado de `unit` limites.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade por solicitado `unit` limite.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Ajustes de intervalo por Move ExpandToEnclosingUnit &](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;ajustes de intervalo por Move ExpandToEnclosingUnit &&quot;) exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit (), o conteúdo textual (ou texto interno) de um recipiente de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto único e contínuo em visualização de controle e exibição de conteúdo a [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário estiver recuperando o texto com a finalidade de citar, interpretar, ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser conseguido chamando <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>para obter um <xref:System.Windows.Automation.AutomationElement>para cada embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual tiver sido recuperado.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;Intervalos de texto abrangidos por objetos inseridos.&quot;)   Exemplo de um fluxo de texto com objetos inseridos e o intervalo abrange mover aspectos ambos ocultados e texto visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>de visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Mover transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit>com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit>não é suportado pelo controle.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       A ordem, da unidade menor ao maior, é listada abaixo.      - <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>> [!NOTE] > O texto não é alterado de alguma forma, como o intervalo de texto abrange apenas uma parte diferente do texto.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]\n[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]"
  syntax:
    content: public int Move (System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "O limite de unidade de texto."
    - id: count
      type: System.Int32
      description: "O número de unidades de texto para mover. Um valor positivo avança o intervalo de texto, um valor negativo move o intervalo de texto com versões anteriores e 0 não tem nenhum efeito."
    return:
      type: System.Int32
      description: "O número de unidades realmente movido. Isso pode ser menor que o número solicitado se qualquer um dos pontos de extremidade de intervalo de texto novo é maior ou menor do que o <xref:System.Windows.Automation.TextPattern.DocumentRange*>pontos de extremidade.</xref:System.Windows.Automation.TextPattern.DocumentRange*>"
  overload: System.Windows.Automation.Text.TextPatternRange.Move*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Move um ponto de extremidade de um intervalo de texto para o ponto de extremidade especificado de um segundo intervalo de texto."
  remarks: "Se o ponto de extremidade que está sendo movido cruza o outro ponto de extremidade do mesmo intervalo de texto e outro ponto de extremidade é movido também, resultando em um intervalo degenerado e garantir que a ordenação correta dos pontos de extremidade (ou seja, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>sempre é menor ou igual a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>).</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  \n  \n [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]"
  syntax:
    content: public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "O ponto de extremidade para mover."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Outro intervalo do mesmo provedor de texto."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "Um ponto de extremidade no outro intervalo."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  id: MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Move um ponto de extremidade do texto variar o número especificado de <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>s dentro do intervalo do documento."
  remarks: "Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas em segundo plano para que o <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>método seja executado com êxito.</xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>      1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido para um intervalo degenerado no <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>supérfluo de ponto de extremidade.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Essa etapa é necessária para remover ambiguidade em situações nas quais um intervalo de texto abrange `unit` limites; por exemplo, &quot;{a U} RL [http://www.microsoft.com](http://www.microsoft.com) é inserido no texto&quot; onde &quot;{&quot; e &quot;}&quot; é pontos de extremidade do intervalo de texto.      2.  O intervalo resultante é movido para trás no <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>para o início da solicitados `unit` limite.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  O intervalo é expandido de um estado de intervalo degenerado movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade por solicitado `unit` limite.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Ajustes de intervalo por Move ExpandToEnclosingUnit &](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;ajustes de intervalo por Move ExpandToEnclosingUnit &&quot;) exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit (), o conteúdo textual (ou texto interno) de um recipiente de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto único e contínuo em visualização de controle e exibição de conteúdo a [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário estiver recuperando o texto com a finalidade de citar, interpretar, ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser conseguido chamando <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>para obter um <xref:System.Windows.Automation.AutomationElement>para cada embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual tiver sido recuperado.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;Intervalos de texto abrangidos por objetos inseridos.&quot;)   Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes MoveEndpointByUnit transfere para o próximo maior <xref:System.Windows.Automation.Text.TextUnit>com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit>não é suportado pelo controle.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       A ordem, da unidade menor ao maior, é listada abaixo.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  \n  \n [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]"
  syntax:
    content: public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "O ponto de extremidade para mover."
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "A unidade textual para mover."
    - id: count
      type: System.Int32
      description: "O número de unidades a serem movidas. Uma contagem positiva avança o ponto de extremidade. Uma contagem negativa move para trás. Uma contagem de 0 não tem nenhum efeito."
    return:
      type: System.Int32
      description: "O número de unidades realmente movidos, que pode ser menor que o número solicitado se mover que o ponto de extremidade é executado no início ou no final do documento."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  id: RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Remove uma seção realçada de texto, correspondente ao intervalo de texto chamada <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> e <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> pontos de extremidade de uma coleção existente do texto realçado em um contêiner de texto que dá suporte a várias seleções de separação."
  remarks: "O ponto de inserção de texto será movido para a área do realce removido.       Fornece um intervalo de texto degenerado moverá o ponto de inserção."
  syntax:
    content: public void RemoveFromSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Se o provedor de texto não oferece suporte a várias seleções de disjunção (por exemplo, <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>deve ter um valor de <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  id: ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Faz com que o controle de texto rolar verticalmente até que o intervalo de texto é visível no visor."
  remarks: "ScrollIntoView respeita texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>de visibilidade do texto.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Se o intervalo de texto está oculto, o controle de texto será rolada somente se o texto oculto tem uma âncora no visor."
  example:
  - "[!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  \n  \n [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]"
  syntax:
    content: public void ScrollIntoView (bool alignToTop);
    parameters:
    - id: alignToTop
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o controle de texto deve ser rolado para que o intervalo de texto é alinhado com a parte superior do visor; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se ele deve ser alinhado com a parte inferior do visor."
  overload: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Se o controle não tem suporte a rolagem."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  id: Select
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Realça o texto no controle de texto correspondente ao intervalo de texto <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> e <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> pontos de extremidade."
  remarks: "Se um intervalo de texto degenerado for fornecido, o ponto de inserção de texto será movido para o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>ponto de extremidade do intervalo de texto.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  \n  \n [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]"
  syntax:
    content: public void Select ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.Select*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ocorre quando a seleção de texto não é suportada pelo controle de texto."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  id: TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
  type: Property
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Obtém o <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> associada ao intervalo de texto."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  \n  \n [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]"
  syntax:
    content: public System.Windows.Automation.TextPattern TextPattern { get; }
    return:
      type: System.Windows.Automation.TextPattern
      description: "O provedor de texto."
  overload: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
- uid: System.Windows.Automation.Text.TextPatternRange
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Automation.Text.TextPatternRangeEndpoint
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRangeEndpoint
  nameWithType: TextPatternRangeEndpoint
  fullName: System.Windows.Automation.Text.TextPatternRangeEndpoint
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
- uid: System.Windows.Automation.Text.TextUnit
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextUnit
  nameWithType: TextUnit
  fullName: System.Windows.Automation.Text.TextUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
- uid: System.Windows.Automation.AutomationTextAttribute
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationTextAttribute
  nameWithType: AutomationTextAttribute
  fullName: System.Windows.Automation.AutomationTextAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
- uid: System.Windows.Rect[]
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect[]
  spec.csharp:
  - uid: System.Windows.Rect
    name: Rect
    nameWithType: Rect
    fullName: Rect[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
- uid: System.Windows.Automation.AutomationElement[]
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement[]
  spec.csharp:
  - uid: System.Windows.Automation.AutomationElement
    name: AutomationElement
    nameWithType: AutomationElement
    fullName: AutomationElement[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
- uid: System.Windows.Automation.AutomationElement
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
- uid: System.Windows.Automation.TextPattern
  parent: System.Windows.Automation
  isExternal: false
  name: TextPattern
  nameWithType: TextPattern
  fullName: System.Windows.Automation.TextPattern
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection
  nameWithType: TextPatternRange.AddToSelection
- uid: System.Windows.Automation.Text.TextPatternRange.Clone*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone
  nameWithType: TextPatternRange.Clone
- uid: System.Windows.Automation.Text.TextPatternRange.Compare*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare
  nameWithType: TextPatternRange.Compare
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints
  nameWithType: TextPatternRange.CompareEndpoints
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit
  nameWithType: TextPatternRange.ExpandToEnclosingUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute
  nameWithType: TextPatternRange.FindAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText
  nameWithType: TextPatternRange.FindText
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue
  nameWithType: TextPatternRange.GetAttributeValue
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles
  nameWithType: TextPatternRange.GetBoundingRectangles
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren
  nameWithType: TextPatternRange.GetChildren
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement
  nameWithType: TextPatternRange.GetEnclosingElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText
  nameWithType: TextPatternRange.GetText
- uid: System.Windows.Automation.Text.TextPatternRange.Move*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move
  nameWithType: TextPatternRange.Move
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange
  nameWithType: TextPatternRange.MoveEndpointByRange
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit
  nameWithType: TextPatternRange.MoveEndpointByUnit
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection
  nameWithType: TextPatternRange.RemoveFromSelection
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView
  nameWithType: TextPatternRange.ScrollIntoView
- uid: System.Windows.Automation.Text.TextPatternRange.Select*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select
  nameWithType: TextPatternRange.Select
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
