### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Fornece interação com logs de eventos do Windows."
  remarks: "Log de eventos permite acessar ou personalizar os logs de eventos do Windows, o que registrar informações sobre eventos importantes de software ou hardware. Usando o log de eventos, você pode ler os logs existentes, gravar entradas de logs, criar ou excluir fontes de evento, excluir logs e responder a entradas de log. Você também pode criar novos logs durante a criação de uma fonte de evento.      > [!IMPORTANT] > Este tipo implementa o <xref:System.IDisposable>interface.</xref:System.IDisposable> Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A>método em um `try` / `catch` bloco.</xref:System.IDisposable.Dispose%2A> Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção &quot;Usando um objeto que implementa IDisposable&quot; o <xref:System.IDisposable>tópico da interface.</xref:System.IDisposable>       Além de fornecer acesso aos logs de eventos individuais e suas entradas, a classe do log de eventos permite que você acessar a coleção de todos os logs de eventos. Você pode usar o `static` membros do log de eventos para excluir logs, obter listas de log, criar ou excluir uma fonte ou determinar se um computador já contém uma fonte específica.       Há três logs de evento padrão: aplicativo, sistema e segurança. Um log de segurança é somente leitura. Outros aplicativos e serviços que você instalar, como o Active Directory, terá os logs de evento adicionais.       Há considerações de segurança ao usar a classe do log de eventos. Log de eventos requer <xref:System.Diagnostics.EventLogPermission>permissões para ações específicas no .NET Framework 2.0 e versões posteriores, ou confiança total no .NET Framework 1.0 e 1.1.</xref:System.Diagnostics.EventLogPermission> É recomendável que <xref:System.Diagnostics.EventLogPermission>não ser concedido ao código parcialmente confiável.</xref:System.Diagnostics.EventLogPermission>  Você nunca deve passar um objeto de log de eventos, incluindo <xref:System.Diagnostics.EventLogEntryCollection>e <xref:System.Diagnostics.EventLogEntry>objetos para código menos confiável.</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> Por exemplo, criação de um objeto de log de eventos, escrever uma entrada e, em seguida, passando o log de eventos objeto código parcialmente confiável pode criar um problema de segurança, porque a capacidade de ler e gravar no log de eventos permite que o código executar ações como emitir mensagens de log de eventos no nome de outro aplicativo.       Começando com o Windows Vista, o controle de conta de usuário (UAC) determina as credenciais de um usuário. Se você for um membro do grupo Administradores interno, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de usuário padrão e um token de acesso de administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, primeiro elevar suas credenciais de usuário padrão para o administrador. Você pode fazer isso quando você iniciar um aplicativo abrindo o menu de atalho para o aplicativo (se você estiver usando um mouse, clique no ícone de aplicativo) e que indica que você deseja executar como administrador.       Você pode usar o log de eventos para criar logs de eventos personalizados que podem ser exibidos pelo Visualizador de eventos do servidor. Use o <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>método para exibir um nome localizado para o log de eventos no Visualizador de eventos.</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Use o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>método para configurar o comportamento do log de eventos quando alcança seu tamanho máximo do log.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       Para ler de um log de eventos, especifique o nome do log (<xref:System.Diagnostics.EventLog.Log%2A> propriedade) e o nome de computador do servidor (<xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para o log de eventos.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se você não especificar o nome de computador do servidor, o computador local, &quot;.&quot;, será assumido. Não é necessário especificar a origem do evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade), como uma fonte é necessária somente para gravar logs.</xref:System.Diagnostics.EventLog.Source%2A> O <xref:System.Diagnostics.EventLog.Entries%2A>propriedade é preenchida automaticamente com a lista do log de eventos de entradas.</xref:System.Diagnostics.EventLog.Entries%2A>       Para gravar em um log de eventos, especificar ou criar uma fonte de evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade).</xref:System.Diagnostics.EventLog.Source%2A> Você deve ter credenciais administrativas no computador para criar uma nova fonte de evento. A origem do evento registra seu aplicativo com o log de eventos como uma fonte válida de entradas. Você pode usar a origem do evento para gravar no log de apenas um por vez. O <xref:System.Diagnostics.EventLog.Source%2A>propriedade pode ser qualquer cadeia de caracteres aleatória, mas o nome deve ser diferente de outras fontes no computador.</xref:System.Diagnostics.EventLog.Source%2A> A origem do evento é normalmente o nome do aplicativo ou outra cadeia de caracteres de identifica. Ao tentar criar uma duplicata <xref:System.Diagnostics.EventLog.Source%2A>valor lança uma exceção.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, um único log de eventos pode ser associado a várias fontes.       Se a origem do evento para o log de eventos associado com a instância do log de eventos não existir, uma nova fonte de evento é criada. Para criar uma fonte de evento no Windows Vista e posterior ou Windows Server 2003, você deve ter credenciais administrativas.       Esse requisito é porque todos os logs de eventos, incluindo os logs de segurança deve ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não tem permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>      > [!IMPORTANT] > Criar ou excluir uma fonte de evento requer sincronização de código subjacente usando um mutex nomeado. Se um aplicativo altamente privilegiado bloqueia o mutex nomeado, tentar criar ou excluir uma fonte de evento faz com que o aplicativo pare de responder até que o bloqueio seja liberado. Para evitar esse problema, conceda nunca <xref:System.Security.Permissions.SecurityPermissionFlag>permissão para código não confiável.</xref:System.Security.Permissions.SecurityPermissionFlag> Além disso, <xref:System.Security.Permissions.SecurityPermissionFlag>permissão permite que outras permissões para ser ignorada potencialmente e só devem ser concedida para código altamente confiável.</xref:System.Security.Permissions.SecurityPermissionFlag>       Aplicativos e serviços devem gravar no log de aplicativo ou em um log personalizado. Drivers de dispositivo devem gravar no log do sistema. Se você não definir explicitamente a <xref:System.Diagnostics.EventLog.Log%2A>propriedade, os padrões de log de eventos no log de aplicativo.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não há nada para proteger um aplicativo de gravação como qualquer fonte registrada.  Se um aplicativo for concedido <xref:System.Diagnostics.EventLogPermissionAccess>permissão, ele pode gravar eventos de qualquer fonte válido registrado no computador.</xref:System.Diagnostics.EventLogPermissionAccess>       Use os <xref:System.Diagnostics.EventLog.WriteEvent%2A> <xref:System.Diagnostics.EventLog.WriteEntry%2A>métodos</xref:System.Diagnostics.EventLog.WriteEntry%2A> e para gravar eventos em um log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Você deve especificar uma fonte de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional ainda não atualizados sua lista de fontes de eventos, e você tenta gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>objeto ou o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter credenciais administrativas no computador para criar uma nova fonte de evento.       Cada fonte pode gravar no log de eventos somente uma por vez; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, o aplicativo pode exigir várias fontes configuradas para logs de eventos diferentes ou arquivos de recurso diferente. Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam a fonte existente, crie uma nova fonte com a configuração atualizada, em vez de excluir a fonte existente.       Você pode registrar a origem do evento com os recursos localizados para suas cadeias de caracteres de categoria e a mensagem de evento. Seu aplicativo pode gravar entradas de log de eventos usando identificadores de recursos em vez de especificar os valores de cadeia de caracteres real. Consulte o <xref:System.Diagnostics.EventLogInstaller>e <xref:System.Diagnostics.EventSourceCreationData>classes para obter mais informações sobre como configurar sua fonte com arquivos de recurso.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Se seu aplicativo grava os valores de cadeia de caracteres diretamente para o log de eventos, você não precisa definir o recurso de propriedades de arquivo para a fonte. A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Ao gravar eventos, você deve especificar pelo menos uma cadeia de caracteres da mensagem ou o identificador de recurso para uma cadeia de caracteres de mensagem. Outras propriedades de evento são opcionais. Exemplos de configurações de evento opcionais incluem o seguinte:-você pode definir o <xref:System.Diagnostics.EventLogEntryType>para especificar o ícone exibido no Visualizador de eventos para a entrada.</xref:System.Diagnostics.EventLogEntryType>      -Você pode especificar um identificador de categoria de evento, se seu aplicativo usar categorias para filtragem de eventos.      -Você pode anexar dados binários a sua entrada de evento se você deseja associar informações adicionais um determinado evento.      > [!IMPORTANT] > O log de eventos consome espaço em disco, o tempo do processador e outros recursos do sistema. É importante fazer logon somente informações essenciais. É recomendável que você fazer chamadas do log de eventos em um caminho de erro, em vez de no caminho do código principal, portanto eles não afetarem negativamente o desempenho.       Para obter uma lista de valores de propriedade inicial para uma instância do log de eventos, consulte o <xref:System.Diagnostics.EventLog.%23ctor%2A>construtor.</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Não associe a instância de qualquer log."
  remarks: "Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A>propriedade o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se você estiver lendo somente <xref:System.Diagnostics.EventLog.Entries%2A>do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia de caracteres vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| Uma cadeia de caracteres vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.MachineName%2A>| O computador local (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância com um log no computador local."
  remarks: "Essa sobrecarga define o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro.</xref:System.Diagnostics.EventLog.Log%2A> Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A>propriedade o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se você estiver lendo somente <xref:System.Diagnostics.EventLog.Entries%2A>do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A> Essa sobrecarga de construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A>propriedade, mas você pode alterar isso antes da leitura de <xref:System.Diagnostics.EventLog.Entries%2A>propriedade.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       Se a fonte que você especificar na <xref:System.Diagnostics.EventLog.Source%2A>propriedade é exclusiva de outras fontes no computador, uma chamada subsequente para <xref:System.Diagnostics.EventLog.WriteEntry%2A>cria um log com o nome especificado, se ele ainda não existir.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia de caracteres vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O computador local (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do log no computador local."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do log é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do log é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância com um log no computador especificado."
  remarks: "Essa sobrecarga define o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro e o <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade para o `machineName` parâmetro.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique a <xref:System.Diagnostics.EventLog.Source%2A>propriedade de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se você estiver lendo somente <xref:System.Diagnostics.EventLog.Entries%2A>do log, você poderá especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Essa sobrecarga de construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades, mas você pode alterar um antes da leitura de <xref:System.Diagnostics.EventLog.Entries%2A>propriedade.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia de caracteres vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O `machineName` parâmetro. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do log no computador especificado."
    - id: machineName
      type: System.String
      description: "O computador no qual o log existe."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do log é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do log é inválido.       - ou - o nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância com um log no computador especificado e cria ou atribui a origem especificada para o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>."
  remarks: "Esse construtor define o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro, o <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade para o `machineName` parâmetro e o <xref:System.Diagnostics.EventLog.Source%2A>propriedade para o `source` parâmetro.</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> A <xref:System.Diagnostics.EventLog.Source%2A>propriedade é necessária ao gravar em um log de eventos.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, se você for somente leitura de um log de eventos, apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>propriedades são necessárias (contanto que o log de eventos no servidor tem uma fonte já está associada a ele).</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se você for somente leitura do log de eventos, outra sobrecarga do construtor pode ser suficiente.       A tabela a seguir mostra os valores de propriedade inicial para uma instância de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| O `source` parâmetro. |   | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O `machineName` parâmetro. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do log no computador especificado"
    - id: machineName
      type: System.String
      description: "O computador no qual o log existe."
    - id: source
      type: System.String
      description: "A origem das entradas de log de eventos."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do log é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do log é inválido.       - ou - o nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Começa a inicialização de um <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> usado em um formulário ou usado por outro componente. A inicialização ocorre em tempo de execução."
  remarks: "O [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] design ambiente usa esse método para iniciar a inicialização de um componente usado em um formulário ou por outro componente. O <xref:System.Diagnostics.EventLog.EndInit%2A>método termina a inicialização.</xref:System.Diagnostics.EventLog.EndInit%2A> Usando o BeginInit e <xref:System.Diagnostics.EventLog.EndInit%2A>métodos impedir que o controle que está sendo usada antes de ser totalmente inicializado.</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>já foi inicializado."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove todas as entradas do log de eventos."
  remarks: "Logs de eventos são definidos com um tamanho máximo que determina quantas entradas podem conter. Quando um log de eventos está cheio, ele interrompe a gravação de novas informações de evento ou começa a substituir entradas anteriores. Se parar a gravação de eventos, você pode usar esse método para limpar o log de entradas existentes e permitir que ele iniciar o registro de eventos. Você deve ter permissões de administrador para o computador no qual o log reside para limpar entradas de log de eventos.       Desmarque fecha o log de eventos, libera os identificadores de eventos, recupera a nova leitura e gravação de identificadores e reabrir o log de eventos. Eventos recebidos após a chamada ao método não são limpos junto com os eventos existentes."
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O log de eventos não foi limpo com êxito.       - ou - o log não pode ser aberto. Um código de erro do Windows não está disponível."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um valor não for especificado para o <xref:System.Diagnostics.EventLog.Log*>propriedade.</xref:System.Diagnostics.EventLog.Log*> Verifique se que o nome do log não é uma cadeia de caracteres vazia."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log não existe."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Fecha o log de eventos e as versões de leitura e gravação de identificadores."
  remarks: "O método Close for chamado por protegido <xref:System.ComponentModel.Component.Dispose%2A>método.</xref:System.ComponentModel.Component.Dispose%2A> Você não precisa chamar fechar antes de chamar <xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Identificador de leitura do log de eventos ou identificador de gravação não foi liberado com êxito."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece uma fonte de evento válida para gravar o evento localizado mensagens, usando as propriedades de configuração especificado para a origem do evento e o log de eventos correspondente."
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "As propriedades de configuração para a origem do evento e seu log de eventos de destino."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece o nome de origem especificado como uma fonte de evento válida para gravar entradas em um log no computador local. Esse método também pode criar um novo log personalizado no computador local."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "O nome de origem pela qual o aplicativo está registrado no computador local."
    - id: logName
      type: System.String
      description: "O nome do log de entradas da fonte são gravadas. Os valores possíveis incluem aplicativo, sistema ou um log de eventos personalizado."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos no computador local."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece o nome de origem especificado como uma fonte de evento válida para gravar entradas em um log no computador especificado. Esse método também pode ser usado para criar um novo log personalizado no computador especificado."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: logName
      type: System.String
      description: "O nome do log de entradas da fonte são gravadas. Os valores possíveis incluem aplicativo, sistema ou um log de eventos personalizado. Se você não especificar um valor, `logName` padrões para o aplicativo."
    - id: machineName
      type: System.String
      description: "O nome do computador para registrar essa fonte de evento, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos no computador especificado."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove um log de eventos do computador local."
  remarks: "Use esse método quando o log que deseja excluir está no computador local. Você pode excluir qualquer log no computador, desde que você tenha as permissões de registro apropriados.       Excluir remove o log especificado pelo `logName` do computador local. Se você quiser excluir apenas a fonte registrada em um log, chame <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> Excluir e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, para que eles podem ser chamados em classe em si.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Não é necessário criar uma nova instância da <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Primeiro, o método Delete exclui o arquivo que contém o conteúdo do log. Em seguida, ele acessa o registro e remove todas as fontes de evento registradas para que o log. Se você recriar o log em um momento posterior, você deve registrar as fontes de evento novamente, se eles forem ser reutilizado. Se você não registrar as fontes de evento e outros usuários de gravação para uma fonte de evento sem especificar um nome de log, a origem do evento será criada no log de eventos do aplicativo. Portanto, os aplicativos que anteriormente eram capazes de gravar entradas de log é excluído e recriado gravará no log de aplicativo em vez disso, porque agora contém a origem do evento.      > [!NOTE] > Recriar um log de eventos pode ser um processo difícil. Evite a exclusão de qualquer um dos logs de eventos criados pelo sistema, como o log de aplicativo.       Excluir um log por meio de uma chamada para exclusão exclui automaticamente as fontes registradas nesse log. Isso pode tornar a outros aplicativos que usam esse log inoperante."
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do log a ser excluído. Os valores possíveis incluem: aplicativo, segurança, sistema e quaisquer logs de eventos personalizados no computador.'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>é uma cadeia de caracteres vazia (&quot;&quot;) ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O log de eventos não foi limpo com êxito.       - ou - o log não pode ser aberto. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove um log de eventos do computador especificado."
  remarks: "Use esse método quando o log que deseja excluir está em um computador remoto. Você pode excluir qualquer log no computador, desde que você tenha as permissões de registro apropriados.       <xref:System.Diagnostics.EventLog.Delete%2A>Remove o log especificado pelo `logName` do computador especificado pelo `machineName`.</xref:System.Diagnostics.EventLog.Delete%2A> Se você quiser excluir apenas a fonte registrada em um log, chame <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, para que eles podem ser chamados em classe em si.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Esse método primeiro exclui o arquivo que contém o conteúdo do log. Em seguida, ele acessa o registro e remove todas as fontes de evento registradas para que o log. Se você recriar o log em um momento posterior, você deve registrar as fontes de evento novamente, se eles forem ser reutilizado. Se você não registrar as fontes de evento e outros usuários de gravação para uma fonte de evento sem especificar um nome de log, a origem do evento será criada no log de eventos do aplicativo. Portanto, os aplicativos que anteriormente eram capazes de gravar entradas de log é excluído e recriado gravará no log de aplicativo em vez disso, porque agora contém a origem do evento.      > [!NOTE] > Recriar um log de eventos pode ser um processo difícil. Evite a exclusão de qualquer um dos logs de eventos criados pelo sistema, como o log de aplicativo.       Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>exclui automaticamente as fontes registradas para esse log.</xref:System.Diagnostics.EventLog.Delete%2A> Isso pode tornar a outros aplicativos que usam esse log inoperante."
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do log a ser excluído. Os valores possíveis incluem: aplicativo, segurança, sistema e quaisquer logs de eventos personalizados no computador especificado.'
    - id: machineName
      type: System.String
      description: "O nome do computador para excluir o log, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O log de eventos não foi limpo com êxito.       - ou - o log não pode ser aberto. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove o registro da fonte de evento do log de eventos do computador local."
  remarks: "Use esse método para remover o registro de um <xref:System.Diagnostics.EventLog.Source%2A>do computador local.</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource acessa o registro no computador local e remove o registro do seu aplicativo como uma origem válida de eventos.       Você pode remover seu componente como uma origem válida de eventos, se você não precisar mais dela para gravar entradas de log. Por exemplo, você pode fazer isso se você precisar alterar o seu componente de um log para outra. Como uma origem só pode ser registrada para um log de cada vez, alterar o log exige que você remover o registro atual.       DeleteEventSource remove somente a fonte registrada em um log. Se você quiser remover o log em si, chame <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e DeleteEventSource `static` métodos, para que eles podem ser chamados em classe em si.</xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>exclui automaticamente as fontes registradas para esse log.</xref:System.Diagnostics.EventLog.Delete%2A> Isso pode tornar a outros aplicativos que usam esse log inoperante.      > [!NOTE] > Se uma fonte já foi mapeada para um log e remapear a um novo log, você deve reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "O nome pelo qual o aplicativo está registrado no sistema de log de eventos."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove o registro da fonte de eventos do aplicativo do computador especificado."
  remarks: "Use essa sobrecarga para remover o registro de um <xref:System.Diagnostics.EventLog.Source%2A>de um computador remoto.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>acessa o registro no computador especificado por `machineName` e remove o registro do seu aplicativo como uma origem válida de eventos.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       Você pode remover seu componente como uma origem válida de eventos, se você não precisar mais dela para gravar entradas de log. Por exemplo, você pode fazer isso se você precisar alterar o seu componente de um log para outra. Como uma origem só pode ser registrada para um log de cada vez, alterar o log exige que você remover o registro atual.       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Remove somente a fonte registrada em um log.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se você quiser remover o log em si, chame <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Se você quiser excluir as entradas de log, chame <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, para que eles podem ser chamados em classe em si.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Excluir um log por meio de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>exclui automaticamente as fontes registradas para esse log.</xref:System.Diagnostics.EventLog.Delete%2A> Isso pode tornar a outros aplicativos que usam esse log inoperante.      > [!NOTE] > Se uma fonte já foi mapeada para um log e remapear a um novo log, você deve reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome pelo qual o aplicativo está registrado no sistema de log de eventos."
    - id: machineName
      type: System.String
      description: "O nome do computador para remover o registro, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>não pode ser excluída porque no registro, a chave do registro pai <code>source</code> não tem uma subchave com o mesmo nome."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Libera os recursos não gerenciados usados pelo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>e, opcionalmente, libera os recursos gerenciados."
  remarks: "Este método é chamado pelo público `Dispose()`método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> `Dispose()`invoca o protegido `Dispose(Boolean)` método com o `disposing` parâmetro definido como `true`. <xref:System.Object.Finalize%2A>invoca `Dispose` com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro for true, este método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Diagnostics.EventLog>referências.</xref:System.Diagnostics.EventLog> Este método chama o `Dispose()` método de cada objeto referenciado."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> recebe <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> notificações de eventos."
  remarks: "A propriedade EnableRaisingEvents determina se o que <xref:System.Diagnostics.EventLog>gera eventos quando as entradas são gravadas no log.</xref:System.Diagnostics.EventLog> Quando a propriedade for `true`, componentes que recebem o <xref:System.Diagnostics.EventLog.EntryWritten>evento receberão a notificação sempre que uma entrada é gravada no log especificado no <xref:System.Diagnostics.EventLog.Log%2A>propriedade.</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> Se for EnableRaisingEvents `false`, nenhum evento é gerado.      > [!NOTE] > Você pode receber notificações de eventos somente quando as entradas são gravadas no computador local. Você não pode receber notificações para entradas gravadas em computadores remotos."
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> recebe notificação quando uma entrada é escrita no log; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log de eventos está em um computador remoto."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Termina a inicialização de um <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> usado em um formulário ou por outro componente. A inicialização ocorre em tempo de execução."
  remarks: "O [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] design ambiente usa esse método para terminar a inicialização de um componente usado em um formulário ou por outro componente. O <xref:System.Diagnostics.EventLog.BeginInit%2A>método inicia a inicialização.</xref:System.Diagnostics.EventLog.BeginInit%2A> Usando o <xref:System.Diagnostics.EventLog.BeginInit%2A>e métodos de EndInit impede que o controle que está sendo usada antes de ser totalmente inicializado.</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o conteúdo do log de eventos."
  remarks: "Use o membro de entradas durante a leitura do log de eventos.       Como a propriedade é somente leitura, não é possível modificar uma entrada ou gravar no log usando entradas. Em vez disso, especifique um <xref:System.Diagnostics.EventLog.Source%2A>e chame <xref:System.Diagnostics.EventLog.WriteEntry%2A>para gravar uma nova entrada de log.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> Você pode usar entradas para contar o número de entradas no log de eventos e exibir cada <xref:System.Diagnostics.EventLogEntry>na coleção.</xref:System.Diagnostics.EventLogEntry> Use o indexada <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>membro para recuperar informações sobre uma entrada específica, como <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, ou <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       Não é necessário especificar <xref:System.Diagnostics.EventLog.Source%2A>quando somente leitura de um log.</xref:System.Diagnostics.EventLog.Source%2A> Você pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>nome e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades (nome de computador do servidor) para o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Em ambos os casos, o membro de entradas é preenchido automaticamente com a lista do log de eventos de entradas. Você pode selecionar o índice apropriado para um item na lista para ler entradas individuais.       Uma importante distinção entre ler e gravar entradas de log é que não é necessário chamar explicitamente um método de leitura. Após a <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>forem especificados, a propriedade de entradas é preenchida automaticamente.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se você alterar o valor da <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade</xref:System.Diagnostics.EventLog.MachineName%2A> ou, as entradas de propriedade é preenchida novamente na próxima vez que você leia o proprietário.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Você não precisa especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>se você estiver se conectando a um log.</xref:System.Diagnostics.EventLog.MachineName%2A> Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local, &quot;.&quot;, será assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "Um <xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref> contendo as entradas no log de eventos. Cada entrada está associada uma instância do <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref> classe."
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando uma entrada é gravada em um log de eventos no computador local."
  remarks: "Para obter notificações de eventos, você deve definir <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>para `true`.</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Você só pode receber notificações de eventos quando as entradas são gravadas no computador local. Você não pode receber notificações para entradas gravadas em computadores remotos.       Quando você cria um delegado EntryWritten, identifica o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do representante ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, até que você remova o delegado. Para obter mais informações sobre como manipular eventos com delegados, consulte [eventos](~/add/includes/ajax-current-ext-md.md).       O sistema responde a <xref:System.Diagnostics.EventLog.WriteEntry%2A>apenas se o último evento de gravação ocorreu pelo menos seis segundos anteriormente.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Isso implica que você só receberá uma notificação de eventos EntryWritten dentro de um intervalo de seis segundos, mesmo se mais de um log de eventos de alteração ocorre. Se você inserir um intervalo de suspensão suficientemente longa (cerca de 10 segundos) entre chamadas para <xref:System.Diagnostics.EventLog.WriteEntry%2A>, é menos prováveis de perder um evento.</xref:System.Diagnostics.EventLog.WriteEntry%2A> No entanto, se a gravação de eventos ocorrem com mais frequência, você pode não receber a notificação de eventos até o próximo intervalo. Normalmente, as notificações de eventos ausentes não são perdidas, mas atrasadas."
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se o log existe no computador local."
  remarks: "Use esse método para determinar se existe um log no computador local. Se você quiser determinar se existe uma fonte no computador local, use <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador local. Caso contrário, a consulta retorna `false`.       Porque você não pode dar a um novo log o nome de um log existente no mesmo computador, use esse método antes de criar um novo log para determinar se especificado `logName` já existe no computador local. O `logName` parâmetro não diferencia maiusculas de minúsculas.       Existe é um `static` método, portanto ele pode ser chamado na própria classe. Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar Exists.</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do log para pesquisar. Os valores possíveis incluem: aplicativo, segurança, sistema, outros logs específicos do aplicativo (como aqueles associados ao Active Directory) ou qualquer log personalizado no computador.'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o log existe no computador local. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É o logName <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou o valor está vazio."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se o log existe no computador especificado."
  remarks: "Use esse método para determinar se existe um log em um computador remoto. Se você quiser determinar se existe uma fonte em um computador remoto, use <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador especificado. Caso contrário, a consulta retorna `false`.       Porque você não pode dar a um novo log o nome de um log existente no mesmo computador, use esse método antes de criar um novo log para determinar se uma com especificado `logName` já existe no servidor especificado o `machineName` parâmetro. O `logName` e `machineName` parâmetros não diferenciam maiusculas de minúsculas.       <xref:System.Diagnostics.EventLog.Exists%2A>é um `static` método, portanto ele pode ser chamado na própria classe.</xref:System.Diagnostics.EventLog.Exists%2A> Não é necessário criar uma nova instância de <xref:System.Diagnostics.EventLog>chamar <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'O log para o qual pesquisar. Os valores possíveis incluem: aplicativo, segurança, sistema, outros logs específicos do aplicativo (como aqueles associados ao Active Directory) ou qualquer log personalizado no computador.'
    - id: machineName
      type: System.String
      description: "O nome do computador no qual pesquisar o log, ou &quot;.&quot; para o computador local."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o log existe no computador especificado. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> parâmetro é um formato inválido. Verifique se que você usou a sintaxe apropriada para o computador no qual você está pesquisando.       - ou - <code> logName </code> é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou o valor está vazio."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pesquisa todos os logs de eventos no computador local e cria uma matriz de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objetos que contêm a lista."
  remarks: "A matriz de <xref:System.Diagnostics.EventLog>objetos é um instantâneo de todos os logs de eventos no computador local quando é feita a chamada para GetEventLogs.</xref:System.Diagnostics.EventLog> Isso não é uma coleção dinâmica, portanto não reflete a exclusão ou a criação de logs em tempo real. Você deve verificar se um log na matriz existe antes de ler ou gravar nele. A matriz geralmente inclui pelo menos três logs: aplicativo, sistema e segurança. Se você criou logs personalizados no computador local, eles serão exibidos na matriz também.       Para recuperar a lista de logs de eventos, você deve ter as permissões de registro apropriados. Essas permissões são idênticas às necessária para chamar <xref:System.Diagnostics.EventLog.Exists%2A>e <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> que representa os logs no computador local."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Você não tem acesso de leitura ao registro.       - ou - não há nenhum serviço de log de eventos no computador."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pesquisa todos os logs de eventos em determinado computador e cria uma matriz de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objetos que contêm a lista."
  remarks: "A matriz de <xref:System.Diagnostics.EventLog>objetos é um instantâneo de todos os logs de eventos no computador especificado pelo `machineName` parâmetro quando a chamada para <xref:System.Diagnostics.EventLog.GetEventLogs%2A>é feita.</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> Isso não é uma coleção dinâmica, portanto não reflete a exclusão ou a criação de logs em tempo real. Você deve verificar se um log na matriz existe antes de ler ou gravar nele. A matriz geralmente inclui pelo menos três logs: aplicativo, sistema e segurança. Se você criou logs personalizados no computador especificado, eles serão exibidos na matriz também.       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>é um `static` método, portanto ele pode ser chamado no <xref:System.Diagnostics.EventLog>classe em si.</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> Não é necessário criar uma instância de um <xref:System.Diagnostics.EventLog>objeto para fazer uma chamada ao método.</xref:System.Diagnostics.EventLog>       Para recuperar a lista de logs de eventos, você deve ter as permissões de registro apropriados. Essas permissões são idênticas às necessária para chamar <xref:System.Diagnostics.EventLog.Exists%2A>e <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "O computador no qual pesquisar logs de eventos."
    return:
      type: System.Diagnostics.EventLog[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> que representa os logs em determinado computador."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> parâmetro é um nome de computador inválido."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Você não tem acesso de leitura ao registro.       - ou - não há nenhum serviço de log de eventos no computador."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome do log para ler ou gravar."
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "O nome do log. Isso pode ser um aplicativo, sistema, segurança ou um nome de log personalizado. O padrão é uma cadeia de caracteres vazia (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome amigável do log de eventos."
  remarks: "> [!NOTE]> No Windows Vista e posterior, os usuários não tem permissão para acessar o log de segurança. Se você estiver executando o Windows Vista ou posterior como um usuário, você receberá um <xref:System.Security.SecurityException>quando você tentar acessar o nome para exibição para um evento no log de segurança.</xref:System.Security.SecurityException>   >> No Windows Vista e versões posteriores, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se você for um membro do grupo Administradores interno, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de usuário padrão e um token de acesso de administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa o log de segurança, primeiro elevar seus privilégios de usuário padrão para o administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador."
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "Um nome que representa o log de eventos no Visualizador de eventos do sistema."
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Especificado <xref:System.Diagnostics.EventLog.Log*>não existe no registro para este computador.</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do log no qual a fonte especificada está registrada."
  remarks: "A origem do evento indica que registra o evento. É geralmente o nome do aplicativo ou o nome de um subcomponente do aplicativo, se o aplicativo for grande. Aplicativos e serviços devem gravar no log de aplicativo ou um log personalizado. Drivers de dispositivo devem gravar no log do sistema.       Quando você cria uma nova origem, que pode gravar apenas em um log de cada vez, o sistema registra seu aplicativo com o log de eventos como uma fonte válida de entradas. O <xref:System.Diagnostics.EventLog.Source%2A>propriedade pode ser qualquer cadeia de caracteres, mas o nome não pode ser usado por outras fontes no computador.</xref:System.Diagnostics.EventLog.Source%2A> Uma tentativa de criar um duplicado <xref:System.Diagnostics.EventLog.Source%2A>valor lança uma exceção.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, um único log de eventos pode ter várias fontes diferentes de gravação a ele."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome de origem do evento."
    - id: machineName
      type: System.String
      description: "O nome do computador no qual procurar, ou &quot;.&quot; para o computador local."
    return:
      type: System.String
      description: "O nome do log associado com a origem especificada no registro."
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome do computador no qual ler ou gravar eventos."
  remarks: "Se você gravar um log de eventos, você deve associar um <xref:System.Diagnostics.EventLog.Source%2A>com o seu objeto de log de eventos para conectá-la para um log específico</xref:System.Diagnostics.EventLog.Source%2A> Não é necessário especificar a <xref:System.Diagnostics.EventLog.Source%2A>propriedade quando somente leitura de um log.</xref:System.Diagnostics.EventLog.Source%2A> Você pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>nome e o nome do computador (nome de computador do servidor).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não é necessário especificar o nome do computador, se você estiver se conectando a um log. Se você não especificar o nome do computador, o computador local (&quot;.&quot;) é assumido.       Uma origem só pode ser registrada para um log de cada vez. Se o <xref:System.Diagnostics.EventLog.Source%2A>propriedade foi definida para uma instância de <xref:System.Diagnostics.EventLog>, você não pode alterar a propriedade MachineName que <xref:System.Diagnostics.EventLog>sem alterar o valor de <xref:System.Diagnostics.EventLog.Source%2A>ou chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>primeiro.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Se você alterar a propriedade MachineName, o <xref:System.Diagnostics.EventLog>fecha todos os identificadores e anexa novamente para o log e o código-fonte no novo computador.</xref:System.Diagnostics.EventLog>       O valor do nome do computador não pode ser uma cadeia de caracteres vazia. Se ele não for definido explicitamente, o padrão é o computador local (&quot;.&quot;)."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "O nome do servidor no qual reside o log de eventos. O padrão é o computador local (&quot;.&quot;)."
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho máximo de evento de log em quilobytes."
  remarks: "A propriedade MaximumKilobytes representa o limite de tamanho do arquivo de log de eventos. Quando o log de eventos atingir o limite de tamanho configurado <xref:System.Diagnostics.EventLog.OverflowAction%2A>valor determina se as novas entradas são descartadas, ou se novas entradas substituir as entradas mais antigas.</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] > Esta propriedade representa um parâmetro de configuração para o log de evento representado por esta instância. Quando o log de eventos atingir seu tamanho máximo, essa propriedade especifica como o sistema operacional trata as novas entradas gravadas por todas as fontes de evento registradas para o log de eventos."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "O tamanho máximo de evento de log em quilobytes. O padrão é 512, que indica o tamanho máximo de 512 KB."
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor especificado é menor do que 64, ou maior que 4194240 ou não um múltiplo de 64."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o número de dias para manter entradas no log de eventos."
  remarks: "Use a propriedade MinimumRetentionDays para examinar a configuração atual de um log de eventos. Use <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>para alterar o número mínimo de dias em que cada entrada no log de eventos deve ser mantida.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       O valor de MinimumRetentionDays depende do comportamento de estouro de configurado o log de eventos. Se o <xref:System.Diagnostics.OverflowAction>propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é 0.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Se o <xref:System.Diagnostics.OverflowAction>propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é -1.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Se o <xref:System.Diagnostics.OverflowAction>propriedade para um log de eventos é definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é maior que zero e representa o número de dias para manter entradas do log de eventos quando o log de eventos está cheio.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       O comportamento de excedentes só ocorre quando um log de eventos atingir seu limite de tamanho. Quando um <xref:System.Diagnostics.EventLog>tem seu <xref:System.Diagnostics.EventLog.OverflowAction%2A>definido como <xref:System.Diagnostics.OverflowAction>e o log de eventos atingir seu tamanho máximo, em seguida, novas entradas são gravadas somente se eles podem substituir entradas cuja idade exceder o período de MinimumRetentionDays.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> Retém as entradas de eventos por um período mínimo é apropriado quando o log de eventos é arquivado regularmente. Caso contrário, você corre o risco de perder novas entradas quando o log de eventos atingir seu limite. Para evitar perder as novas informações de evento, defina os dias de retenção mínimo para eventos com base em seu agendamento de arquivo para um determinado log de eventos."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "O número de dias que as entradas no log de eventos são mantidas. O valor padrão é 7."
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Altera o comportamento configurado para gravar novas entradas quando o log de eventos atingir seu tamanho máximo do arquivo."
  remarks: "O comportamento de estouro de um log de eventos especifica o que acontece quando as novas entradas devem ser gravados em um log que atingiu seu tamanho máximo do arquivo.      > [!NOTE] > O comportamento de excedentes entra em vigor somente quando um log de eventos atingir seu tamanho máximo do arquivo. O comportamento de estouro não afeta a gravar uma nova entrada de um log que possa acomodar as entradas de log de eventos adicionais.       O método ModifyOverflowPolicy configura o comportamento de estouro de um log de eventos. <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> Depois de chamar esse método para o log de eventos especificado pelo <xref:System.Diagnostics.EventLog.Log%2A>propriedade, o <xref:System.Diagnostics.EventLog.OverflowAction%2A>e <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>valores de propriedade refletem o comportamento de estouro recém-configurado.</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Esta propriedade representa um parâmetro de configuração para o log de evento representado por esta instância. Quando o log de eventos atingir seu tamanho máximo, essa propriedade especifica como o sistema operacional trata as novas entradas gravadas por todas as fontes de evento registradas para o log de eventos.       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>para indicar que uma nova entrada substitui a entrada mais antiga quando o <xref:System.Diagnostics.EventLog>atinge seu tamanho máximo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Se o `action` parâmetro está definido como <xref:System.Diagnostics.OverflowAction>, o `retentionDays` o valor do parâmetro é ignorado.</xref:System.Diagnostics.OverflowAction>       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>para indicar que cada nova entrada substitui as entradas mais antigas quando o <xref:System.Diagnostics.EventLog>atinge seu tamanho máximo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Especifique o número de dias que os eventos devem ser mantidos no log usando o `retentionDays` parâmetro. Os eventos gravados dentro do período de retenção não são substituídos por novas entradas.       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>para descartar os novos eventos quando o tamanho máximo do log for atingido.</xref:System.Diagnostics.OverflowAction> Se o `action` parâmetro está definido como <xref:System.Diagnostics.OverflowAction>, o `retentionDays` o valor do parâmetro é ignorado.</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] > Configuração da diretiva de estouro <xref:System.Diagnostics.OverflowAction>Especifica que novas entradas são descartadas quando o log de eventos está cheio.</xref:System.Diagnostics.OverflowAction> Se você usar essa configuração, verifique o log de eventos regularmente é arquivado e limpo para evitar alcançar o limite de tamanho máximo."
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "O comportamento de estouro para escrever novas entradas no log de eventos."
    - id: retentionDays
      type: System.Int32
      description: "O número mínimo de dias que cada entrada de log de eventos é retida. Esse parâmetro é usado somente se `action` é definido como <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>não é válido <xref:System.Diagnostics.EventLog.OverflowAction*> valor."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>é menor do que um, ou maior que 365."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o comportamento configurado para armazenar novas entradas quando o log de eventos atingir seu tamanho máximo do log."
  remarks: "Logs de eventos crescem em tamanho, como novos eventos são gravados neles. Cada log de eventos tem um limite de tamanho máximo configurado; o <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>propriedade define o número máximo de quilobytes permitidos para o tamanho do arquivo de log de eventos.</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       Use o valor da propriedade OverflowAction para examinar o comportamento de estouro configurado para um log de eventos em seu tamanho máximo. Use o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>método para alterar o comportamento de estouro de um log de eventos.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      > [!NOTE] > O comportamento de excedentes entra em vigor somente quando um log de eventos atingir seu tamanho máximo do arquivo. O comportamento de estouro não afeta a gravar uma nova entrada de um log que possa acomodar as entradas de log de eventos adicionais."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "O <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref> valor que especifica o comportamento configurado para armazenar novas entradas quando o log de eventos atingir seu tamanho máximo do log. O padrão é <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Especifica o nome localizado do log de eventos, que é exibido no Visualizador de eventos do servidor."
  remarks: "Use RegisterDisplayName para registrar e exibir um nome localizado no Visualizador de eventos para logs de eventos personalizados.       O identificador de recurso especificado deve corresponder a uma cadeia de caracteres localizada definida no arquivo de recurso. O Visualizador de eventos exibe o nome do log de eventos personalizado usando a cadeia de caracteres localizada e as configurações de cultura atual. Por exemplo, você pode definir vários nomes de log de eventos localizados para culturas diferentes em seu arquivo de recurso. O Visualizador de eventos exibe a cadeia de caracteres localizada correspondente às configurações de cultura do usuário atual.       Se o Visualizador de eventos não é possível carregar a cadeia de caracteres localizada do arquivo de recurso, ou se nenhum nome de exibição foi registrado para o log de eventos, o Visualizador de eventos exibe o nome do log de eventos definido em <xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não é necessário registrar um nome de exibição para os logs de eventos predefinidos. O sistema operacional registra os nomes de exibição localizado para os logs de eventos do aplicativo, sistema e segurança."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "O caminho totalmente especificado para um arquivo de recurso localizado."
    - id: resourceId
      type: System.Int64
      description: "O identificador de recurso que indexa uma cadeia de caracteres localizada dentro do arquivo de recurso."
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome da fonte para registrar e usar durante a gravação no log de eventos."
  remarks: "A origem do evento indica que registra o evento. É geralmente o nome do aplicativo ou o nome de um subcomponente do aplicativo, se o aplicativo for grande. Aplicativos e serviços devem gravar no log de aplicativo ou um log personalizado. Drivers de dispositivo devem gravar no log do sistema.       Você precisa especificar uma fonte de evento, se você estiver escrevendo um log de eventos. Antes de gravar uma entrada em um log de eventos, você deve registrar a origem do evento com o log de eventos como uma origem válida de eventos. Quando você grava uma entrada de log, o sistema usa a propriedade de origem para localizar o log adequado para colocar sua entrada. Se você está lendo no log de eventos, você pode especificar a origem ou um <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Você não precisa especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>se você estiver se conectando a um registro no computador local.</xref:System.Diagnostics.EventLog.MachineName%2A> Se você não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>       Use <xref:System.Diagnostics.EventLog.WriteEvent%2A>e <xref:System.Diagnostics.EventLog.WriteEntry%2A>para gravar eventos em um log de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> Você deve especificar uma fonte de evento para gravar eventos; Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Você pode criar uma fonte de evento para um log de eventos existente ou um novo log de eventos. Quando você cria uma nova origem para um novo log de eventos, o sistema registra a fonte para que o log, mas o log não é criado até que a primeira entrada é gravada nele.       A origem deve ser exclusiva no computador local. um novo nome de origem não pode coincidir com o nome de uma fonte existente ou um nome de log de eventos existente. Cada fonte pode gravar no log de eventos somente uma por vez; No entanto, seu aplicativo pode usar várias fontes para gravar em vários logs de eventos. Por exemplo, o aplicativo pode exigir várias fontes configuradas para logs de eventos diferentes ou arquivos de recurso diferente.       Se você alterar o valor de origem, o <xref:System.Diagnostics.EventLog>para que ele está registrado é fechado e todos os identificadores de evento são liberados.</xref:System.Diagnostics.EventLog>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Para alterar os detalhes de configuração de uma fonte existente, você deve excluir a fonte e, em seguida, criá-lo com a nova configuração. Se outros aplicativos ou componentes de usam a fonte existente, crie uma nova fonte com a configuração atualizada em vez de excluir a fonte existente.      > [!NOTE] > Se uma fonte já foi mapeada para um log e remapear a um novo log, você deve reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "O nome registrado com o log de eventos como uma fonte de entradas. O padrão é uma cadeia de caracteres vazia (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome da fonte resulta em um caminho de chave de registro mais de 254 caracteres."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se uma fonte de evento é registrada no computador local."
  remarks: "Use esse método para determinar se uma fonte de eventos existe no computador local. Se você quiser determinar se um log existe no computador local, use <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Como esse método acessa o registro, você deve ter as permissões de registro apropriados no computador local. Caso contrário, um <xref:System.Security.SecurityException>será lançada.</xref:System.Security.SecurityException>      > [!NOTE] > Para pesquisar uma fonte de evento no Windows Vista e posterior ou Windows Server 2003, você deve ter privilégios administrativos.   >> O motivo disso é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não tem permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>   >> Iniciando com o Windows Vista, controle de conta de usuário (UAC) determina os privilégios de um usuário. Se você for um membro do grupo Administradores interno, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de usuário padrão e um token de acesso de administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa os contadores de desempenho, primeiro elevar seus privilégios de usuário padrão para o administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.      > [!NOTE] > Um serviço que está executando sob o <xref:System.ServiceProcess.ServiceAccount>conta não tem os privilégios necessários para executar esse método.</xref:System.ServiceProcess.ServiceAccount> A solução é verificar se a origem do evento existe no <xref:System.ServiceProcess.ServiceInstaller>, e se ele não existir, para criar a fonte do instalador.</xref:System.ServiceProcess.ServiceInstaller>       Como você não pode dar uma nova fonte de nome de uma fonte existente no mesmo computador, use este método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>para garantir que uma fonte com o nome especificado pelo `source` ainda não existir no computador local.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> O `source` parâmetro não diferencia maiusculas de minúsculas."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "O nome de origem do evento."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a origem do evento é registrada no computador local. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>não foi encontrado, mas alguns ou todos os logs de eventos não podem ser pesquisados."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se uma fonte de evento é registrada em um computador especificado."
  remarks: "Use esse método para determinar se uma fonte de eventos existe no computador especificado o `machineName` parâmetro. Se você quiser determinar se um log existe no computador especificado, use <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Como esse método acessa o registro, você deve ter as permissões de registro apropriados no servidor especificado. Caso contrário, um <xref:System.Security.SecurityException>será lançada.</xref:System.Security.SecurityException>      > [!NOTE] > Para pesquisar uma fonte de evento no Windows Vista e posterior ou Windows Server 2003, você deve ter privilégios administrativos.   >> O motivo disso é que todos os logs de eventos, incluindo segurança, devem ser pesquisados para determinar se a origem do evento é exclusiva. Começando com o Windows Vista, os usuários não tem permissão para acessar o log de segurança; Portanto, um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>   >> Iniciando com o Windows Vista, controle de conta de usuário (UAC) determina os privilégios de um usuário. Se você for um membro do grupo Administradores interno, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de usuário padrão e um token de acesso de administrador. Por padrão, você está na função de usuário padrão. Para executar o código que acessa os contadores de desempenho, primeiro elevar seus privilégios de usuário padrão para o administrador. Você pode fazer isso quando você iniciar um aplicativo clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.      > [!NOTE] > Um serviço que está executando sob o <xref:System.ServiceProcess.ServiceAccount>conta não tem os privilégios necessários para executar esse método.</xref:System.ServiceProcess.ServiceAccount> A solução é verificar se a origem do evento existe no <xref:System.ServiceProcess.ServiceInstaller>, e se ele não existir, para criar a fonte do instalador.</xref:System.ServiceProcess.ServiceInstaller>       Como você não pode dar uma nova fonte de nome de uma fonte existente no mesmo computador, use este método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>para garantir que uma fonte com o nome especificado pelo `source` ainda não existir no computador.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> O `source` e `machineName` parâmetros não diferenciam maiusculas de minúsculas.       <xref:System.Diagnostics.EventLog.SourceExists%2A>é um `static` método, portanto ele pode ser chamado na própria classe.</xref:System.Diagnostics.EventLog.SourceExists%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>chamar <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog>"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome de origem do evento."
    - id: machineName
      type: System.String
      description: "O nome do computador no qual procurar, ou &quot;.&quot; para o computador local."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a origem do evento é registrada no computador especificado. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>é um nome de computador inválido."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>não foi encontrado, mas alguns ou todos os logs de eventos não podem ser pesquisados."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o objeto usado para empacotar as chamadas de manipulador de eventos emitidas como resultado de uma <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> gravada um evento de entrada."
  remarks: "Quando for SynchronizingObject `null`, métodos de manipulação de <xref:System.Diagnostics.EventLog.EntryWritten>eventos são chamados em um thread do pool de threads do sistema.</xref:System.Diagnostics.EventLog.EntryWritten> Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando o <xref:System.Diagnostics.EventLog.EntryWritten>evento é manipulado por um visual Windows Forms componente, como um botão, acessando o componente através do pool de threads de sistema pode não funcionar, ou pode resultar em uma exceção.</xref:System.Diagnostics.EventLog.EntryWritten> Evitar isso, definindo SynchronizingObject como um componente de Windows Forms, que faz com que os métodos de manipulação de <xref:System.Diagnostics.EventLog.EntryWritten>evento seja chamado no mesmo thread em que o componente foi criado.</xref:System.Diagnostics.EventLog.EntryWritten>       Se o <xref:System.Diagnostics.EventLog>é usado dentro de [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] em um designer de formulários do Windows, SynchronizingObject é definida automaticamente como o controle que contém o <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> Por exemplo, se você colocar um <xref:System.Diagnostics.EventLog>em um designer para Form1 (que herda de <xref:System.Windows.Forms.Form>) a propriedade SynchronizingObject <xref:System.Diagnostics.EventLog>está definido para a instância do Form1.</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "O <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> usado para empacotar as chamadas do manipulador de eventos emitidas como resultado de uma <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> eventos no log de eventos."
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada de tipo de informação, com o texto da mensagem determinada, o log de eventos."
  remarks: "Use esse método para gravar uma entrada de informações no log de evento associado a esta <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> Se você quiser especificar quaisquer outros <xref:System.Diagnostics.EventLogEntryType>use uma sobrecarga diferente de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes que você possa gravar entradas no log.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Se a fonte especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e registra o código-fonte.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada e <xref:System.Diagnostics.EventLog.WriteEntry%2A>a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida em sua <xref:System.Diagnostics.EventLog>instância, o log padrão é o log de aplicativo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas das exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) pode não ser o esperado se o computador remoto não está em execução do .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava um erro, aviso, informações, auditoria com êxito ou entrada de auditoria de falha com o texto de mensagem fornecida para o log de eventos."
  remarks: "Use esse método para gravar uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType>para o log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes que você possa gravar entradas no log.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Se a fonte especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e registra o código-fonte.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada e <xref:System.Diagnostics.EventLog.WriteEntry%2A>a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida em sua <xref:System.Diagnostics.EventLog>instância, o log padrão é o log de aplicativo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) pode não ser o esperado se o computador remoto não está em execução do .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada de tipo de informação com o texto de mensagem fornecida para o log de eventos, usando a fonte de evento registrado especificado."
  remarks: "Use esse método para gravar uma entrada de informações no log de evento, usando uma fonte que já está registrada como uma fonte de evento para o log adequado. Se você quiser especificar quaisquer outros <xref:System.Diagnostics.EventLogEntryType>use uma sobrecarga diferente de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL.   >> De `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem especificado e o identificador de evento definido pelo aplicativo para o log de eventos."
  remarks: "Use esse método para gravar uma entrada com um aplicativo definido `eventID` o log de eventos. O `eventID` junto com a fonte de identificar um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de evento exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Além do identificador de evento, você pode especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes que você possa gravar entradas no log.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Se a fonte especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e registra o código-fonte.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada e <xref:System.Diagnostics.EventLog.WriteEntry%2A>a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida em sua <xref:System.Diagnostics.EventLog>instância, o log padrão é o log de aplicativo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) pode não ser o esperado se o computador remoto não está em execução do .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava um erro, aviso, informações, auditoria com êxito ou entrada de auditoria de falha com o texto de mensagem fornecida para o log de eventos, usando a fonte de evento registrado especificado."
  remarks: "Use esse método para gravar uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType>para o log de eventos, usando uma fonte já registrada como uma fonte de evento para o log de apropriado.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem determinada, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo para o log de eventos."
  remarks: "Use esse método para gravar uma entrada com um aplicativo definido `category` o log de eventos. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma fonte de evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos de categoria aparecem como um número positivo complementar no evento visualizador. Por exemplo, um – 10 aparece como 65,526, 1 como 65.535.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso de categoria e defina o `category` para um identificador de recurso no arquivo de recurso de categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso de categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso de categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recursos, usando o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Além da categoria, você pode especificar um identificador de evento para o evento que está sendo gravado no log de eventos. Identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de evento exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.       Por fim, você pode especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes que você possa gravar entradas no log.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Se a fonte especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e registra o código-fonte.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada e <xref:System.Diagnostics.EventLog.WriteEntry%2A>a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida em sua <xref:System.Diagnostics.EventLog>instância, o log padrão é o log de aplicativo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) pode não ser o esperado se o computador remoto não está em execução do .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específico do aplicativo associada à mensagem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem especificado e o identificador de evento definido pelo aplicativo para o log de eventos, usando a fonte de evento registrado especificado."
  remarks: "Use esse método para gravar uma entrada com um aplicativo definido `eventID` o log de eventos, usar uma fonte já registrado como uma fonte de evento para o log adequado. O `eventID`, junto com a fonte, identificar exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Visualizadores de evento apresentam essas cadeias de caracteres para o usuário para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.       Além do identificador de evento, essa sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A>permite que você especifique um <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> </xref:System.Diagnostics.EventLog.WriteEntry%2A> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem determinada, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo para o log de eventos e acrescenta dados binários para a mensagem."
  remarks: "Use essa sobrecarga para gravar dados de eventos específicos definidos pelo aplicativo para o log de eventos. O Visualizador de eventos não interpretar esses dados; ele exibe dados brutos somente em um formato hexadecimal e texto combinado. Use dados de eventos específicos com cautela, incluí-lo somente se você tiver certeza de que será útil para alguém depuração do problema. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você pode escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o arquivo de log e cria relatórios que incluem informações sobre os dados de eventos específicos.       Além dos dados binários, você pode especificar uma categoria definida pelo aplicativo e um identificador de evento definido pelo aplicativo. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma fonte de evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.      > [!NOTE] > O `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos de categoria aparecem como um número positivo complementar no evento visualizador. Por exemplo, um – 10 aparece como 65,526, 1 como 65.535.       Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso de categoria e defina o `category` para um identificador de recurso no arquivo de recurso de categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso de categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso de categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recursos, usando o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de evento exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.       Por fim, você pode especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes que você possa gravar entradas no log.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem.       Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       Se a fonte especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registrada no computador que o componente está gravando, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e registra o código-fonte.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema precisa registrar o <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada e <xref:System.Diagnostics.EventLog.WriteEntry%2A>a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida em sua <xref:System.Diagnostics.EventLog>instância, o log padrão é o log de aplicativo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima são geradas por erros gerados durante o processo de registro de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você gravar uma entrada em um computador remoto, o valor da mensagem (a cadeia de caracteres de texto) pode não ser o esperado se o computador remoto não está em execução do .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específico do aplicativo associada à mensagem."
    - id: rawData
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados à entrada."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem determinada, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo para o log de eventos, usando a fonte de evento registrado especificado. O <code> category </code> pode ser usado pelo Visualizador de eventos para filtrar o log de eventos."
  remarks: "Use esse método para gravar uma entrada com um aplicativo definido `category` o log de eventos, usando uma fonte que já está registrada como uma fonte de evento para o log adequado. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma fonte de evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos de categoria aparecem como um número positivo complementar no evento visualizador. Por exemplo, um – 10 aparece como 65,526, 1 como 65.535.       Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso de categoria e defina o `category` para um identificador de recurso no arquivo de recurso de categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso de categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso de categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recursos, usando o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Além da categoria, você pode especificar um identificador de evento para o evento que está sendo gravado no log de eventos. Identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de evento exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.       Por fim, você pode especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL.   >> De `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específico do aplicativo associada à mensagem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada com o texto da mensagem determinada, o identificador de evento definido pelo aplicativo e a categoria definida pelo aplicativo para o log de eventos (usando a origem do evento registrado especificado) e anexa os dados binários para a mensagem."
  remarks: "Use esse método para gravar dados de eventos específicos definidos pelo aplicativo para o log de eventos, usando uma fonte já registrada como uma fonte de evento para o log adequado. O Visualizador de eventos não interpretar esses dados; ele exibe dados brutos somente em um formato hexadecimal e texto combinado. Usar dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza de que será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você pode escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o arquivo de log e cria relatórios que incluem informações sobre os dados de eventos específicos.       Além dos dados binários, você pode especificar uma categoria definida pelo aplicativo e um identificador de evento definido pelo aplicativo. O Visualizador de eventos usa a categoria para filtrar eventos gravados por uma fonte de evento. O Visualizador de eventos pode exibir a categoria como um valor numérico, ou pode usar a categoria como um identificador de recurso para exibir uma cadeia de caracteres da categoria localizada.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos de categoria aparecem como um número positivo complementar no evento visualizador. Por exemplo, um – 10 aparecerá como 65,526, 1 como 65.535.       Para exibir cadeias de caracteres da categoria localizada no Visualizador de eventos, você deve usar uma fonte de evento configurado com um arquivo de recurso de categoria e defina o `category` para um identificador de recurso no arquivo de recurso de categoria. Se a origem do evento não tem um arquivo de recurso da categoria configurado ou especificado `category` não indexa uma cadeia de caracteres no arquivo de recurso de categoria, em seguida, o Visualizador de eventos exibe o valor da categoria numérica para a entrada. Configurar o arquivo de recurso de categoria, juntamente com o número de cadeias de caracteres de categoria no arquivo de recursos, usando o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Identificadores de evento, junto com a origem do evento, identificam exclusivamente um evento. Cada aplicativo pode definir seus próprios eventos numerados e as cadeias de caracteres de descrição para o qual eles são mapeados. Os visualizadores de evento exibem esses valores de cadeia de caracteres para ajudar o usuário a entender o que deu errado e sugerir ações a serem tomadas.       Por fim, você pode especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está sendo gravado no log de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` é indicado por um ícone e texto na coluna de tipo no Visualizador de eventos para um log. Esse parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falha.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grava a cadeia de caracteres fornecida diretamente para o log de eventos; ele não usa um arquivo de recurso de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Use o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método gravar eventos usando um arquivo de recurso de mensagem localizada.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caractere NUL, a mensagem no log de eventos é encerrada no caractere NUL.   >> De `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "A origem pelo qual o aplicativo está registrado no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia de caracteres para gravar no log de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Uma da <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico do aplicativo para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específico do aplicativo associada à mensagem."
    - id: rawData
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados à entrada."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>não é válido <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada localizada para o log de eventos."
  remarks: "Use esse método para gravar uma entrada localizada no log de eventos. Você pode especificar as propriedades de evento com identificadores de recursos em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recursos para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Você deve registrar a fonte de arquivo de recurso correspondente antes de gravar eventos usando identificadores de recursos.       A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Você pode definir opcionalmente o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>da `instance` entrada para definir o tipo de categoria e eventos da sua entrada de evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação de cadeias de caracteres de substituição.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> A origem especificada deve ser configurada para gravar entradas localizadas em log; no mínimo, o de origem deve ter um arquivo de recurso de mensagem definido.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se seu aplicativo grava os valores de cadeia de caracteres diretamente para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você escrever uma entrada para um computador remoto, o valor de `message` cadeia de caracteres não pode ser o esperado se o computador remoto não está em execução do .NET Framework. Além disso, o `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de log de eventos localizada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada do log de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada de log de eventos com os dados de determinado evento, cadeias de caracteres de substituição de mensagem e os dados binários associados."
  remarks: "Use esse método para escrever uma entrada localizada com dados de eventos específicos adicionais no log de eventos. Você pode especificar as propriedades de evento com identificadores de recursos em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recursos para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizado para <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Você deve registrar a fonte de arquivo de recurso correspondente antes de gravar eventos usando identificadores de recursos.       A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Você pode definir opcionalmente o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>da `instance` entrada para definir o tipo de categoria e eventos da sua entrada de evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação de cadeias de caracteres de substituição.       Especifique os dados binários com um evento quando é necessário fornecer mais detalhes sobre o evento. Por exemplo, use o `data` parâmetro para incluir informações sobre um erro específico. O Visualizador de eventos não interpretar os dados de evento associado; ele exibe os dados em um formato hexadecimal e texto combinado. Usar dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza de que será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você pode escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o log de eventos e cria relatórios que incluem informações sobre os dados de eventos específicos.       Você deve definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes do componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> A origem especificada deve ser configurada para gravar entradas localizadas em log; no mínimo, o de origem deve ter um arquivo de recurso de mensagem definido.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.      > [!NOTE] > Se você não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.WriteEvent%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se seu aplicativo grava os valores de cadeia de caracteres diretamente para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se você escrever uma entrada para um computador remoto, o valor de `message` cadeia de caracteres não pode ser o esperado se o computador remoto não está em execução do .NET Framework. Além disso, o `message` cadeia de caracteres não pode conter %*n*, onde *n* é um valor inteiro (por exemplo, %1) porque o Visualizador de eventos tratá-la como uma cadeia de caracteres de inserção. Como um protocolo de Internet versão endereço de 6 (IPv6) pode conter essa sequência de caracteres, você não pode registrar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de log de eventos localizada."
    - id: data
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados à entrada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada do log de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava uma entrada de log de eventos com evento cadeias de substituição de dados e a mensagem, usando a fonte de evento registrado especificado."
  remarks: "Use esse método para gravar uma entrada localizada no log de evento, usando uma fonte já registrada como uma fonte de evento para o log adequado. Você pode especificar as propriedades de evento com identificadores de recursos em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recursos para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizada para a fonte. Você deve registrar a fonte de arquivo de recurso correspondente antes de gravar eventos usando identificadores de recursos.       A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Você pode definir opcionalmente o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>da `instance` entrada para definir o tipo de categoria e eventos da sua entrada de evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação de cadeias de caracteres de substituição.       A origem especificada deve ser registrada para um log de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> A origem especificada deve ser configurada para gravar entradas localizadas em log; no mínimo, o de origem deve ter um arquivo de recurso de mensagem definido.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se seu aplicativo grava os valores de cadeia de caracteres diretamente para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de eventos registrado para o aplicativo no computador especificado."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de log de eventos localizada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada do log de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Grava um evento de entrada de log com os dados de determinado evento, cadeias de caracteres de substituição de mensagem e os dados binários associados e usar especificado registrado a origem do evento."
  remarks: "Use esse método para escrever uma entrada localizada com dados de eventos específicos adicionais no log de evento, usando uma fonte já registrada como uma fonte de evento para o log adequado. Você pode especificar as propriedades de evento com identificadores de recursos em vez de valores de cadeia de caracteres. O Visualizador de eventos usa os identificadores de recursos para exibir as cadeias de caracteres correspondentes do arquivo de recurso localizada para a fonte. Você deve registrar a fonte de arquivo de recurso correspondente antes de gravar eventos usando identificadores de recursos.       A entrada `instance` instância Especifica as propriedades e a mensagem de evento. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no arquivo de recurso de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Você pode definir opcionalmente o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>da `instance` entrada para definir o tipo de categoria e eventos da sua entrada de evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Você também pode especificar uma matriz de cadeias de caracteres independente de linguagem para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém espaços reservados de formatação de cadeias de caracteres de substituição.       Especifique os dados binários com um evento quando é necessário fornecer mais detalhes sobre o evento. Por exemplo, use o `data` parâmetro para incluir informações sobre um erro específico. O Visualizador de eventos não interpretar os dados de evento associado; ele exibe os dados em um formato hexadecimal e texto combinado. Usar dados de eventos específicos com moderação; incluí-lo somente se você tiver certeza de que será útil. Você também pode usar dados de eventos específicos para armazenar informações que o aplicativo pode processar independentemente do Visualizador de eventos. Por exemplo, você pode escrever um visualizador especificamente para seus eventos ou escrever um programa que examina o log de eventos e cria relatórios que incluem informações sobre os dados de eventos específicos.       A origem especificada deve ser registrada para um log de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> A origem especificada deve ser configurada para gravar entradas localizadas em log; no mínimo, o de origem deve ter um arquivo de recurso de mensagem definido.       Você deve criar e configurar a origem do evento antes de gravar a primeira entrada com a origem. Crie a nova fonte de evento durante a instalação do seu aplicativo. Isso permite que o tempo para o sistema operacional atualizar sua lista de fontes de eventos registrados e suas configurações. Se o sistema operacional não foi atualizado para a sua lista de fontes de eventos, e você tentar gravar um evento com a nova fonte, que haverá falha na operação de gravação. Você pode configurar uma nova fonte usando um <xref:System.Diagnostics.EventLogInstaller>, ou usando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Você deve ter direitos administrativos no computador para criar uma nova fonte de evento.       A origem deve ser configurada para gravar entradas localizadas ou para a gravação de cadeias de caracteres diretas. Use o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se seu aplicativo grava os valores de cadeia de caracteres diretamente para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se seu aplicativo grava entradas usando identificadores de recursos e os valores de cadeia de caracteres, você deve registrar duas fontes separadas. Por exemplo, configure uma fonte com arquivos de recurso e, em seguida, usar essa fonte no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método grave entradas usando identificadores de recursos para o log de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma fonte diferente sem arquivos de recurso e usar essa fonte do <xref:System.Diagnostics.EventLog.WriteEntry%2A>método grave cadeias de caracteres diretamente para o log de eventos usando essa fonte.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de eventos registrado para o aplicativo no computador especificado."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de log de eventos localizada."
    - id: data
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados à entrada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias de caracteres para mesclar o texto da mensagem da entrada do log de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave do registro para o log de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operacional relatou um erro ao gravar a entrada de evento no log de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
