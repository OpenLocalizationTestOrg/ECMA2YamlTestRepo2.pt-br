### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Fornece um pool de threads que podem ser usados para executar tarefas, postagem de itens de trabalho, processar e/s assíncrona, aguardar em nome de outros threads e processar timers."
  remarks: "Muitos aplicativos criam threads que gastam uma grande quantidade de tempo no estado suspenso, aguardando um evento ocorra. Outros threads podem entrar em um estado suspenso apenas para ser ativado periodicamente para sondar uma alteração ou atualizar as informações de status. O pool de threads permite que você use threads com mais eficiência, fornecendo o seu aplicativo com um pool de threads de trabalho que são gerenciados pelo sistema. Exemplos de operações que usam threads do pool incluem o seguinte: - quando você cria um <xref:System.Threading.Tasks.Task>ou <xref:System.Threading.Tasks.Task%601>objeto para executar algumas tarefas de forma assíncrona, por padrão, a tarefa está agendada para ser executado em um pool de threads.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Temporizadores assíncronas usam o pool de threads. Threads de pool executar retornos de chamada de <xref:System.Threading.Timer?displayProperty=fullName>classe e acionar eventos da <xref:System.Timers.Timer?displayProperty=fullName>classe</xref:System.Timers.Timer?displayProperty=fullName> de</xref:System.Threading.Timer?displayProperty=fullName>      -Quando você usar identificadores de espera de registrado, um thread do sistema monitora o status dos identificadores de espera. Quando uma operação de espera é concluída, um thread do pool de threads de trabalho executa a função de retorno de chamada correspondente.      -Quando você chamar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>método para a fila de um método para execução em um pool de threads.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Para fazer isso, passando-o um <xref:System.Threading.WaitCallback>delegar.</xref:System.Threading.WaitCallback>   O representante tem a assinatura <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> onde `state` é um objeto que contém dados a serem usados pelo delegado.    Os dados reais podem ser passados para o delegado chamando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Os threads no pool de threads gerenciados são threads em segundo plano. Isto é, seus <xref:System.Threading.Thread.IsBackground%2A>propriedades são `true`.</xref:System.Threading.Thread.IsBackground%2A> Isso significa que um thread de pool de threads não manterá um aplicativo em execução depois que todos os threads de primeiro plano serem encerrados.      > [!IMPORTANT] > Quando o pool de threads reutiliza um thread, ele não limpa os dados no armazenamento local de thread ou em campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo.</xref:System.ThreadStaticAttribute> Portanto, quando um método examina o armazenamento local de thread ou campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo, os valores encontrados podem ser restantes do uso anterior do thread do pool.</xref:System.ThreadStaticAttribute>       Também é possível enfileirar itens de trabalho que não estão relacionados a uma operação de espera para o pool de threads. Para solicitar que um item de trabalho ser manipulada por um thread no pool de threads, chame o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Esse método aceita como um parâmetro de uma referência para o método ou delegate que será chamado pelo thread selecionado do pool de threads. Não é possível cancelar um item de trabalho depois que ele foi enfileirado.       Timers de fila de timer e operações de espera registrado também usam o pool de threads. Suas funções de retorno de chamada são enfileiradas para o pool de threads.       Há um pool de threads por processo. Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o tamanho padrão do pool de threads para um processo depende de vários fatores, como o tamanho do espaço de endereço virtual. Um processo pode chamar o <xref:System.Threading.ThreadPool.GetMaxThreads%2A>método para determinar o número de threads.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> O número de threads no pool de threads pode ser alterado usando o <xref:System.Threading.ThreadPool.SetMaxThreads%2A>método.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Cada thread usa o tamanho da pilha padrão e é executado com a prioridade padrão.      > [!NOTE] > Código não gerenciado que hospeda o .NET Framework pode alterar o tamanho do pool de threads, usando o `CorSetMaxThreads` função, definida no arquivo mscoree.h.       O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria. Quando um mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas. Começando com o [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads de trabalho para otimizar a taxa de transferência, que é definida como o número de tarefas que são concluídas por unidade de tempo. Há muito poucos threads não podem fazer uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.      > [!NOTE] > Quando a demanda for baixa, o número real de threads de pool pode ficar abaixo os valores mínimos.       Você pode usar o <xref:System.Threading.ThreadPool.GetMinThreads%2A>método para obter esses valores mínimos.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A>método para aumentar o número mínimo de threads.</xref:System.Threading.ThreadPool.SetMinThreads%2A> No entanto, esses valores de aumento desnecessariamente podem causar problemas de desempenho. Se iniciam muitas tarefas ao mesmo tempo, todos eles podem parecer ser lenta. Na maioria dos casos o pool de threads terão um desempenho melhor com seu próprio algoritmo para alocar threads."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Associa um identificador de sistema operacional para o <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "Um <xref:System.IntPtr>que contém o identificador.</xref:System.IntPtr> O identificador deve ter aberto para e/s sobreposta no lado não gerenciado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador estiver associado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Associa um identificador de sistema operacional para o <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "O `osHandle` parâmetro deve ser um <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>que é derivada da <xref:System.Runtime.InteropServices.SafeHandle>classe</xref:System.Runtime.InteropServices.SafeHandle> abstrata de</xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "Um <xref:System.Runtime.InteropServices.SafeHandle>que contém o identificador de sistema operacional.</xref:System.Runtime.InteropServices.SafeHandle> O identificador deve ter aberto para e/s sobreposta no lado não gerenciado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador estiver associado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera a diferença entre o número máximo de threads de pool retornado pelo <xref:System.Threading.ThreadPool.GetMaxThreads*>método e o número de ativo no momento.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "Quando retorna GetAvailableThreads, a variável especificada pela `workerThreads` contém o número de threads de trabalho adicional que podem ser iniciados e a variável especificada pela `completionPortThreads` contém o número de adicionais threads de e/s assíncronas que pode ser iniciado.       Se não houver nenhum threads disponíveis, as solicitações de pool de threads adicionais permanecem na fila até que os threads de pool se tornam disponível."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "O número de threads de trabalho disponíveis."
    - id: completionPortThreads
      type: System.Int32
      description: "O número de threads de e/s assíncronos disponíveis."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera o número de solicitações para o pool de threads que podem estar ativas simultaneamente. Todas as solicitações acima desse número permanecem na fila até que os threads de pool se tornam disponível."
  remarks: "Quando retorna GetMaxThreads, a variável especificada pela `workerThreads` contém o número máximo de threads de trabalho permitidos no pool de threads e a variável especificada pela `completionPortThreads` contém o número máximo de threads de e/s assíncronas permitidas no pool de threads.       Você pode usar o <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>método para determinar o número real de threads no pool de threads a qualquer momento.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Você pode usar o <xref:System.Threading.ThreadPool.SetMaxThreads%2A>para definir o número máximo de threads de trabalho e os threads de e/s assíncronas no pool de threads.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       É possível enfileirar como muitas solicitações de pool de threads permite a memória do sistema. Se houver mais solicitações que threads de pool, as solicitações adicionais permanecem na fila até que os threads de pool se tornam disponível."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "O número máximo de threads de trabalho no pool de threads."
    - id: completionPortThreads
      type: System.Int32
      description: "O número máximo de threads de e/s assíncronas no pool de threads."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera o número mínimo de threads que do pool de threads cria sob demanda, as novas solicitações são feitas, antes de alternar para um algoritmo para gerenciar a destruição e criação de threads."
  remarks: "O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria. Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema. Quando o mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas. Começando com o [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas que são concluídas por unidade de tempo. Há muito poucos threads não podem fazer uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.      > [!NOTE] > Quando a demanda for baixa, o número real de threads de pool pode ficar abaixo os valores mínimos."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Quando este método retorna, contém o número mínimo de threads de trabalho que cria o pool de threads sob demanda."
    - id: completionPortThreads
      type: System.Int32
      description: "Quando este método retorna, contém o número mínimo de threads de e/s assíncronas que cria o pool de threads sob demanda."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Enfileira um método para execução. O método é executado quando um thread do pool se torna disponível."
  remarks: "Você pode colocar dados requeridos pelo método na fila nos campos de instância da classe na qual o método é definido, ou você pode usar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>sobrecarga que aceita um objeto que contém os dados necessários.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Usuários do Visual Basic podem omitir o <xref:System.Threading.WaitCallback>construtor e simplesmente usar a `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic automaticamente chama construtor delegado correto.      ## Versão informações no .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Um <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> que representa o método a ser executado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o método foi enfileirado com êxito; <xref:System.NotSupportedException>é gerada se o item de trabalho não foi possível enfileirar.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O common language runtime (CLR) está hospedado, e o host não dá suporte a esta ação."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Enfileira um método de execução e especifica um objeto que contém dados a serem usados pelo método. O método é executado quando um thread do pool se torna disponível."
  remarks: "Se o método de retorno de chamada requer dados complexos, você pode definir uma classe para conter os dados.      > [!NOTE] > Usuários do Visual Basic podem omitir o <xref:System.Threading.WaitCallback>construtor e simplesmente usar a `AddressOf` operador ao passar o método de retorno de chamada para QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic automaticamente chama construtor delegado correto.      ## Versão informações no .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Um <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> que representa o método a ser executado."
    - id: state
      type: System.Object
      description: "Um objeto que contém dados a serem usados pelo método."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o método foi enfileirado com êxito; <xref:System.NotSupportedException>é gerada se o item de trabalho não foi possível enfileirar.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O common language runtime (CLR) está hospedado, e o host não dá suporte a esta ação."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um inteiro assinado de 32 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle>"
  remarks: "Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O método RegisterWaitForSingleObject enfileira o delegado especificado para o pool de threads. Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:-o objeto especificado está no estado sinalizado.      -O intervalo de tempo limite expira.       O método RegisterWaitForSingleObject verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Se o estado do objeto for sinalizado, o método registra uma operação de espera. A operação de espera é executada por um thread do pool de threads. O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira. Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.      > [!IMPORTANT] > Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex> Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore>com uma contagem máxima de 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado. Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em várias chamadas para RegisterWaitForSingleObject, você deverá duplicar o identificador do Win32 `DuplicateHandle` função. Observe que você não deve pulso um objeto de evento passado para RegisterWaitForSingleObject, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.       Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização. Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida. Por exemplo, a contagem de um semáforo é reduzida por um.      ## Informações de versão iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegado para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> que encapsula o identificador nativo."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> millisecondsTimeOutInterval </code> parâmetro é menor que -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um inteiro assinado de 64 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle>"
  remarks: "Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O método RegisterWaitForSingleObject enfileira o delegado especificado para o pool de threads. Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:-o objeto especificado está no estado sinalizado.      -O intervalo de tempo limite expira.       O método RegisterWaitForSingleObject verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Se o estado do objeto for sinalizado, o método registra uma operação de espera. A operação de espera é executada por um thread do pool de threads. O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira. Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.      > [!IMPORTANT] > Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex> Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore>com uma contagem máxima de 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado. Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em várias chamadas para RegisterWaitForSingleObject, você deverá duplicar o identificador do Win32 `DuplicateHandle` função. Observe que você não deve pulso um objeto de evento passado para RegisterWaitForSingleObject, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.       Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização. Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida. Por exemplo, a contagem de um semáforo é reduzida por um.      ## Informações de versão iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegado para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> que encapsula o identificador nativo."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> millisecondsTimeOutInterval </code> parâmetro é menor que -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um <xref:System.TimeSpan>valor para o tempo limite.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O método RegisterWaitForSingleObject enfileira o delegado especificado para o pool de threads. Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:-o objeto especificado está no estado sinalizado.      -O intervalo de tempo limite expira.       O método RegisterWaitForSingleObject verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Se o estado do objeto for sinalizado, o método registra uma operação de espera. A operação de espera é executada por um thread do pool de threads. O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira. Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.      > [!IMPORTANT] > Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex> Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore>com uma contagem máxima de 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado. Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em várias chamadas para RegisterWaitForSingleObject, você deverá duplicar o identificador do Win32 `DuplicateHandle` função. Observe que você não deve pulso um objeto de evento passado para RegisterWaitForSingleObject, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.       Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização. Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida. Por exemplo, a contagem de um semáforo é reduzida por um.      ## Informações de versão iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegado para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto passado para o delegado."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo limite representado pelo <xref:System.TimeSpan>.</xref:System.TimeSpan> Se `timeout` for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `timeout` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> que encapsula o identificador nativo."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> timeout </code> parâmetro é menor que -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O <code> timeout </code> parâmetro for maior que &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um inteiro não assinado de 32 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle>"
  remarks: "Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método enfileira o delegado especificado para o pool de threads.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:-o objeto especificado está no estado sinalizado.      -O intervalo de tempo limite expira.       O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> </xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Se o estado do objeto for sinalizado, o método registra uma operação de espera. A operação de espera é executada por um thread do pool de threads. O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira. Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.      > [!IMPORTANT] > Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex> Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore>com uma contagem máxima de 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado. Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deverá duplicar o identificador usando o Win32 `DuplicateHandle` função.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização. Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida. Por exemplo, a contagem de um semáforo é reduzida por um.      ## Informações de versão iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Em versões anteriores, as informações de entidade não são propagadas."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegado para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> que pode ser usado para cancelar a operação de espera registrado."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> millisecondsTimeOutInterval </code> parâmetro é menor que -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o número de solicitações para o pool de threads que pode estar ativo simultaneamente. Todas as solicitações acima desse número permanecem na fila até que os threads de pool se tornam disponível."
  remarks: "Você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número de processadores no computador. Para determinar quantos processadores estão presentes, recuperar o valor da <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>propriedade.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> Além disso, você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número correspondente de mínimo de threads de trabalho ou threads de conclusão de e/s. Para determinar o tamanho do pool de threads mínimo, chame o <xref:System.Threading.ThreadPool.GetMinThreads%2A>método.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Se o common language runtime está hospedado, por exemplo, serviços de informações da Internet (IIS) ou SQL Server, o host pode limitar ou impedir alterações para o tamanho do pool de threads.       Tenha cuidado ao alterar o número máximo de threads no pool de threads. Enquanto seu código pode se beneficiar, as alterações podem ter um efeito adverso em bibliotecas de código que você usa.       Definir o tamanho do pool de threads muito grande pode causar problemas de desempenho. Se muitos threads estão em execução ao mesmo tempo, a alternância de tarefa sobrecarga se torna um fator importante."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "O número máximo de threads de trabalho no pool de threads."
    - id: completionPortThreads
      type: System.Int32
      description: "O número máximo de threads de e/s assíncronas no pool de threads."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a alteração for bem-sucedida; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o número mínimo de threads que do pool de threads cria sob demanda, as novas solicitações são feitas, antes de alternar para um algoritmo para gerenciar a destruição e criação de threads."
  remarks: "O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria. Quando o mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas. Começando com o [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas que são concluídas por unidade de tempo. Há muito poucos threads não podem fazer uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.       Quando a demanda for baixa, o número real de threads de pool pode ficar abaixo os valores mínimos.       Se você especificar um número negativo ou um número maior que o número máximo de threads de pool de thread ativo (obtidos usando <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), retorna SetMinThreads `false` e não altera qualquer um dos valores mínimo.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema. Você pode usar o método SetMinThreads para aumentar a ofthreads número mínimo. No entanto, esses valores de aumento desnecessariamente podem causar problemas de desempenho. Se iniciam muitas tarefas ao mesmo tempo, todos eles podem parecer ser lenta. Na maioria dos casos, o pool de threads terão um desempenho melhor com seu próprio algoritmo para alocar threads. Reduzindo o mínimo menor que o número de processadores também pode prejudicar o desempenho."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "O número mínimo de threads de trabalho que cria o pool de threads sob demanda."
    - id: completionPortThreads
      type: System.Int32
      description: "O número mínimo de threads de e/s assíncronas que cria o pool de threads sob demanda."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a alteração for bem-sucedida; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Enfileira uma operação de e/s sobreposta para execução."
  remarks: "Para obter informações sobre como usar o Win32 nativo sobreposto e/s, consulte o <xref:System.Threading.Overlapped>classe, o <xref:System.Threading.NativeOverlapped>estrutura e o `OVERLAPPED` estrutura no SDK da plataforma Win32.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      > [!CAUTION] > Usando o UnsafeQueueNativeOverlapped método inadvertidamente foi possível abrir a uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeQueueNativeOverlapped, a pilha do thread do pool não tem o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "O <xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> estrutura à fila."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a operação foi enfileirada com êxito em uma porta de conclusão de e/s; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Enfileira o delegado especificado para o pool de threads, mas não se propaga a pilha de chamada para o thread de trabalho."
  remarks: "Ao contrário de <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>método, UnsafeQueueUserWorkItem não propaga a pilha de chamada para o thread de trabalho.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.      > [!CAUTION] > UnsafeQueueUserWorkItem usando inadvertidamente pode abrir uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeQueueUserWorkItem, a pilha do thread do pool não terá o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Um <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> que representa o delegado a ser invocado quando um thread no pool de threads seleciona o item de trabalho."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado quando a manutenção do pool de threads."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o método for bem-sucedido; <xref:System.OutOfMemoryException>é gerada se o item de trabalho não foi possível enfileirar.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Encontrou uma condição de falta de memória."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não foi possível enfileirar o item de trabalho."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, usando um inteiro assinado de 32 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle> Esse método não propaga a pilha de chamada para o thread de trabalho."
  remarks: "Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método, UnsafeRegisterWaitForSingleObject não propaga a pilha de chamada para o thread de trabalho.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject usando inadvertidamente pode abrir uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeRegisterWaitForSingleObject, a pilha do thread do pool não terá o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão.       Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex>       Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O representante para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objeto que pode ser usado para cancelar a operação de espera registrado."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> millisecondsTimeOutInterval </code> parâmetro é menor que -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um inteiro assinado de 64 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle> Esse método não propaga a pilha de chamada para o thread de trabalho."
  remarks: "Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método, UnsafeRegisterWaitForSingleObject não propaga a pilha de chamada para o thread de trabalho.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject usando inadvertidamente pode abrir uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeRegisterWaitForSingleObject, a pilha do thread do pool não terá o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão.       Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex>       Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O representante para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objeto que pode ser usado para cancelar a operação de espera registrado."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> millisecondsTimeOutInterval </code> parâmetro é menor que -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um <xref:System.TimeSpan>valor para o tempo limite.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Esse método não propaga a pilha de chamada para o thread de trabalho."
  remarks: "Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método, UnsafeRegisterWaitForSingleObject não propaga a pilha de chamada para o thread de trabalho.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject usando inadvertidamente pode abrir uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeRegisterWaitForSingleObject, a pilha do thread do pool não terá o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão.       Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex>       Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O representante para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo limite representado pelo <xref:System.TimeSpan>.</xref:System.TimeSpan> Se `timeout` for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `timeout` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objeto que pode ser usado para cancelar a operação de espera registrado."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> timeout </code> parâmetro é menor que -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O <code> timeout </code> parâmetro for maior que &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registra um delegado para aguardar um <xref:System.Threading.WaitHandle>, especificando um inteiro não assinado de 32 bits para o tempo limite em milissegundos.</xref:System.Threading.WaitHandle> Esse método não propaga a pilha de chamada para o thread de trabalho."
  remarks: "Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>método, UnsafeRegisterWaitForSingleObject não propaga a pilha de chamada para o thread de trabalho.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject usando inadvertidamente pode abrir uma falha de segurança. Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha. Quando o trabalho está em fila em um pool de threads usando UnsafeRegisterWaitForSingleObject, a pilha do thread do pool não terá o contexto de chamadores reais. Código mal-intencionado poderá explorar isso para evitar verificações de permissão.       Usando um <xref:System.Threading.Mutex>para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</xref:System.Threading.Mutex>       Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle>que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método para liberar referências para o identificador de espera.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método, mesmo se você especificar `true` para `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>método em vez de dependendo finalizador do identificador de espera registrado.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "O <xref:System.Threading.WaitHandle>para registrar.</xref:System.Threading.WaitHandle> Usar um <xref:System.Threading.WaitHandle>diferente <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "O representante para chamar quando o `waitObject` parâmetro é sinalizado."
    - id: state
      type: System.Object
      description: "O objeto que é passado para o delegado."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "O tempo limite em milissegundos. Se o `millisecondsTimeOutInterval` parâmetro for 0 (zero), a função testa o estado do objeto e retorna imediatamente. Se `millisecondsTimeOutInterval` é -1, o intervalo de tempo limite da função nunca expira."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o thread não aguardará a `waitObject` parâmetro depois que o representante foi chamado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para indicar que ele é zerado sempre que a operação de espera é concluída até que a espera não está registrada."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "O <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objeto que pode ser usado para cancelar a operação de espera registrado."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
