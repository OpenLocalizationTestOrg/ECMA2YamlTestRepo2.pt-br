### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogStore
  id: LogStore
  children:
  - System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogStore.Archivable
  - System.IO.Log.LogStore.BaseSequenceNumber
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.Delete(System.String)
  - System.IO.Log.LogStore.Dispose
  - System.IO.Log.LogStore.Extents
  - System.IO.Log.LogStore.FreeBytes
  - System.IO.Log.LogStore.Handle
  - System.IO.Log.LogStore.LastSequenceNumber
  - System.IO.Log.LogStore.Length
  - System.IO.Log.LogStore.Policy
  - System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.StreamCount
  langs:
  - csharp
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
  type: Class
  summary: "Representa um armazenamento estruturado de log."
  remarks: "A <xref:System.IO.Log.LogRecordSequence>classe fornece uma implementação da interface de sequência do registro na parte superior de um log de sistema de arquivos de Log comuns (CLFS).</xref:System.IO.Log.LogRecordSequence> Ele funciona com a classe de LogStore, que fornece uma interface para manipular diretamente e gerenciamento de um arquivo de log CLFS. Um repositório de log fornece armazenamento somente de acréscimo em um conjunto de extensões do disco. A classe LogStore representa este armazenamento e fornece métodos para adicionar e remover contêineres, configuração de política e criando arquivos. Ele não fornece métodos para leitura e gravação para o armazenamento; Esses métodos são fornecidos pela <xref:System.IO.Log.LogRecordSequence>classe.</xref:System.IO.Log.LogRecordSequence>       A relação entre a classe LogStore e <xref:System.IO.Log.LogRecordSequence>classe é semelhante à relação entre um arquivo de disco e um <xref:System.IO.FileStream>objeto.</xref:System.IO.FileStream> </xref:System.IO.Log.LogRecordSequence> O arquivo de disco fornece o armazenamento real e tem atributos como comprimento e a hora do último acesso, enquanto o <xref:System.IO.FileStream>objeto fornece uma exibição no arquivo que pode ser usado para lê-lo e gravar proprietário.</xref:System.IO.FileStream> Da mesma forma, a classe LogStore tem atributos como uma diretiva e uma coleção de extensões do disco e o <xref:System.IO.Log.LogRecordSequence>classe fornece um mecanismo orientado por registro para ler e gravar dados.</xref:System.IO.Log.LogRecordSequence>       Ao contrário a sequência de registro de arquivo representada pela <xref:System.IO.Log.FileRecordSequence>classe, uma instância de LogStore armazena seus dados em uma coleção de extensões do disco, representado pelo <xref:System.IO.Log.LogExtent>instâncias.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.FileRecordSequence> As extensões em uma determinada instância de LogStore são de tamanho uniforme, e o espaço é adicionado a e removido de uma instância de LogStore em incrementos de extensão. Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A>e <xref:System.IO.Log.LogExtentCollection.Remove%2A>métodos do <xref:System.IO.Log.LogExtentCollection>objeto, que pode ser retornado pelo <xref:System.IO.Log.LogStore.Extents%2A>propriedade.</xref:System.IO.Log.LogStore.Extents%2A> </xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>       Uma instância de LogStore pode ter políticas associadas a ele. Esses são representados pelo <xref:System.IO.Log.LogPolicy>instâncias que podem ser retornadas pelo <xref:System.IO.Log.LogStore.Policy%2A>propriedade.</xref:System.IO.Log.LogStore.Policy%2A> </xref:System.IO.Log.LogPolicy> Uma política impõe regras que o log tentará a seguir, como o número máximo de extensões e o tamanho mínimo e instruções sobre aumentando ou diminuindo o LogStore sob determinadas condições. Além disso, você pode especificar se uma instância de LogStore pode ser arquivada. Políticas são definidas por log e são voláteis, o que significa que quando cada identificador para o log é fechada, a política não existe mais."
  example:
  - "The following example shows how to archive a LogStore to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/t-system.io.log.logstore_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/t-system.io.log.logstore_1.cs)]"
  syntax:
    content: 'public sealed class LogStore : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe para o identificador especificado."
  syntax:
    content: public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de arquivo para o log de arquivo atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> encapsula o objeto."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O identificador do log não pôde ser associado ao pool de threads."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe com o caminho especificado e o modo."
  remarks: "Use este construtor para abrir um repositório de log com o caminho especificado e o modo. O armazenamento é aberto com acesso de leitura/gravação e compartilha o acesso de leitura.       O `path` parâmetro deve usar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.       Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe em vez disso."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe com o caminho especificado, o modo e o acesso."
  remarks: "Use este construtor para abrir um novo armazenamento de log com o caminho especificado, o modo e o acesso. O armazenamento é aberto com o compartilhamento de acesso de leitura.       O `path` parâmetro deve usar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.       Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe em vez disso."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogStore>objeto que ele é aberto com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> O armazenamento é aberto com o compartilhamento de acesso especificado.       O `path` parâmetro deve usar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.       Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Uma da <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina como o armazenamento de log será compartilhado entre processos."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido.       - ou - <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe em vez disso."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogStore>objeto que ele é aberto com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> O armazenamento é aberto com o compartilhamento de acesso especificado. O `path` parâmetro deve seguir a sintaxe a seguir: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um arquivo de log e `<log client name>` é um identificador exclusivo do cliente. Um repositório de log deve ser um repositório de log físico ou um armazenamento de log virtuais, mas não ambos. Quando um armazenamento de log tiver sido criado física ou virtualmente, ele permanecerá isso para o seu tempo de vida. Um repositório de log físico é criado especificando somente o nome de log físico. Um repositório de log virtual é criado, especificando o nome de log físico e o nome do cliente de log.       Os clientes que compartilham o mesmo nome de log físico compartilham o mesmo conjunto de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Uma da <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina como o armazenamento de log será compartilhado entre processos."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Uma da <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> valor que especifica a segurança definida no repositório de recém-criado se o repositório deve ser criado."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do arquivo de armazenamento de log especificado pelo <code> path </code> não é válido.       - ou - <code> Mode </code> é <xref uid=&quot;langword_csharp_CreateNew&quot; name=&quot;CreateNew&quot; href=&quot;&quot;> </xref>, que não pode ser usado sem acesso de gravação.       - ou - <code> Mode </code> é <xref uid=&quot;langword_csharp_OpenOrCreate&quot; name=&quot;OpenOrCreate&quot; href=&quot;&quot;> </xref>, que não pode ser usado sem acesso de gravação."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido.       - ou - <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log.       O arquivo especificado por <code> path </code> não pode ser acessado porque está em uso por outro processo.       o arquivo especificado por - ou - <code> path </code> não pode ser criado porque o arquivo ou diretório já existe.       - ou - o identificador do log não pôde ser associado ao pool de threads.       - ou - a versão ou o formato de arquivo de log especificado é inválido."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe em vez disso."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Archivable
  id: Archivable
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém um valor que indica se este <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância pode ser arquivada."
  remarks: "Se um <xref:System.IO.Log.LogStore>não pode ser arquivado, chamadas para o <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A>e <xref:System.IO.Log.LogStore.SetArchiveTail%2A>métodos resultam em um <xref:System.NotSupportedException>que está sendo gerada.</xref:System.NotSupportedException> </xref:System.IO.Log.LogStore.SetArchiveTail%2A> </xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> </xref:System.IO.Log.LogStore>"
  syntax:
    content: public bool Archivable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância pode ser arquivado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogStore.Archivable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência mais baixo que corresponde a um registro válido neste <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância."
  remarks: "Números de sequência são maior ou igual a BaseSequenceNumber e menor que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</xref:System.IO.Log.LogStore.LastSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência mais baixo que corresponde a um registro válido neste <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância."
  overload: System.IO.Log.LogStore.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  id: CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tira um instantâneo do estado do repositório de log para fazer um backup."
  remarks: ''
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_1_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_1_1.cs)]"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();
    parameters: []
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "Um <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> objeto que contém o estado necessário para tornar um arquivo morto."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O armazenamento de log não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um argumento não é válido."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  id: CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tira um instantâneo do estado do repositório de log entre os números de sequência especificado para fazer um backup."
  remarks: "O instantâneo de arquivo retornado deste método abrange informações sobre o número de sequência de base ou o número de sequência de arquivo, o que for menor, para o último número de sequência. Não é inclusivo para o último número de sequência, o que significa que o arquivo contém somente registros até, mas não incluindo a última. Além disso, ao usar esse método, o início SequenceNumber deve ser igual de BaseSequenceNumber para que o arquivo para ser consistente."
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);
    parameters:
    - id: first
      type: System.IO.Log.SequenceNumber
      description: "O sequência número inicial no intervalo para arquivamento."
    - id: last
      type: System.IO.Log.SequenceNumber
      description: "O sequência número final no intervalo para arquivar."
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "Um <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> objeto que contém o estado necessário para tornar um arquivo morto."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>first</code>ou <code>last</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>first</code>é maior do que <code>last</code>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O armazenamento de log não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Remove o armazenamento de log."
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para remover."
  overload: System.IO.Log.LogStore.Delete*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Dispose
  id: Dispose
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Libera todos os recursos usados pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "Chamar Dispose quando terminar de usar o <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> O método Dispose deixa a <xref:System.IO.Log.LogStore>em um estado inutilizável.</xref:System.IO.Log.LogStore> Depois de chamar Dispose, você deve liberar todas as referências para o <xref:System.IO.Log.LogStore>para o coletor de lixo possa recuperar a memória que o <xref:System.IO.Log.LogStore>estava ocupando.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore>      > [!NOTE] > Sempre chamada Dispose antes de liberar sua última referência a <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.IO.Log.LogStore>do objeto `Finalize` método.</xref:System.IO.Log.LogStore>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogStore.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Extents
  id: Extents
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém a coleção de extensões de log que contêm os dados para este armazenamento de log."
  remarks: "Um <xref:System.IO.Log.LogStore>instância armazena seus dados em uma coleção de extensões do disco, representado pelo <xref:System.IO.Log.LogExtent>instâncias.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.LogStore> As extensões em um determinado <xref:System.IO.Log.LogStore>instância são de tamanho uniforme, e espaço é adicionado a e removido de um <xref:System.IO.Log.LogStore>instância em incrementos de extensão.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore> Para adicionar e remover extensões de log, use o <xref:System.IO.Log.LogExtentCollection.Add%2A>e<xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos do <xref:System.IO.Log.LogExtentCollection>objeto, que é retornado por essa propriedade.</xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>"
  syntax:
    content: public System.IO.Log.LogExtentCollection Extents { get; }
    return:
      type: System.IO.Log.LogExtentCollection
      description: "Um <xref href=&quot;System.IO.Log.LogExtentCollection&quot;> </xref> instância que contém a coleção de extensões de log que encapsula dados para este armazenamento de log."
  overload: System.IO.Log.LogStore.Extents*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.FreeBytes
  id: FreeBytes
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de bytes disponíveis no armazenamento de log."
  syntax:
    content: public long FreeBytes { get; }
    return:
      type: System.Int64
      description: "O número de bytes disponíveis no armazenamento de log."
  overload: System.IO.Log.LogStore.FreeBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Handle
  id: Handle
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o identificador de arquivo do sistema operacional para o arquivo de log que atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância encapsula."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "O identificador de arquivo do sistema operacional para o log de arquivo atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância encapsula."
  overload: System.IO.Log.LogStore.Handle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, obtém o número de sequência do próximo registro a ser anexado ao armazenamento de log."
  remarks: "Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>e menor que LastSequenceNumber.</xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro a ser anexado ao armazenamento de log."
  overload: System.IO.Log.LogStore.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Length
  id: Length
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o tamanho do armazenamento de log, em bytes."
  remarks: "O tamanho do armazenamento de log é a soma dos tamanhos das extensões do log."
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "O tamanho do armazenamento de log, em bytes."
  overload: System.IO.Log.LogStore.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Policy
  id: Policy
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém a política associada a este armazenamento de log."
  remarks: "Você pode usar a <xref:System.IO.Log.LogPolicy>instância retornada por esta propriedade para examinar e manipular a diretiva de log associado a esta <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogPolicy>"
  syntax:
    content: public System.IO.Log.LogPolicy Policy { get; }
    return:
      type: System.IO.Log.LogPolicy
      description: "Um <xref href=&quot;System.IO.Log.LogPolicy&quot;> </xref> instância que representa a política associada a este armazenamento de log."
  overload: System.IO.Log.LogStore.Policy*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  id: SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Define o número de sequência de final do arquivo."
  remarks: "O menor o número de sequência de base e o final do arquivo determina o final do log."
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_0_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_0_1.cs)]"
  syntax:
    content: public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);
    parameters:
    - id: archiveTail
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de final do arquivo."
  overload: System.IO.Log.LogStore.SetArchiveTail*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>archiveTail</code>não é válido para essa sequência."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O armazenamento de log não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogStore.StreamCount
  id: StreamCount
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de fluxos de log nesse armazenamento de log."
  syntax:
    content: public int StreamCount { get; }
    return:
      type: System.Int32
      description: "O número de fluxos de log nesse armazenamento de log."
  overload: System.IO.Log.LogStore.StreamCount*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogStore.Archivable
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
- uid: System.IO.Log.LogArchiveSnapshot
  parent: System.IO.Log
  isExternal: false
  name: LogArchiveSnapshot
  nameWithType: LogArchiveSnapshot
  fullName: System.IO.Log.LogArchiveSnapshot
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
- uid: System.IO.Log.LogStore.Delete(System.String)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
- uid: System.IO.Log.LogStore.Dispose
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
- uid: System.IO.Log.LogStore.Extents
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
- uid: System.IO.Log.LogExtentCollection
  parent: System.IO.Log
  isExternal: false
  name: LogExtentCollection
  nameWithType: LogExtentCollection
  fullName: System.IO.Log.LogExtentCollection
- uid: System.IO.Log.LogStore.FreeBytes
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogStore.Handle
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
- uid: System.IO.Log.LogStore.Policy
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
- uid: System.IO.Log.LogPolicy
  parent: System.IO.Log
  isExternal: false
  name: LogPolicy
  nameWithType: LogPolicy
  fullName: System.IO.Log.LogPolicy
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
- uid: System.IO.Log.LogStore.StreamCount
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogStore.#ctor*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore
  nameWithType: LogStore.LogStore
- uid: System.IO.Log.LogStore.Archivable*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
- uid: System.IO.Log.LogStore.BaseSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot
  nameWithType: LogStore.CreateLogArchiveSnapshot
- uid: System.IO.Log.LogStore.Delete*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete
  nameWithType: LogStore.Delete
- uid: System.IO.Log.LogStore.Dispose*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose
  nameWithType: LogStore.Dispose
- uid: System.IO.Log.LogStore.Extents*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
- uid: System.IO.Log.LogStore.FreeBytes*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
- uid: System.IO.Log.LogStore.Handle*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
- uid: System.IO.Log.LogStore.Policy*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
- uid: System.IO.Log.LogStore.SetArchiveTail*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail
  nameWithType: LogStore.SetArchiveTail
- uid: System.IO.Log.LogStore.StreamCount*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
