### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Cria e controla um thread, define sua prioridade e obtém seu status."
  remarks: "Quando um processo é iniciado, o common language runtime cria automaticamente um thread único em primeiro plano para executar o código do aplicativo. Junto com este thread principal do primeiro plano, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo. Esses threads podem executar em primeiro plano ou no plano de fundo. Além disso, você pode usar o <xref:System.Threading.ThreadPool>classe para executar código em threads de trabalho que são gerenciados pelo common language runtime.</xref:System.Threading.ThreadPool>       Nesta seção [iniciar um thread](#Starting)[objetos Thread recuperando](#Retrieving)[threads de primeiro plano e plano de fundo](#Foreground)[cultura e threads](#Culture)[Obtendo informações sobre e controlar threads](#Properties)[acessar o código-fonte para a classe Thread](#Source) <a name=&quot;Starting&quot;> </a> # # iniciar um thread iniciar um thread, fornecendo um delegado que representa o método que o thread é executar o construtor de classe.                                Em seguida, chamar o <xref:System.Threading.Thread.Start%2A>método para começar a execução.</xref:System.Threading.Thread.Start%2A>       Os construtores de Thread podem ter um delegado de dois tipos, dependendo se você pode passar um argumento para o método a ser executado:-se o método não possui argumentos, você passar um <xref:System.Threading.ThreadStart>delegar para o construtor.</xref:System.Threading.ThreadStart> Ele tem a assinatura: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` o exemplo a seguir cria e inicia um thread que executa o `ExecuteInForeground` método.           O método exibe informações sobre algumas propriedades de thread e, em seguida, executa um loop no qual ele pausa por meio segundo e exibe o número decorrido de segundos. Quando o thread de execução pelo menos cinco segundos, o loop é encerrado e o thread finaliza a execução.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -se o método tem um argumento, você passar um <xref:System.Threading.ParameterizedThreadStart>delegar para o construtor.</xref:System.Threading.ParameterizedThreadStart>       Ele tem a assinatura: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` o método executado pelo delegado pode, em seguida, converta (em c#) ou converter o parâmetro (no Visual Basic) para o tipo apropriado.                     O exemplo a seguir é idêntico ao anterior, exceto que ele chama o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>construtor.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Esta versão do `ExecuteInForeground` método tem um único parâmetro que representa o número aproximado de milissegundos que o loop é executado.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] não é necessário manter uma referência a um objeto de Thread depois de iniciar o thread.       O thread continua a executar até concluir o procedimento de thread.      <a name=&quot;Retrieving&quot;></a># # Recuperar Thread objetos que você pode usar o static (`Shared` no Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A>propriedade para recuperar uma referência para o thread em execução no momento do código que o thread está em execução.</xref:System.Threading.Thread.CurrentThread%2A> O exemplo a seguir usa o <xref:System.Threading.Thread.CurrentThread%2A>propriedade para exibir informações sobre o thread principal do aplicativo, outro thread de primeiro plano, um thread em segundo plano e um pool de threads.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> # # instâncias da classe do Thread de threads de primeiro plano e plano de fundo representam threads de primeiro plano ou threads em segundo plano.         Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread em segundo plano não manter um processo em execução se todos os threads de primeiro plano tem sido encerrado. Depois que todos os threads de primeiro plano foram interrompidos, o tempo de execução interrompe todos os threads em segundo plano e desligado.       Por padrão, os seguintes threads executam em primeiro plano:-o thread principal do aplicativo.      -Todos os threads criados chamando um construtor de classe Thread.       Os seguintes threads são executados em segundo plano por padrão:-Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução.  Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando a <xref:System.Threading.ThreadPool>classe.</xref:System.Threading.ThreadPool>          > [!NOTE] > Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool. Usam operações assíncronas baseado em tarefas de <xref:System.Threading.Tasks.Task>e <xref:System.Threading.Tasks.Task%601>classes para implementar o [padrão assíncrono baseado em tarefa](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado.       Você pode alterar um segmento a ser executado em segundo plano, definindo a <xref:System.Threading.Thread.IsBackground%2A>propriedade a qualquer momento.</xref:System.Threading.Thread.IsBackground%2A>  Threads em segundo plano são úteis para qualquer operação que deve continuar enquanto um aplicativo está em execução, mas não deve impedir que o aplicativo finalizando, como monitoramento de alterações do sistema de arquivos ou conexões de soquete de entrada.       O exemplo a seguir ilustra a diferença entre os threads de primeiro plano e plano de fundo. É como o primeiro exemplo de [iniciar um thread](#Starting) seção, exceto que ele define o thread seja executado em segundo plano antes de iniciá-lo. Como mostra a saída, o loop é interrompido antes de ele ser executado por cinco segundos.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> # # cultura e threads cada thread tem uma cultura, representada pelo <xref:System.Threading.Thread.CurrentCulture%2A>propriedade e uma cultura de interface do usuário, representado pelo <xref:System.Threading.Thread.CurrentUICulture%2A>propriedade.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          A cultura atual oferece suporte a operações sensíveis à cultura como analisar e formatação, cadeia de caracteres de comparação e ordenação e também controla o sistema de escrita e o calendário usado por um thread. Fornece a cultura de interface do usuário atual para a recuperação sensíveis à cultura de recursos em arquivos de recurso.       Quando um novo segmento é instanciado, sua cultura e cultura da interface do usuário são definidos pela cultura do sistema atual e cultura da interface do usuário e não pela cultura e cultura da interface do usuário do thread do qual o novo thread é criado. Isso significa que, por exemplo, que se a cultura atual do sistema for inglês (Estados Unidos) e a cultura atual do thread principal do aplicativo é francês (França), a cultura de um novo thread criado chamando o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>construtor do thread principal é inglês (Estados Unidos) e francês (França).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Para obter mais informações, consulte a seção &quot;Cultura e threads&quot; do <xref:System.Globalization.CultureInfo>tópico sobre a classe.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > Isso não é possível de threads que executam operações assíncronas para aplicativos que têm como destino o [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] e versões posteriores, no caso, a cultura e cultura da interface do usuário é parte do contexto de um operações assíncronas; o thread em que uma operação assíncrona é executado por padrão herda a cultura e cultura da interface do usuário do thread do qual a operação assíncrona foi iniciada. Para obter mais informações, consulte a seção &quot;Cultura e baseado em tarefas de operações assíncronas&quot; do <xref:System.Globalization.CultureInfo>tópico sobre a classe.</xref:System.Globalization.CultureInfo>       Você pode fazer o seguinte para garantir que todos os threads de execução em um aplicativo compartilham a mesma cultura e cultura da interface do usuário:-você pode passar um <xref:System.Globalization.CultureInfo>objeto que representa a cultura ao <xref:System.Threading.ParameterizedThreadStart>delegar ou <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -Para aplicativos executados no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] e versões posteriores, você pode definir a cultura e cultura da interface do usuário que deve ser atribuído a todos os threads criados em um domínio de aplicativo, definindo o valor da <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Propriedades.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Observe que essa é uma configuração de domínio de aplicativo.       Para obter mais informações e exemplos, consulte a seção &quot;Cultura e threads&quot; do <xref:System.Globalization.CultureInfo>tópico sobre a classe.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a># # Obtendo informações sobre e controlando threads, você pode recuperar um número de valores de propriedade que fornecem informações sobre um segmento. Em alguns casos, você também pode definir esses valores de propriedade para controlar a operação do thread. Essas propriedades de thread incluem:-um nome. <xref:System.Threading.Thread.Name%2A>é uma gravação-uma vez a propriedade que você pode usar para identificar um thread.</xref:System.Threading.Thread.Name%2A>  O valor padrão é `null`.      -Um código de hash, que você pode recuperar chamando o <xref:System.Threading.Thread.GetHashCode%2A>método.</xref:System.Threading.Thread.GetHashCode%2A> O código hash pode ser usado para identificar exclusivamente um thread; para o tempo de vida do seu thread, seu código de hash não coincidirá com o valor de qualquer outro thread, independentemente do domínio de aplicativo do qual você pode obter o valor.      -A ID do thread. O valor de somente leitura <xref:System.Threading.Thread.ManagedThreadId%2A>propriedade é atribuída pelo tempo de execução e identifica exclusivamente um thread dentro de seu processo.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > Um sistema operacional [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) não tem nenhuma relação fixa a um thread gerenciado, como um host não gerenciado pode controlar a relação entre os threads gerenciados e não gerenciados. Especificamente, um host sofisticado pode usar o [API de hospedagem de CLR](https://msdn.microsoft.com/library/ms404385.aspx) para agendar muitos threads gerenciados no mesmo thread do sistema operacional, ou para mover um thread gerenciado entre threads diferentes do sistema operacional.      -O estado do segmento atual. Durante sua existência, um thread é sempre em uma ou mais os estados definidos pelo <xref:System.Threading.ThreadState>propriedade.</xref:System.Threading.ThreadState>      -Um nível de prioridade do agendamento, que é definido como o <xref:System.Threading.ThreadPriority>propriedade.</xref:System.Threading.ThreadPriority> Embora você possa definir esse valor para solicitar a prioridade do thread, não é garantido que ele ser respeitado pelo sistema operacional.      -O somente leitura <xref:System.Threading.Thread.IsThreadPoolThread%2A>propriedade, que indica se um thread é um pool de threads.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      -A <xref:System.Threading.Thread.IsBackground%2A>propriedade.</xref:System.Threading.Thread.IsBackground%2A> Para obter mais informações, consulte o [threads de primeiro plano e plano de fundo](#Foreground) seção.      <a name=&quot;Source&quot;></a># # Acessando o código-fonte para a classe do Thread para exibir o código-fonte do .NET Framework para a classe de Thread, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificando um delegado que permite que um objeto a serem passados para o thread quando o thread foi iniciado."
  remarks: "Um thread não começar a execução quando ele é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A>método.</xref:System.Threading.Thread.Start%2A> Para passar um objeto de dados para o thread, use o <xref:System.Threading.Thread.Start%28System.Object%29>sobrecarga de método.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart>construtor ao criar um thread.</xref:System.Threading.ThreadStart> Use o `AddressOf` operador ao passar o método, por exemplo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart>construtor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Um delegado que representa os métodos a ser invocado quando esse thread começa a executar."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe."
  remarks: "Um thread não começar a execução quando ele é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A>método.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart>construtor ao criar um thread.</xref:System.Threading.ThreadStart> Use o `AddressOf` operador ao passar o método como `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart>construtor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Um <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegado que representa os métodos a ser invocado quando esse thread começa a executar."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificando um delegado que permite que um objeto a serem passados para o thread quando o thread foi iniciado e especificando o tamanho máximo da pilha do thread."
  remarks: "Evite usar essa sobrecarga de construtor. O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>sobrecarga de construtor é o tamanho da pilha recomendados para threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]somente totalmente confiáveis código pode definir `maxStackSize` para um valor maior que o tamanho da pilha padrão (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está sendo executado com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado. Nenhuma exceção é lançada. Código em qualquer nível de confiança pode definir `maxStackSize` para um valor menor que o tamanho da pilha padrão.      > [!NOTE] > Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável e é necessário iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado. Não faça isso, a menos que você controlar totalmente o código que é executado no thread.       Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado. Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página. Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).      > [!NOTE] > Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.       Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha. Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha. Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Um <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegado que representa os métodos a ser invocado quando esse thread começa a executar."
    - id: maxStackSize
      type: System.Int32
      description: "O tamanho máximo da pilha, em bytes, para ser usado por thread ou 0 para usar o tamanho máximo da pilha do padrão especificado no cabeçalho do executável.       Importante para ao código parcialmente confiável, `maxStackSize` será ignorado se for maior que o tamanho da pilha padrão. Nenhuma exceção é lançada."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>é menor que zero."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificando o tamanho máximo da pilha do thread."
  remarks: "Evite usar essa sobrecarga de construtor. O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>sobrecarga de construtor é o tamanho da pilha recomendados para threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]somente totalmente confiáveis código pode definir `maxStackSize` para um valor maior que o tamanho da pilha padrão (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está sendo executado com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado. Nenhuma exceção é lançada. Código em qualquer nível de confiança pode definir `maxStackSize` para um valor menor que o tamanho da pilha padrão.      > [!NOTE] > Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável e é necessário iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado. Não faça isso, a menos que você controlar totalmente o código que é executado no thread.       Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado. Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página. Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).      > [!NOTE] > Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.       Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha. Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha. Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Um <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegado que representa os métodos a ser invocado quando esse thread começa a executar."
    - id: maxStackSize
      type: System.Int32
      description: "O tamanho máximo da pilha, em bytes, para ser usado por thread ou 0 para usar o tamanho máximo da pilha do padrão especificado no cabeçalho do executável.       Importante para ao código parcialmente confiável, `maxStackSize` será ignorado se for maior que o tamanho da pilha padrão. Nenhuma exceção é lançada."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>é menor que zero."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gera um <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> no thread no qual ele é chamado, para iniciar o processo de encerramento do thread. Chamar esse método normalmente finaliza o thread."
  remarks: "Quando esse método é chamado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException>thread para anular o proprietário.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do `catch` impedir a menos que <xref:System.Threading.Thread.ResetAbort%2A>é chamado.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread. Não executadas `finally` blocos são executados antes do thread foi anulado.      > [!NOTE] > Quando um thread chama `Abort` em si mesmo, o efeito é semelhante ao lançar uma exceção; o <xref:System.Threading.ThreadAbortException>acontece imediatamente, e o resultado é previsível.</xref:System.Threading.ThreadAbortException> No entanto, se um thread chama `Abort` em outro thread, a anulação interrupções de qualquer código está sendo executado. Também há uma possibilidade de que um construtor estático pode ser anulado. Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo. Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um `finally` bloco está em execução, caso em que o `finally` bloco será anulado.       O thread não é garantido para anular imediatamente ou em todos os. Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação. Para aguardar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A>método no thread depois de chamar o método de anulação, mas não há nenhuma garantia que a espera terminará.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > Pode impedir que o thread que chama a anulação se o thread que está sendo anulado estiver em uma área protegida do código, como um `catch` bloco, `finally` bloco ou região de execução restrita. Se o thread que chama a anulação mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.       Se `Abort` é chamado em um thread que não tenha sido iniciado, o thread será anulada quando <xref:System.Threading.Thread.Start%2A>é chamado.</xref:System.Threading.Thread.Start%2A> Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.       Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException>é gerada no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState>é adicionada para o <xref:System.Threading.Thread.ThreadState%2A>propriedade do thread que está sendo anulada.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Um <xref:System.Threading.ThreadAbortException>não é gerada no thread suspenso até <xref:System.Threading.Thread.Resume%2A>é chamado.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.       Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o `Abort`. No entanto, um aplicativo não pode detectar essa situação.       Depois de `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método. Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread que está sendo anulado está suspensa no momento."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gera um <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> no thread no qual ele é chamado, para iniciar o processo de encerrar o thread enquanto também fornece informações sobre o encerramento do thread de exceção. Chamar esse método normalmente finaliza o thread."
  remarks: "Quando esse método é chamado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException>thread para anular o proprietário.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do `catch` impedir a menos que <xref:System.Threading.Thread.ResetAbort%2A>é chamado.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread. Não executadas `finally` blocos são executados antes do thread foi anulado.      > [!NOTE] > Quando um thread chama `Abort` em si mesmo, o efeito é semelhante ao lançar uma exceção; o <xref:System.Threading.ThreadAbortException>acontece imediatamente, e o resultado é previsível.</xref:System.Threading.ThreadAbortException> No entanto, se um thread chama `Abort` em outro thread, a anulação interrupções de qualquer código está sendo executado. Há uma possibilidade de que um construtor estático pode ser anulado. Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo. Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um `finally` bloco está em execução, caso em que o `finally` bloco será anulado.       O thread não é garantido para anular imediatamente ou em todos os. Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação. Para aguardar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A>método no thread depois de chamar o método de anulação, mas não há nenhuma garantia de que a espera terminará.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > O thread que chama <xref:System.Threading.Thread.Abort%2A>podem bloquear se o thread que está sendo anulado estiver em uma área protegida do código, como um `catch` bloco, `finally` bloco ou região de execução restrita.</xref:System.Threading.Thread.Abort%2A> Se o thread que chama <xref:System.Threading.Thread.Abort%2A>mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.</xref:System.Threading.Thread.Abort%2A>       Se `Abort` é chamado em um thread que não tenha sido iniciado, o thread será anulada quando <xref:System.Threading.Thread.Start%2A>é chamado.</xref:System.Threading.Thread.Start%2A> Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.       Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException>é gerada no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState>é adicionada para o <xref:System.Threading.Thread.ThreadState%2A>propriedade do thread que está sendo anulada.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Um <xref:System.Threading.ThreadAbortException>não é gerada no thread suspenso até <xref:System.Threading.Thread.Resume%2A>é chamado.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.       Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o `Abort`. No entanto, um aplicativo não pode detectar essa situação.       Depois de `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método. Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Um objeto que contém informações específicas do aplicativo, como estado, o que pode ser usado pelo thread que está sendo anulada."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread que está sendo anulado está suspensa no momento."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Aloca um slot de dados sem nome em todos os threads. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       O slot é alocado em todos os threads.       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "O alocado denominado slot de dados em todos os threads."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Aloca um slot de dados nomeado em todos os threads. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.       Não é necessário usar o método AllocateNamedDataSlot para alocar um slot de dados nomeada, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A>método aloca o slot se ele já não foi alocado.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > Se o método AllocateNamedDataSlot é usado, ele deve ser chamado no thread principal na inicialização do programa, porque ele lança uma exceção se um slot com o nome especificado já foi alocado. Não há nenhuma maneira de testar se um slot já foi alocado.       Slots alocados com esse método devem ser liberados com <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome do slot de dados a ser alocada."
    return:
      type: System.LocalDataStoreSlot
      description: "O alocado denominado slot de dados em todos os threads."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um slot de dados nomeada com o nome especificado já existe."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o estado de apartment deste thread."
  remarks: "**A propriedade ApartmentState está obsoleta.**  As alternativas não obsoleto são o <xref:System.Threading.Thread.GetApartmentState%2A>método para recuperar o estado de apartment e <xref:System.Threading.Thread.SetApartmentState%2A>método para definir o estado de apartment.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       Nas versões do .NET Framework 1.0 e 1.1, o `ApartmentState` propriedade marca um thread para indicar que ela será executada em um apartment do thread único ou vários. Essa propriedade pode ser definida quando o thread está no `Unstarted` ou `Running` thread estado; no entanto, ela pode ser definida apenas uma vez por um thread. Se a propriedade não foi definida, retornará `Unknown`.       Uma tentativa de usar a propriedade ApartmentState para definir o estado de apartment de thread cujo estado apartment já foi definido é ignorada. No entanto, o <xref:System.Threading.Thread.SetApartmentState%2A>método lança um <xref:System.InvalidOperationException>nesse caso.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > No .NET Framework versão 2.0, os novos segmentos são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se seu estado de apartment não foi definido antes de iniciarem.</xref:System.Threading.ApartmentState?displayProperty=fullName> O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState?displayProperty=fullName>por padrão.</xref:System.Threading.ApartmentState?displayProperty=fullName> Não é possível definir o thread principal do aplicativo para <xref:System.Threading.ApartmentState?displayProperty=fullName>Definindo o <xref:System.Threading.ApartmentState?displayProperty=fullName>propriedade na primeira linha de código.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Use o <xref:System.STAThreadAttribute>em vez disso.</xref:System.STAThreadAttribute>       No .NET Framework versão 2.0, você pode especificar o threading de modelo para um aplicativo C++ usando COM o [/CLRTHREADATTRIBUTE (Definir Thread atributo CLR)](~/add/includes/ajax-current-ext-md.md) opção de vinculador."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "Uma da <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valores. O valor inicial é <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É feita uma tentativa de definir esta propriedade para um estado que não é um estado de apartment válido (um estado diferente de STA (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) ou o multi-threaded apartment (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou a anulação de thread podem comprometer a outras tarefas no domínio do aplicativo."
  remarks: "Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código. Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual. Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.       Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio. Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo.</xref:System.AppDomain> Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.       Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain>em vez de correr o risco de continuando a execução em um estado instável.</xref:System.AppDomain> Para informar o host que seu código está inserindo uma região crítica, chame BeginCriticalRegion. Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A>quando a execução retorna para uma região não críticos do código.</xref:System.Threading.Thread.EndCriticalRegion%2A>       Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um host que o código gerenciado está prestes a executar instruções que dependam da identidade do thread atual do sistema operacional físico."
  remarks: "Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads. Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento. A maioria das tarefas não são afetados por essa alternância. No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico. Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.       Por exemplo, se o aplicativo chama uma API para adquirir um bloqueio de sistema operacional com afinidade de thread, como CRITICAL_SECTION Win32, do sistema você deve chamar BeginThreadAffinity antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A>depois de liberar o bloqueio.</xref:System.Threading.Thread.EndThreadAffinity%2A>       Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o contexto atual no qual o thread está em execução."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "Um <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> que representa o contexto do thread atual."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define a cultura do thread atual."
  remarks: "O <xref:System.Globalization.CultureInfo>objeto retornado por essa propriedade, junto com seus objetos associados, determinar o formato padrão para datas, horas, números, valores de moeda, a ordenação de texto, convenções de maiusculas e minúsculas e comparações de cadeia de caracteres.</xref:System.Globalization.CultureInfo> Consulte o <xref:System.Globalization.CultureInfo>de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo.</xref:System.Globalization.CultureInfo> Consulte o <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>propriedade para saber como a cultura padrão de um thread é determinada, e como os usuários definir informações de cultura para seus computadores.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], você pode definir a propriedade CurrentCulture para uma cultura neutra. Isso ocorre porque o comportamento do <xref:System.Globalization.CultureInfo>classe mudou: quando ele representa uma cultura neutra, seus valores de propriedade (em particular, o <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A>Propriedades) agora refletem a cultura específica que está associada com a cultura neutra.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> Em versões anteriores do .NET Framework, a propriedade CurrentCulture gerou um <xref:System.NotSupportedException>exceção quando foi atribuída a uma cultura neutra.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Um objeto que representa a cultura do thread atual."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A propriedade é definida como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define a entidade atual do thread (para segurança baseada em função)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "Um <xref:System.Security.Principal.IPrincipal>valor que representa o contexto de segurança.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária para definir a entidade."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o thread em execução no momento."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "Um <xref href=&quot;System.Threading.Thread&quot;> </xref> que é a representação do thread em execução no momento."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define a cultura atual usada pelo Gerenciador de recursos para pesquisar recursos específicos de cultura em tempo de execução."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Um objeto que representa a cultura atual."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A propriedade é definida como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A propriedade é definida como um nome de cultura que não pode ser usado para localizar um arquivo de recurso. Nomes de arquivo de recurso devem incluir somente letras, números, hífens ou sublinhados."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Desativa a limpeza automática de runtime callable wrappers (RCW) para o thread atual."
  remarks: "Por padrão, o common language runtime (CLR) limpa callable wrappers do tempo de execução automaticamente. O CLR bomba de mensagens durante a limpeza, o que pode causar problemas de reentrada para alguns aplicativos que atendem aos seguintes critérios comuns:-o aplicativo faz sua própria bombeamento de mensagens.      -O aplicativo precisa controlar com precisão ao bombeamento de mensagens ocorre.       Esses aplicativos podem usar o método DisableComObjectEagerCleanup para impedir que o CLR fazendo a recuperação automática da callable wrappers do tempo de execução.       Quando esse método for chamado em um thread, a limpeza automática não pode ser habilitada novamente para esse thread. Quando seu aplicativo está pronto para limpar callable wrappers do tempo de execução, use o <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>método para instruir o tempo de execução para limpar todos os runtime callable wrappers no contexto atual.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Bombeamento de mensagens ocorre durante a execução do método."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou a anulação de thread são limitados à tarefa atual."
  remarks: "Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código. Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual. Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.       Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio. Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo.</xref:System.AppDomain> Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.       Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain>em vez de correr o risco de continuando a execução em um estado instável.</xref:System.AppDomain> Para informar o host que seu código está inserindo uma região crítica, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> Chame EndCriticalRegion quando a execução retorna a uma região não críticos do código.       Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um host que o código gerenciado concluiu a execução de instruções que dependam da identidade do thread atual do sistema operacional físico."
  remarks: "Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads. Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento. A maioria das tarefas não são afetados por essa alternância. No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico. Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.       Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio com afinidade de thread, como CRITICAL_SECTION Win32, você deve chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A>antes de adquirir o bloqueio e EndThreadAffinity depois de liberar o bloqueio.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um <xref:System.Threading.ExecutionContext>objeto que contém informações sobre os vários contextos do thread atual.</xref:System.Threading.ExecutionContext>"
  remarks: "O <xref:System.Threading.ExecutionContext>classe fornece um único contêiner para todas as informações relevantes para um segmento lógico de execução.</xref:System.Threading.ExecutionContext> Isso inclui o contexto de segurança, o contexto de chamada, contexto de sincronização, o contexto de localização e o contexto de transação."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "Um <xref:System.Threading.ExecutionContext>objeto que consolida as informações de contexto para o thread atual.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Garante que os recursos são liberados e outras operações de limpeza são realizadas quando o coletor de lixo recupera o <xref href=&quot;System.Threading.Thread&quot;> </xref> objeto."
  remarks: "O coletor de lixo chama Finalize quando o objeto atual está pronto para ser finalizado."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Elimina a associação entre um nome e um slot, para todos os threads do processo. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       Depois de qualquer thread chamadas `FreeNamedDataSlot`, outro thread que chama <xref:System.Threading.Thread.GetNamedDataSlot%2A>com o mesmo nome alocará um novo slot associado com o nome.</xref:System.Threading.Thread.GetNamedDataSlot%2A> As chamadas subsequentes para `GetNamedDataSlot` por qualquer thread retornará o novo slot. No entanto, qualquer thread que ainda tem um <xref:System.LocalDataStoreSlot?displayProperty=fullName>retornado por uma chamada anterior para `GetNamedDataSlot` pode continuar a usar o slot antigo.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       Um slot que tenha sido associado um nome é liberado apenas quando cada `LocalDataStoreSlot` que foi obtido antes da chamada para `FreeNamedDataSlot` foi liberado e coleta de lixo.       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome do slot de dados a ser liberado."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retorna um <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valor que indica o estado de apartment."
  remarks: "Esse método, juntamente com o <xref:System.Threading.Thread.SetApartmentState%2A>método e o <xref:System.Threading.Thread.TrySetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "Uma da <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valores que indica o estado de apartment do thread gerenciado. O padrão é <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retorna um <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objeto que pode ser usado para capturar a pilha do thread atual."
  remarks: "Não há suporte para esse método."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Nenhuma."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Em todos os casos."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera o valor do slot especificado no thread atual, no domínio atual do thread atual. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.      > [!NOTE] > GetData é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread. Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "O <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> da qual obter o valor."
    return:
      type: System.Object
      description: "O valor a ser recuperado."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retorna o domínio atual no qual o thread atual está em execução."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "Um <xref href=&quot;System.AppDomain&quot;> </xref> que representa o domínio de aplicativo atual do thread em execução."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retorna um identificador de domínio de aplicativo único."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "Um inteiro assinado de 32 bits identifica exclusivamente o domínio de aplicativo."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retorna um código hash para o thread atual."
  remarks: "O código de hash não é garantido como sendo exclusivo. Use o <xref:System.Threading.Thread.ManagedThreadId%2A>propriedade se precisar de um identificador exclusivo para um thread gerenciado.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Um valor de código de hash de inteiro."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Procura um slot de dados nomeado. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.       Se o slot nomeado não existir, um novo slot é alocado. Slots de dados nomeada são públicos e podem ser manipulados por qualquer pessoa."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome do slot de dados local."
    return:
      type: System.LocalDataStoreSlot
      description: "Um <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> alocado para esse thread."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Interrompe um thread que está no <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> estado de thread."
  remarks: "Se esse thread não está bloqueado no momento em um estado de junção, de modo de suspensão ou de espera, ele será interrompido quando ele lado começa a bloquear.       <xref:System.Threading.ThreadInterruptedException>será lançada no thread interrompido, mas não até que os blocos de thread.</xref:System.Threading.ThreadInterruptedException> Se o thread nunca bloqueado, a exceção nunca é gerada e, portanto, o thread pode ser concluída sem nunca sejam interrompidos."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem apropriada <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica o status de execução do thread atual."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esse thread foi iniciado e não foi encerrado normalmente ou anulada; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define um valor que indica se um thread é um thread em segundo plano."
  remarks: "Um thread é um thread em segundo plano ou em um thread de primeiro plano. Threads em segundo plano são idênticos aos threads de primeiro plano, exceto que os threads em segundo plano não impedem que um processo de encerramento. Depois de tem terminado e todos os threads de primeiro plano que pertencem a um processo, o common language runtime finaliza o processo. Qualquer threads em segundo plano restantes são interrompidos e não são concluídos.       Por padrão, os seguintes threads executam em primeiro plano (ou seja, sua propriedade IsBackground retorna `false`):-o thread principal (ou o thread principal do aplicativo).      -Todos os threads criados chamando um <xref:System.Threading.Thread>Construtor de classe.</xref:System.Threading.Thread>       Por padrão, os seguintes threads executam em segundo plano (ou seja, sua propriedade IsBackground retorna `true`):-Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução. Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando a <xref:System.Threading.ThreadPool>classe.</xref:System.Threading.ThreadPool>          > [!NOTE] > Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool.      -Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esse thread for ou se tornará um thread em segundo plano; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread está inativo."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica se um thread pertence ao pool de threads gerenciados ou não."
  remarks: "Para obter mais informações, consulte [o Thread Pool gerenciado](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esse thread pertence ao pool de threads gerenciados; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Bloqueia o thread de chamada até que o thread representado por esta instância é encerrado, enquanto continua a executar COM padrão e <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> bombeamento."
  remarks: "Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cuja método é chamado de junção foi concluída. Use esse método para garantir que um thread foi encerrado. O chamador bloqueará indefinidamente, se o thread não terminar. No exemplo a seguir, o `Thread1` thread chama o método de associação de `Thread2`, que faz com que `Thread1` para bloquear até `Thread2` foi concluída.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A>é chamado, o método retorna imediatamente.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > Você nunca deve chamar o método de associação do <xref:System.Threading.Thread>objeto que representa o thread atual do thread atual.</xref:System.Threading.Thread> Isso faz com que seu aplicativo travar porque o thread atual espera em si alterações esse método indefinidamente, o estado do thread de chamada para incluir <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState?displayProperty=fullName>estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O chamador tentou ingressar em um thread que está no <xref href=&quot;System.Threading.ThreadState&quot;> </xref> estado."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "O thread será interrompido enquanto aguardava."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "O thread de chamada até que o thread representado por esta instância finaliza ou o tempo especificado expira, enquanto continua a executar COM padrão e SendMessage bombeamento de blocos."
  remarks: "Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A>é chamado de método foi concluída ou o intervalo de tempo limite expirou.</xref:System.Threading.Thread.Join%2A> No exemplo a seguir, o `Thread1` chamadas de threads a <xref:System.Threading.Thread.Join>método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos decorridos.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] se <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>for especificado para o `millisecondsTimeout` parâmetro, que esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join>sobrecarga do método, exceto para o valor de retorno.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A>é chamado, o método retorna imediatamente.</xref:System.Threading.Thread.Join%2A>       Esse método altera o estado do thread de chamada para incluir <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState?displayProperty=fullName>estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O número de milissegundos para aguardar o thread seja finalizado."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread foi encerrado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o thread não foi encerrado após o período de tempo especificado pelo <code> millisecondsTimeout </code> parâmetro tiver decorrido."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> millisecondsTimeout </code> é negativa e não é igual a &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "O thread de chamada até que o thread representado por esta instância finaliza ou o tempo especificado expira, enquanto continua a executar COM padrão e SendMessage bombeamento de blocos."
  remarks: "Junção é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A>é chamado de método foi concluída ou o intervalo de tempo limite expirou.</xref:System.Threading.Thread.Join%2A> No exemplo a seguir, o `Thread1` chamadas de threads a <xref:System.Threading.Thread.Join>método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos decorridos.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] se <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>for especificado para `timeout`, esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join>sobrecarga do método, exceto para o valor de retorno.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A>é chamado, o método retorna imediatamente.</xref:System.Threading.Thread.Join%2A>       Esse método altera o estado do thread atual para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState?displayProperty=fullName>estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Um <xref:System.TimeSpan>definido como a quantidade de tempo de espera para o thread encerrar.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread foi encerrado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o thread não foi encerrado após o período de tempo especificado pelo <code> timeout </code> parâmetro tiver decorrido."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> timeout </code> é negativa e não é igual a &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos, ou é maior do que &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milissegundos."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O chamador tentou ingressar em um thread que está no <xref href=&quot;System.Threading.ThreadState&quot;> </xref> estado."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um identificador exclusivo para o thread gerenciado atual."
  remarks: "O valor da propriedade do thread ManagedThreadId serve para identificar exclusivamente o thread dentro de seu processo.       O valor da propriedade ManagedThreadId não varia ao longo do tempo, mesmo se o código não gerenciado que hospeda o common language runtime implementa o thread como uma fibra."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "Um inteiro que representa um identificador exclusivo para esse thread gerenciado."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Sincroniza o acesso de memória da seguinte maneira: O processador de execução do thread atual não é possível reorganizar as instruções de tal forma que os acessos de memória antes da chamada para MemoryBarrier executar depois de acessos de memória que segue a chamada para MemoryBarrier.'
  remarks: "MemoryBarrier é necessária somente em sistemas de multiprocessador com memória fraca ordenação (por exemplo, um sistema utilizar vários processadores Intel Itanium).       Para a maioria das finalidades, c# `lock` instrução, o Visual Basic `SyncLock` instrução, ou o <xref:System.Threading.Monitor>classe fornecem maneiras mais fáceis para sincronizar os dados.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o nome do thread."
  remarks: "Esta propriedade é gravação-depois. Como o valor padrão da propriedade de nome do thread é `null`, você pode determinar se um nome tem já foram explicitamente atribuído para o thread, comparando-o com `null`.       A cadeia de caracteres atribuída à propriedade nome pode incluir qualquer caractere Unicode."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Uma cadeia de caracteres que contém o nome do segmento, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum nome foi definido."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação de definição foi solicitada, mas o <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade já foi definida."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define um valor que indica a prioridade de agendamento de thread."
  remarks: "Um thread pode ser atribuído a qualquer um dos seguinte prioridade <xref:System.Threading.ThreadPriority>valores:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` sistemas operacionais não precisam cumprir a prioridade de thread.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "Uma da <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> valores. O valor padrão é <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread atingiu um estado final, tais como <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O valor especificado para uma operação definida não é válido <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> valor."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Cancela um <xref:System.Threading.Thread.Abort*>solicitada para o thread atual.</xref:System.Threading.Thread.Abort*>"
  remarks: "Esse método só pode ser chamado por código com as permissões adequadas.       Quando é feita uma chamada para `Abort` para encerrar um thread, o sistema gera um <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do bloco catch, a menos que `ResetAbort` é chamado. `ResetAbort`Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread.       Consulte <xref:System.Threading.ThreadAbortException>para obter um exemplo que demonstra a chamar o `ResetAbort` método.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>não foi invocado no thread atual."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão de segurança necessárias para o thread atual."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retoma um thread que foi suspenso."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado, está inativo ou não está no estado suspenso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem apropriada <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o estado de apartment de um thread antes de ser iniciado."
  remarks: "Novos threads são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se seu estado de apartment não foi definido antes de iniciarem.</xref:System.Threading.ApartmentState?displayProperty=fullName> Estado de apartment deve ser definido antes que um thread é iniciado.      > [!NOTE] > O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState?displayProperty=fullName>por padrão.</xref:System.Threading.ApartmentState?displayProperty=fullName> A única maneira de definir o estado apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState?displayProperty=fullName>é aplicar o <xref:System.STAThreadAttribute>atributo ao método de ponto de entrada.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       O método SetApartmentState, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A>método e o <xref:System.Threading.Thread.TrySetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "O novo estado de apartment."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>não é um estado de apartment válido."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O estado de apartment já foi inicializado."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Aplica um capturada <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> para o thread atual."
  remarks: "Não há suporte para esse método."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "O <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objeto a ser aplicado ao segmento atual."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Em todos os casos."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define os dados no slot especificado no thread em execução no momento, para o domínio atual do thread. Para obter melhor desempenho, use os campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e slots de dados.</xref:System.ThreadStaticAttribute> Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/add/includes/ajax-current-ext-md.md).       Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização após a conclusão do procedimento de thread e o <xref:System.Threading.Thread>objeto tiver sido recuperado pela coleta de lixo.</xref:System.Threading.Thread> Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.      > [!NOTE] > SetData é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread. Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "O <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> no qual definir o valor."
    - id: data
      type: System.Object
      description: "O valor a ser definido."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Suspende o thread atual para o número especificado de milissegundos."
  remarks: "O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado. Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Você pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>para o `millisecondsTimeout` parâmetro para suspender o thread indefinidamente.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=fullName>classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore>em vez disso, para sincronizar threads ou gerenciar recursos.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Os pulsos de relógio do sistema em uma taxa específica chamada a resolução do relógio. O tempo limite real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para coincidir com tiques do relógio. Para obter mais informações sobre resolução de relógio e o tempo de espera, consulte o [suspensão função](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tópico. Este método chama o [suspensão função](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) de APIs do sistema do Windows.       Este método não executa SendMessage bombeamento e COM padrão.      > [!NOTE] > Se você precisa de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A>método que especifica um intervalo de tempo limite.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O número de milissegundos para o qual o thread está suspenso. Se o valor de `millisecondsTimeout` argumento for zero, o thread abandona o restante de seu intervalo de tempo para qualquer thread de prioridade igual que está pronta para executar. Se não houver nenhum outro thread de prioridade igual que estão pronto para ser executado, a execução do thread atual não está suspenso."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de tempo limite é negativo e não é igual a <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Suspende o thread atual para o período de tempo especificado."
  remarks: "O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado. Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Você pode especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>para o `timeout` parâmetro para suspender o thread indefinidamente.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=fullName>classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore>em vez disso, para sincronizar threads ou gerenciar recursos.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Essa sobrecarga de <xref:System.Threading.Thread.Sleep%2A>usa o número total de milissegundos em `timeout`.</xref:System.Threading.Thread.Sleep%2A> Milissegundos fracionários são descartados.       Este método não executa SendMessage bombeamento e COM padrão.      > [!NOTE] > Se você precisa de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A>método que especifica um intervalo de tempo limite.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade de tempo para o qual o thread está suspenso. Se o valor da `millisecondsTimeout` argumento é &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, o thread abandona o restante de seu intervalo de tempo para qualquer thread de prioridade igual que está pronta para executar. Se não houver nenhum outro thread de prioridade igual que estão pronto para ser executado, a execução do thread atual não está suspenso."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> timeout </code> é negativa e não é igual a &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos, ou é maior do que &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milissegundos."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que um thread para aguardar o número de horas definidas pelo <code> iterations </code> parâmetro."
  remarks: "O método SpinWait é útil para a implementação de bloqueios. Classes do .NET Framework, como <xref:System.Threading.Monitor>e <xref:System.Threading.ReaderWriterLock>, use esse método internamente.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait basicamente coloca o processador de um loop estreito muito, com a contagem de loop especificada pelo `iterations` parâmetro. A duração da espera, portanto, depende da velocidade do processador.       Compare isso com o <xref:System.Threading.Thread.Sleep%2A>método.</xref:System.Threading.Thread.Sleep%2A> Um thread que chama <xref:System.Threading.Thread.Sleep%2A>produz o restante do seu fatia atual de tempo do processador, mesmo se o intervalo especificado for zero.</xref:System.Threading.Thread.Sleep%2A> Especificar um intervalo diferente de zero para <xref:System.Threading.Thread.Sleep%2A>Remove o thread de consideração pelo Agendador de thread até que o intervalo de tempo decorrido.</xref:System.Threading.Thread.Sleep%2A>       SpinWait não geralmente é útil para aplicativos comuns. Na maioria dos casos, você deve usar as classes de sincronização fornecidas pelo .NET Framework. Por exemplo, chamar <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>ou uma instrução que encapsula <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` em c# ou `SyncLock` no Visual Basic).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > Em casos raros em que é vantajoso para evitar uma alternância de contexto, como quando você sabe que uma alteração de estado é iminente, fazer uma chamada ao método SpinWait em seu loop. O código que executa SpinWait é projetado para evitar problemas que podem ocorrer em computadores com vários processadores. Por exemplo, em computadores com vários processadores Intel utilizar a tecnologia Hyper-Threading, SpinWait evita a privação de processador em determinadas situações."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "Um inteiro assinado de 32 bits que define quanto tempo é de um thread de espera."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o sistema operacional alterar o estado da instância atual para <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "Quando um thread estiver no <xref:System.Threading.ThreadState?displayProperty=fullName>de estado, o sistema operacional pode agendá-lo para execução.</xref:System.Threading.ThreadState?displayProperty=fullName> O thread de início da execução na primeira linha do método representado pelo <xref:System.Threading.ThreadStart>ou <xref:System.Threading.ParameterizedThreadStart>delegado fornecido para o construtor de thread.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Observe que a chamada inicial não bloqueia o thread de chamada.      > [!NOTE] > Se essa sobrecarga é usada com um thread criado usando um <xref:System.Threading.ParameterizedThreadStart>delegado, `null` é passado para o método executado pelo thread.</xref:System.Threading.ParameterizedThreadStart>       Depois que o thread termina, ele não pode ser reiniciado com outra chamada para `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente iniciar este thread."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o sistema operacional alterar o estado da instância atual para <xref href=&quot;System.Threading.ThreadState&quot;> </xref>e, opcionalmente, fornece um objeto que contém dados a serem usados pelo método o thread é executado."
  remarks: "Quando um thread estiver no <xref:System.Threading.ThreadState?displayProperty=fullName>de estado, o sistema operacional pode agendá-lo para execução.</xref:System.Threading.ThreadState?displayProperty=fullName> O thread de início da execução na primeira linha do método representado pelo <xref:System.Threading.ThreadStart>ou <xref:System.Threading.ParameterizedThreadStart>delegado fornecido para o construtor de thread.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Observe que a chamada inicial não bloqueia o thread de chamada.       Depois que o thread termina, ele não pode ser reiniciado com outra chamada para `Start`.       Essa sobrecarga e a <xref:System.Threading.ParameterizedThreadStart>delegado facilitam passar dados para um procedimento de thread, mas a técnica não é tipo seguro porque qualquer objeto pode ser passado para essa sobrecarga.</xref:System.Threading.ParameterizedThreadStart> Uma maneira mais robusta para passar dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados em um objeto de trabalho. Para obter mais informações, consulte [criando Threads e passando dados na hora de início](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "O segmento de um objeto que contém dados a serem usados pelo método Execute."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente iniciar este thread."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Este thread foi criado usando um <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegado em vez de um <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegate."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "O suspende o thread ou se o thread já está suspenso, não tem nenhum efeito."
  remarks: "Se o thread já está suspenso, esse método não terá efeito.      > [!CAUTION] > Não usam a suspensão e <xref:System.Threading.Thread.Resume%2A>métodos para sincronizar as atividades de threads.</xref:System.Threading.Thread.Resume%2A> Você não tem como saber qual código de um thread está em execução quando você suspende a ele. Se você suspender um thread enquanto ele mantém o bloqueio durante a avaliação de permissão de segurança, outros threads de <xref:System.AppDomain>pode estar bloqueada.</xref:System.AppDomain> Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads de <xref:System.AppDomain>que tentar usar que classe estão bloqueadas.</xref:System.AppDomain> Os deadlocks podem ocorrer facilmente."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado ou está inativo."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem apropriada <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Um conjunto de nomes é mapeado para um conjunto correspondente de identificadores de expedição."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a biblioteca MSDN."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reservado para uso futuro. Deve ser IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "No passado a matriz de nomes a serem mapeados."
    - id: cNames
      type: System.UInt32
      description: "Contagem dos nomes a serem mapeados."
    - id: lcid
      type: System.UInt32
      description: "O contexto de localidade no qual os nomes de interpretar."
    - id: rgDispId
      type: System.IntPtr
      description: "Matriz alocada pelo chamador que recebe as IDs correspondentes aos nomes."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera as informações de tipo para um objeto, o que pode ser usada para obter as informações de tipo para uma interface."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a biblioteca MSDN."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "As informações de tipo para retornar."
    - id: lcid
      type: System.UInt32
      description: "O identificador de localidade para o tipo de informação."
    - id: ppTInfo
      type: System.IntPtr
      description: "Recebe um ponteiro para o objeto de informações do tipo solicitado."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Recupera o número de interfaces de informações de tipo que um objeto fornece (0 ou 1)."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a biblioteca MSDN."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Fornece acesso às propriedades e métodos expostos por um objeto."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a biblioteca MSDN."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifica o membro."
    - id: riid
      type: System.Guid
      description: "Reservado para uso futuro. Deve ser IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "O contexto de localidade na qual interpretar argumentos."
    - id: wFlags
      type: System.Int16
      description: "Sinalizadores que descrevem o contexto da chamada."
    - id: pDispParams
      type: System.IntPtr
      description: "Ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPIDs para argumentos nomeados e contas para o número de elementos nas matrizes."
    - id: pVarResult
      type: System.IntPtr
      description: "Ponteiro para o local onde o resultado a ser armazenado."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Ponteiro para uma estrutura que contém informações de exceção."
    - id: puArgErr
      type: System.IntPtr
      description: "O índice do primeiro argumento que tem um erro."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que contém os estados do thread atual."
  remarks: "A propriedade ThreadState fornece informações mais específicas do que o <xref:System.Threading.Thread.IsAlive%2A>propriedade.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > Estado de thread só tem interesse em cenários de depuração. O código nunca deve usar o estado de thread para sincronizar as atividades de threads."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "Uma da <xref href=&quot;System.Threading.ThreadState&quot;> </xref> valores que indica o estado do thread atual. O valor inicial é <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o estado de apartment de um thread antes de ser iniciado."
  remarks: "Novos threads são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se seu estado de apartment não foi definido antes de iniciarem.</xref:System.Threading.ApartmentState?displayProperty=fullName> Estado de apartment deve ser definido antes que um thread é iniciado.      > [!NOTE] > O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState?displayProperty=fullName>por padrão.</xref:System.Threading.ApartmentState?displayProperty=fullName> A única maneira de definir o estado apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState?displayProperty=fullName>é aplicar o <xref:System.STAThreadAttribute>atributo ao método de ponto de entrada.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       O método TrySetApartmentState, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A>método e o <xref:System.Threading.Thread.SetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "O novo estado de apartment."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o estado de apartment está definido; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>não é um estado de apartment válido."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "VolatileRead e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, VolatileRead obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, VolatileRead e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar VolatileRead ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa VolatileRead ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "O campo a ser lido."
    return:
      type: System.Byte
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "O campo a ser lido."
    return:
      type: System.Double
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "O campo a ser lido."
    return:
      type: System.Int16
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "O campo a ser lido."
    return:
      type: System.Int32
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "O campo a ser lido."
    return:
      type: System.Int64
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "O campo a ser lido."
    return:
      type: System.IntPtr
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "O campo a ser lido."
    return:
      type: System.Object
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "O campo a ser lido."
    return:
      type: System.SByte
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "O campo a ser lido."
    return:
      type: System.Single
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "O campo a ser lido."
    return:
      type: System.UInt16
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "O campo a ser lido."
    return:
      type: System.UInt32
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "O campo a ser lido."
    return:
      type: System.UInt64
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é o mais recente escrito por qualquer processador em um computador, independentemente do número de processadores ou o estado do cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor mais recente gravado em um local de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "O campo a ser lido."
    return:
      type: System.UIntPtr
      description: "O valor mais recente gravado para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e VolatileWrite para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, VolatileWrite garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e VolatileWrite Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Byte
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Double
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Int16
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Int32
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Int64
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.IntPtr
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Object
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.SByte
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.Single
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.UInt16
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.UInt32
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.UInt64
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Grava um valor para um campo imediatamente, para que o valor é visível para todos os processadores no computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor>classe fornecem alternativas mais fácil.</xref:System.Threading.Monitor>       Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isso pode exigir a liberação de caches de processador.       Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.       Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "O campo ao qual o valor é a serem gravados."
    - id: value
      type: System.UIntPtr
      description: "O valor a ser gravado."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o thread de chamada gerar outro thread está pronto para execução no processador atual da execução. O sistema operacional seleciona o thread para produzir a."
  remarks: "Se esse método for bem-sucedido, o restante da fração de tempo atual do thread é produzido. O sistema operacional agenda o thread de chamada para outro intervalo de tempo, de acordo com sua prioridade e o status de outros threads que estão disponíveis para executar.       Gerando é limitado para o processador que está executando o thread de chamada. O sistema operacional não mudará execução a outro processador, mesmo se que o processador está ocioso ou estiver executando um thread de prioridade mais baixa. Se não houver nenhum outro thread está pronto para executar o processador atual, o sistema operacional não gera a execução e esse método retorna `false`.       Esse método é equivalente a usando invocação de plataforma para chamar o Win32 nativo `SwitchToThread` função. Você deve chamar o rendimento invocação de método em vez de usar a plataforma porque ignora de invocação de plataforma qualquer comportamento de threading personalizado que solicitou que o host."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o sistema operacional execução tiver alternado para outro thread; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
