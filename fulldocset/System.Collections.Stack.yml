### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "Representa uma coleção simples último a entrar, primeiro a sair (UEPS) não genérica de objetos."
  remarks: "Para obter a versão genérica dessa coleção, consulte <xref:System.Collections.Generic.Stack%601?displayProperty=fullName>.</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       A capacidade de uma pilha é o número de elementos que a pilha pode conter. À medida que elementos são adicionados a uma pilha, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.       Se <xref:System.Collections.Stack.Count%2A>é menor que a capacidade da pilha, <xref:System.Collections.Stack.Push%2A>é uma operação de (1).</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> Se a capacidade precisa ser aumentado para acomodar o novo elemento, <xref:System.Collections.Stack.Push%2A>se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>é uma operação de (1).</xref:System.Collections.Stack.Pop%2A>       Pilha aceita `null` como um valor válido e permite que os elementos duplicados."
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Stack&quot;> </xref> classe que está vazia e tem a capacidade inicial padrão."
  remarks: "A capacidade de um <xref:System.Collections.Stack>é o número de elementos que o <xref:System.Collections.Stack>pode conter.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</xref:System.Collections.Stack>       Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Este construtor é uma operação de (1)."
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Stack&quot;> </xref> classe que contém os elementos copiados da coleção especificada e tem a mesma capacidade inicial como o número de elementos copiados."
  remarks: "A capacidade de um <xref:System.Collections.Stack>é o número de elementos que o <xref:System.Collections.Stack>pode conter.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</xref:System.Collections.Stack>       Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Os elementos são copiados para o <xref:System.Collections.Stack>na mesma ordem em que são lidas pela <xref:System.Collections.IEnumerator>de <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Stack>       Este construtor é um O (`n`) operação, onde `n` é o número de elementos em `col`."
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "O <xref:System.Collections.ICollection>copiar elementos de.</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Stack&quot;> </xref> classe que está vazia e tem a capacidade inicial especificada ou a capacidade inicial padrão, o que for maior."
  remarks: "A capacidade de um <xref:System.Collections.Stack>é o número de elementos que o <xref:System.Collections.Stack>pode conter.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Como os elementos são adicionados a um <xref:System.Collections.Stack>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.</xref:System.Collections.Stack>       Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos de <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Este construtor é um O (`n`) operação, onde `n` é `initialCapacity`."
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "O número inicial de elementos que o <xref href=&quot;System.Collections.Stack&quot;> </xref> pode conter."
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>é menor que zero."
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Remove todos os objetos do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "<xref:System.Collections.Stack.Count%2A>é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.</xref:System.Collections.Stack.Count%2A>       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Cria uma cópia superficial do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a. As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.       Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Uma cópia superficial do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Determina se um elemento está no <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Este método determina a igualdade chamando o <xref:System.Object.Equals%2A?displayProperty=fullName>método.</xref:System.Object.Equals%2A?displayProperty=fullName>       Esse método executa uma pesquisa linear; Portanto, esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>       Começando com o .NET Framework 2.0, este método testa a igualdade passando o `obj` argumento para o <xref:System.Object.Equals%2A>método objetos individuais na coleção.</xref:System.Object.Equals%2A> Nas versões anteriores do .NET Framework, isso foi feito usando passando os itens individuais na coleção para o <xref:System.Object.Equals%2A>método o `obj` argumento.</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "O objeto a ser localizado no <xref href=&quot;System.Collections.Stack&quot;> </xref>. O valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copia o <xref href=&quot;System.Collections.Stack&quot;> </xref> para uma dimensão existente <xref:System.Array>, começando no índice de matriz especificado.</xref:System.Array>"
  remarks: "Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "O unidimensional <xref:System.Array>que é o destino dos elementos copiados de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Array> O <xref:System.Array>devem ter a indexação com base em zero.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "O índice de base zero no `array` no qual a cópia começa."
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>é menor que zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>é multidimensional.       o número de elementos na origem - ou - <xref href=&quot;System.Collections.Stack&quot;> </xref> é maior que o espaço disponível do <code>index</code> até o final do destino <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "O tipo da fonte de <xref href=&quot;System.Collections.Stack&quot;> </xref> não pode ser convertido automaticamente para o tipo de destino <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém o número de elementos contidos no <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "A capacidade é o número de elementos que o <xref:System.Collections.Stack>pode armazenar.</xref:System.Collections.Stack> Contagem é o número de elementos que estão realmente em <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       A capacidade é sempre maior que ou igual à contagem. Se a contagem exceder a capacidade durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.       Recuperar o valor dessa propriedade é uma operação de (1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "O número de elementos contidos no <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retorna um <xref:System.Collections.IEnumerator>para o <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic, c#]       O `foreach` instrução de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, usando `foreach` é recomendada, em vez de manipulação direta do enumerador.       Enumeradores podem ser usados para ler os dados na coleção, mas eles não podem ser usados para modificar a coleção subjacente.       Inicialmente, o enumerador está posicionado antes do primeiro elemento na coleção. <xref:System.Collections.IEnumerator.Reset%2A>também traz o enumerador de volta para essa posição.</xref:System.Collections.IEnumerator.Reset%2A>  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A>é indefinido.</xref:System.Collections.IEnumerator.Current%2A> Portanto, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A>para avançar o enumerador para o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Retorna o mesmo objeto até que o <xref:System.Collections.IEnumerator.MoveNext%2A>ou <xref:System.Collections.IEnumerator.Reset%2A>é chamado.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>define <xref:System.Collections.IEnumerator.Current%2A>para o próximo elemento.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>passa o final da coleção, o enumerador está posicionado após o último elemento da coleção e <xref:System.Collections.IEnumerator.MoveNext%2A>retorna `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando o enumerador está nessa posição, chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A>também retornam `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se a última chamada <xref:System.Collections.IEnumerator.MoveNext%2A>retornado `false`, <xref:System.Collections.IEnumerator.Current%2A>é indefinido.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Definir <xref:System.Collections.IEnumerator.Current%2A>para o primeiro elemento da coleção novamente, você pode chamar <xref:System.Collections.IEnumerator.Reset%2A>seguido pelo <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Um enumerador permanece válido desde que a coleção permaneça inalterada. Se forem feitas alterações à coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado irrecuperavelmente e seu comportamento é indefinido.       O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de thread-safe.  Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.       Esse método é uma operação de (1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém um valor que indica se o acesso para o <xref href=&quot;System.Collections.Stack&quot;> </xref> é sincronizado (thread-safe)."
  remarks: "Para garantir a segurança de thread do <xref:System.Collections.Stack>, todas as operações devem ser feitas por meio do wrapper retornado pelo <xref:System.Collections.Stack.Synchronized%2A>método.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.       O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Stack.SyncRoot%2A>durante toda a enumeração.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ] recuperar o valor dessa propriedade é uma operação de (1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, se acesse o <xref href=&quot;System.Collections.Stack&quot;> </xref> é sincronizado (thread-safe); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retorna o objeto no topo do <xref href=&quot;System.Collections.Stack&quot;> </xref> sem removê-lo."
  remarks: "Esse método é semelhante do <xref:System.Collections.Stack.Pop%2A>método, mas inspeção não modifica o <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Pop%2A>       `null`pode ser enviado para o <xref:System.Collections.Stack>como um espaço reservado, se necessário.</xref:System.Collections.Stack> Para distinguir entre um valor nulo e o fim da pilha, verifique o <xref:System.Collections.Stack.Count%2A>catch ou propriedade de <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Stack>está vazio.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Esse método é uma operação de (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "O <xref:System.Object>na parte superior do <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Collections.Stack&quot;> </xref> está vazio."
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Remove e retorna o objeto no topo do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Esse método é semelhante ao <xref:System.Collections.Stack.Peek%2A>método, mas <xref:System.Collections.Stack.Peek%2A>não modifica o <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Peek%2A> </xref:System.Collections.Stack.Peek%2A>       `null`pode ser enviado para o <xref:System.Collections.Stack>como um espaço reservado, se necessário.</xref:System.Collections.Stack> Para distinguir entre um valor nulo e o fim da pilha, verifique o <xref:System.Collections.Stack.Count%2A>catch ou propriedade de <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Stack>está vazio.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Esse método é uma operação de (1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "O <xref:System.Object>removidos da parte superior do <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Collections.Stack&quot;> </xref> está vazio."
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Insere um objeto no topo do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Se <xref:System.Collections.Stack.Count%2A>já for igual à capacidade, a capacidade do <xref:System.Collections.Stack>é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`pode ser enviado para o <xref:System.Collections.Stack>como um espaço reservado, se necessário.</xref:System.Collections.Stack> Ele ocupa um slot da pilha e é tratado como qualquer objeto.       Se <xref:System.Collections.Stack.Count%2A>é menor que a capacidade da pilha, Push é uma operação de (1).</xref:System.Collections.Stack.Count%2A> Se a capacidade precisa ser aumentado para acomodar o novo elemento, Push se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "O <xref:System.Object>para enviar por push para o <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object> O valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retorna um sincronizado wrapper (thread-safe) para o <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Para garantir a segurança de thread do <xref:System.Collections.Stack>, todas as operações devem ser feitas por meio desse wrapper.</xref:System.Collections.Stack>       Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.       O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Stack.SyncRoot%2A>durante toda a enumeração.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ] esse método é uma operação de (1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "O <xref href=&quot;System.Collections.Stack&quot;> </xref> para sincronizar."
    return:
      type: System.Collections.Stack
      description: "Um wrapper sincronizado em torno de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém um objeto que pode ser usado para sincronizar o acesso a <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Para criar uma versão sincronizada do <xref:System.Collections.Stack>, use o <xref:System.Collections.Stack.Synchronized%2A>método.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <xref:System.Collections.Stack>usando a propriedade SyncRoot.</xref:System.Collections.Stack> O código de sincronização deve executar operações no SyncRoot do <xref:System.Collections.Stack>, não diretamente no <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Isso garante que a operação correta de coleções que são derivados de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <xref:System.Collections.Stack>objeto.</xref:System.Collections.Stack>       Enumerar através de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção é sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador lançar uma exceção. Para garantir a segurança de thread durante a enumeração, você pode bloquear a coleção durante toda a enumeração ou capture as exceções resultante de alterações feitas por outros threads.       O exemplo de código a seguir mostra como bloquear a coleção usando o SyncRoot durante toda a enumeração.       [!code-cpp[Clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[clássico Stack.IsSynchronized exemplo n º&2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ] recuperar o valor dessa propriedade é uma operação de (1).    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Um <xref:System.Object>que pode ser usado para sincronizar o acesso a <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copia o <xref href=&quot;System.Collections.Stack&quot;> </xref> para uma nova matriz."
  remarks: "Os elementos são copiados para a matriz na ordem do último a entrar, primeiro a sair (UEPS), semelhante à ordem dos elementos retornados por uma sucessão de chamadas para <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Uma nova matriz que contém cópias dos elementos do <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
