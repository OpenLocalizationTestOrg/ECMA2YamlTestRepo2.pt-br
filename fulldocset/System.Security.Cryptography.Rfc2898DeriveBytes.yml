### YamlMime:ManagedReference
items:
- uid: System.Security.Cryptography.Rfc2898DeriveBytes
  id: Rfc2898DeriveBytes
  children:
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  - System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  - System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  - System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  - System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  langs:
  - csharp
  name: Rfc2898DeriveBytes
  nameWithType: Rfc2898DeriveBytes
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes
  type: Class
  summary: "Implementa baseada em senha da chave funcionalidade de derivação, PBKDF2, usando um gerador de número pseudoaleatório com base em <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref>."
  remarks: "Rfc2898DeriveBytes usa uma senha, um valor falso e um número de iteração e, em seguida, gera chaves por meio de chamadas para o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>método.</xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. A classe Rfc2898DeriveBytes pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS #5: baseada em senha Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  example:
  - "The following code example uses the Rfc2898DeriveBytes class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/t-system.security.crypto_117_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/t-system.security.crypto_117_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/t-system.security.crypto_117_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes
  inheritance:
  - System.Object
  - System.Security.Cryptography.DeriveBytes
  implements: []
  inheritedMembers:
  - System.Security.Cryptography.DeriveBytes.Dispose
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  id: '#ctor(System.String,System.Byte[])'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Byte[])
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> usando uma senha e um valor falso para derivar a chave de classe."
  remarks: "O tamanho de salt deve ser 8 bytes ou maior.       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS #5: baseada em senha Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  example:
  - "The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/7aa0756c-8905-4e75-ae9a-_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/7aa0756c-8905-4e75-ae9a-_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/7aa0756c-8905-4e75-ae9a-_1.cpp)]"
  syntax:
    content: public Rfc2898DeriveBytes (string password, byte[] salt);
    parameters:
    - id: password
      type: System.String
      description: "A senha usada para derivar a chave."
    - id: salt
      type: System.Byte[]
      description: "O salt chave usado para derivar a chave."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A senha ou salt está <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  id: '#ctor(System.String,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> usando a senha e o tamanho de salt para derivar a chave de classe."
  remarks: "O tamanho de salt deve ser 8 bytes ou maior.       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS #5: baseada em senha Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  syntax:
    content: public Rfc2898DeriveBytes (string password, int saltSize);
    parameters:
    - id: password
      type: System.String
      description: "A senha usada para derivar a chave."
    - id: saltSize
      type: System.Int32
      description: "O tamanho do salt aleatório que você deseja gerar a classe."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A senha ou salt está <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  id: '#ctor(System.Byte[],System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> usando uma senha, um valor falso e o número de iterações para derivar a chave de classe."
  remarks: "O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS #5: baseada em senha Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  syntax:
    content: public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);
    parameters:
    - id: password
      type: System.Byte[]
      description: "A senha usada para derivar a chave."
    - id: salt
      type: System.Byte[]
      description: "O salt chave usado para derivar a chave."
    - id: iterations
      type: System.Int32
      description: "O número de iterações para a operação."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A senha ou salt está <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  id: '#ctor(System.String,System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> usando uma senha, um valor falso e o número de iterações para derivar a chave de classe."
  remarks: "O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS #5: baseada em senha Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  example:
  - "The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \n  \n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/8b79aa42-3b6a-4a39-985a-_1.cs)]\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/8b79aa42-3b6a-4a39-985a-_1.vb)]\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/8b79aa42-3b6a-4a39-985a-_1.cpp)]"
  syntax:
    content: public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);
    parameters:
    - id: password
      type: System.String
      description: "A senha usada para derivar a chave."
    - id: salt
      type: System.Byte[]
      description: "O salt chave usado para derivar a chave."
    - id: iterations
      type: System.Int32
      description: "O número de iterações para a operação."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A senha ou salt está <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  id: '#ctor(System.String,System.Int32,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Rfc2898DeriveBytes(String,Int32,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> usando uma senha, um tamanho de salt e o número de iterações para derivar a chave de classe."
  remarks: "O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.       RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.       Para obter mais informações sobre PBKDF2, consulte RFC 2898 &quot;PKCS n º 5: Password-Based Cryptography Specification Version 2.0,&quot; disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, &quot;PBKDF2&quot; para obter detalhes completos.      > [!IMPORTANT] > Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe."
  syntax:
    content: public Rfc2898DeriveBytes (string password, int saltSize, int iterations);
    parameters:
    - id: password
      type: System.String
      description: "A senha usada para derivar a chave."
    - id: saltSize
      type: System.Int32
      description: "O tamanho do salt aleatório que você deseja gerar a classe."
    - id: iterations
      type: System.Int32
      description: "O número de iterações para a operação."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A senha ou salt está <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>iterations </code>está fora do intervalo. Este parâmetro requer um número negativo."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  id: CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: CryptDeriveKey(String,String,Int32,Byte[])
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Derive uma chave criptográfica do <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> objeto."
  remarks: "Essa função é um wrapper para a função de API de criptografia CryptDeriveKey() e pretende oferecer interoperabilidade com aplicativos usando a API de criptografia.       Se o `keySize` parâmetro for definido como 0 bits, o tamanho de chave padrão para o algoritmo especificado será usado."
  syntax:
    content: public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);
    parameters:
    - id: algname
      type: System.String
      description: "O nome do algoritmo para a qual derivar a chave."
    - id: alghashname
      type: System.String
      description: "O nome do algoritmo de hash a ser usado para derivar a chave."
    - id: keySize
      type: System.Int32
      description: "O tamanho da chave em bits, derivar."
    - id: rgbIV
      type: System.Byte[]
      description: "O vetor de inicialização (IV) a ser usado para derivar a chave."
    return:
      type: System.Byte[]
      description: "A chave derivada."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*
  exceptions:
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "O <code> keySize </code> parâmetro está incorreto.       - ou - não é possível obter o provedor de serviços de criptografia (CSP).       - ou - <code> algname </code> parâmetro não é um nome de algoritmo válido.       - ou - <code> alghashname </code> parâmetro não é um nome de algoritmo de hash válido."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Libera os recursos não gerenciados usados pelo <xref href=&quot;System.Security.Cryptography.Rfc2898DeriveBytes&quot;> </xref> classe e, opcionalmente, libera os recursos gerenciados."
  remarks: "Este método é chamado pelo público `Dispose()` método e o `Finalize` método. `Dispose()`invoca o protegido `Dispose(Boolean)` método com o `disposing` parâmetro definido como `true`. `Finalize`invoca `Dispose` com `disposing` definido como `false`.       Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Security.Cryptography.Rfc2898DeriveBytes>referências.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Este método chama o `Dispose()` método de cada objeto referenciado."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  id: GetBytes(System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: GetBytes(Int32)
  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Retorna a chave pseudo-aleatório para este objeto."
  remarks: "A <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe implementa funcionalidade PBKDF2 usando um gerador de números pseudoaleatórios com base em <xref:System.Security.Cryptography.HMACSHA1>.</xref:System.Security.Cryptography.HMACSHA1> </xref:System.Security.Cryptography.Rfc2898DeriveBytes> O <xref:System.Security.Cryptography.Rfc2898DeriveBytes>classe usa uma senha, um valor falso e um número de iteração e, em seguida, gera chaves por meio de chamadas para o método GetBytes.</xref:System.Security.Cryptography.Rfc2898DeriveBytes> Chamadas repetidas para este método não irá gerar a mesma chave; em vez disso, acrescentando duas chamadas do método GetBytes com um `cb` valor de parâmetro de `20` é o equivalente a chamar o método GetBytes uma vez com um `cb` valor de parâmetro de `40`."
  example:
  - "The following example shows how to use the GetBytes method to get the key for an instance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#2](~/add/codesnippet/csharp/m-system.security.crypto_127_1.cs)]\n [!code-vb[rfc28981#2](~/add/codesnippet/visualbasic/m-system.security.crypto_127_1.vb)]\n [!code-cpp[rfc28981#2](~/add/codesnippet/cpp/m-system.security.crypto_127_1.cpp)]"
  syntax:
    content: public override byte[] GetBytes (int cb);
    parameters:
    - id: cb
      type: System.Int32
      description: "O número de bytes de chave pseudo-aleatório para gerar."
    return:
      type: System.Byte[]
      description: "Uma matriz de bytes é preenchida com pseudo-aleatório bytes de chave."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>cb </code>está fora do intervalo. Este parâmetro requer um número negativo."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  id: IterationCount
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Obtém ou define o número de iterações para a operação."
  remarks: "Contagem de iteração é o número de vezes que uma operação é executada. Para esse método, a contagem deve ser maior que zero. O número mínimo recomendado de iterações é 1000."
  example:
  - "The following example shows how to use the IterationCount property to display the number of iterations used in the generation of the key. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#3](~/add/codesnippet/csharp/p-system.security.crypto_117_1.cs)]\n [!code-vb[rfc28981#3](~/add/codesnippet/visualbasic/p-system.security.crypto_117_1.vb)]\n [!code-cpp[rfc28981#3](~/add/codesnippet/cpp/p-system.security.crypto_117_1.cpp)]"
  syntax:
    content: public int IterationCount { get; set; }
    return:
      type: System.Int32
      description: "O número de iterações para a operação."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O número de iterações é menor que 1."
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  id: Reset
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Reset()
  nameWithType: Rfc2898DeriveBytes.Reset()
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Redefine o estado da operação."
  remarks: "Esse método é chamado automaticamente se a contagem de iteração salt é modificada."
  example:
  - "The following example shows how to use the Reset method. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \n  \n [!code-cs[rfc28981#5](~/add/codesnippet/csharp/m-system.security.crypto_26_1.cs)]\n [!code-vb[rfc28981#5](~/add/codesnippet/visualbasic/m-system.security.crypto_26_1.vb)]\n [!code-cpp[rfc28981#5](~/add/codesnippet/cpp/m-system.security.crypto_26_1.cpp)]"
  syntax:
    content: public override void Reset ();
    parameters: []
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  id: Salt
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Obtém ou define o valor de sal chave para a operação."
  remarks: "Salt, um conjunto aleatório de bytes, é usado para fazer a descriptografia não autorizado de uma mensagem mais difícil. Um ataque de dicionário é um ataque em que o invasor tenta descriptografar uma mensagem criptografada, comparando o valor criptografado com valores criptografados anteriormente computados para as chaves mais prováveis. Esse ataque torna muito mais difícil pela introdução de sal ou aleatórios bytes, no final da senha antes da derivação de chaves."
  syntax:
    content: public byte[] Salt { get; set; }
    return:
      type: System.Byte[]
      description: "O valor de sal chave para a operação."
  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho de salt especificado é menor do que 8 bytes."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O salt é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
references:
- uid: System.Security.Cryptography.DeriveBytes
  isExternal: false
  name: System.Security.Cryptography.DeriveBytes
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Cryptography.CryptographicException
  parent: System.Security.Cryptography
  isExternal: false
  name: CryptographicException
  nameWithType: CryptographicException
  fullName: System.Security.Cryptography.CryptographicException
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Byte[])
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Byte[],Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes(String,Int32,Int32)
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: CryptDeriveKey(String,String,Int32,Byte[])
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: GetBytes(Int32)
  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Reset()
  nameWithType: Rfc2898DeriveBytes.Reset()
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Rfc2898DeriveBytes
  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: CryptDeriveKey
  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Dispose
  nameWithType: Rfc2898DeriveBytes.Dispose
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: GetBytes
  nameWithType: Rfc2898DeriveBytes.GetBytes
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: IterationCount
  nameWithType: Rfc2898DeriveBytes.IterationCount
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Reset
  nameWithType: Rfc2898DeriveBytes.Reset
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  isExternal: false
  name: Salt
  nameWithType: Rfc2898DeriveBytes.Salt
