### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "Representa uma sequência de registros armazenada em uma <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "A classe LogRecordSequence fornece uma implementação da interface de sequência do registro na parte superior de um log de sistema de arquivos de Log comuns (CLFS). Além dos recursos orientados a registros padrão, ele fornece um modelo de política para evitar condições de log completo e multiplexação de clientes no mesmo arquivo físico. Ele funciona com o <xref:System.IO.Log.LogStore>classe, que fornece uma interface para diretamente manipular e gerenciando um CLFS o arquivo de log.</xref:System.IO.Log.LogStore> A relação entre o <xref:System.IO.Log.LogStore>classe e a classe LogRecordSequence é semelhante à relação entre um arquivo de disco e um <xref:System.IO.FileStream>objeto.</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> O arquivo de disco fornece armazenamento concreto e tem atributos como comprimento e a hora do último acesso; enquanto o <xref:System.IO.FileStream>objeto fornece uma exibição no arquivo que pode ser usado para lê-lo e gravar proprietário.</xref:System.IO.FileStream> Da mesma forma, a <xref:System.IO.Log.LogStore>classe tem atributos como uma diretiva e uma coleção de extensões do disco; e a classe LogRecordSequence fornece um mecanismo orientado por registro para ler e gravar dados.</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com o armazenamento de log especificado."
  remarks: "O tamanho do buffer determina o tamanho máximo do registro que pode ser anexado ou ler. Este construtor, um valor padrão de 64 é definido. O número desejado de buffers é definido como 10."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que esta sequência de registro deve usar."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>não é válido."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o armazenamento de log e o modo de acesso."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogRecordSequence>em um novo <xref:System.IO.Log.LogStore>objeto que ele abre com o caminho especificado e o modo.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Tem acesso de leitura/gravação para o armazenamento e o armazenamento é aberto para acesso de leitura de compartilhamento."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com o armazenamento de log especificado, o tamanho do buffer para cada registro e o número de buffers."
  remarks: "Use este construtor se desejar especificar valores para `bufferSize` e `bufferCount` e não quiser usar o valor padrão de 64 para `bufferSize` e 10 para `bufferCount`."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que esta sequência de registro deve usar."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho do buffer desejado em bytes. O tamanho do buffer determina o tamanho máximo do registro que pode ser anexado ou ler."
    - id: bufferCount
      type: System.Int32
      description: "O número desejado de buffers."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>é negativo ou zero.       - ou - <code>bufferCount</code> for negativo ou zero."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o armazenamento de log e os modos de acesso e compartilhamento."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogRecordSequence>em um novo <xref:System.IO.Log.LogStore>objeto que ele é aberto com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> O armazenamento é aberto com o compartilhamento de acesso de leitura."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o armazenamento de log e o modo de acesso."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogRecordSequence>em um novo <xref:System.IO.Log.LogStore>objeto que ele é aberto com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> O armazenamento é aberto com o compartilhamento de acesso especificado."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Uma da <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina como o armazenamento de log será compartilhado entre processos."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o armazenamento de log, permissão de arquivo, modos de acesso e compartilhamento e o tamanho do buffer e a contagem de registros."
  remarks: "Este construtor inicializa um novo <xref:System.IO.Log.LogRecordSequence>em um novo <xref:System.IO.Log.LogStore>objeto que ele é aberto com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> O armazenamento é aberto com o compartilhamento de acesso especificado."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma da <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma da <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina como o arquivo pode ser acessado pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Uma da <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina como o armazenamento de log será compartilhado entre processos."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho do buffer desejado em bytes. O tamanho do buffer determina o tamanho máximo do registro que pode ser anexado ou ler."
    - id: bufferCount
      type: System.Int32
      description: "O número desejado de buffers."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;).       - ou - <code>path</code> contém somente espaços em branco.       - ou - <code>path</code> contém um ou mais caracteres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao abrir o armazenamento de log."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo de base de armazenamento de log para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Uma opção válida <xref href=&quot;System.IO.FileMode&quot;> </xref> valor que determina como abrir ou criar o repositório."
    - id: access
      type: System.IO.FileAccess
      description: "Uma opção válida <xref href=&quot;System.IO.FileAccess&quot;> </xref> valor que determina como o armazenamento de log pode ser acessado."
    - id: share
      type: System.IO.FileShare
      description: "Uma opção válida <xref href=&quot;System.IO.FileShare&quot;> </xref> valor que determina como o armazenamento de log será compartilhado entre processos."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho do buffer desejado em bytes. O tamanho do buffer determina o tamanho máximo do registro que pode ser anexado ou ler."
    - id: bufferCount
      type: System.Int32
      description: "O número desejado de buffers."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Uma opção válida <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> valor que especifica a segurança definida no repositório de recém-criado se o repositório deve ser criado."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O arquivo especificado por <code> path </code> não é válido.       - ou - o nome do arquivo de armazenamento de log especificado não é válido.       - ou - <code> mode </code> tem um valor de <xref href=&quot;System.IO.FileMode&quot;> </xref>e não pode ser usado sem acesso de gravação.       - ou - <code> mode </code> tem um valor de <xref href=&quot;System.IO.FileMode&quot;> </xref>e não pode ser usado sem acesso de gravação."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um ou mais argumentos estão fora do intervalo."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo especificado por <code> path </code> não pode ser encontrado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       o arquivo especificado por - ou - <code> path </code> não pode ser acessado porque está em uso por outro processo.       o arquivo especificado por - ou - <code> path </code> não pode ser criado porque o arquivo ou diretório já existe.       - ou - o identificador do log não pôde ser associado ao pool de threads.       - ou - a versão ou o formato de arquivo de log especificado é inválido."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser usado porque o componente necessário do sistema de arquivos de Log comuns (CLFS) não está instalado. Instale o componente CLFS se ele está disponível para sua plataforma ou use o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Avança o número de sequência de base do log. Este método não pode ser herdado."
  remarks: "Esse método é geralmente usado com o <xref:System.IO.Log.LogRecordSequence.TailPinned>evento para liberar espaço em um registro.</xref:System.IO.Log.LogRecordSequence.TailPinned> O <xref:System.IO.Log.LogRecordSequence.TailPinned>evento indica que o final da sequência (ou seja, o número de sequência de base) precisa ser movido para frente para liberar espaço.</xref:System.IO.Log.LogRecordSequence.TailPinned> Liberando espaço pode ser feito por qualquer gravação reiniciar áreas usando o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>truncar o log ou método e usando o método AdvanceBaseSequenceNumber para avançar o número de sequência de base de um log para especificado pelo `newBaseSequenceNumber` parâmetro.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> O exemplo de código na seção de exemplo demonstra a segunda abordagem.       Observe que chamar esse método é o mesmo que definir uma nova sequência de base numérica usando o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>método, exceto que nenhum registro de reinicialização é gravado no log.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Especifica a nova base de <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> para o log. Isso deve estar no intervalo entre o número de sequência de base atual e o último número de sequência do log de modo inclusivo."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>não é válido para essa sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido.       - ou - <code> newBaseSequenceNumber </code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log especificado não tem nenhuma extensão. Uma ou mais extensões devem ser criados antes de uma sequência de registro pode ser usada."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava um registro de log para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registro de log para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registro de log para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, usando o espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para este registro."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registro de log para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, usando o espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para este registro."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência do primeiro registro válido no atual <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "Números de sequência são maior ou igual a BaseSequenceNumber e menor que <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>       O valor dessa propriedade pode ser alterado ao chamar o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>método ou <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>método.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência mais baixo que corresponde a um registro válido no <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Assíncrona começa a operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrona, que pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Assíncrona começa a operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrona, que pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Assíncrona começa a operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para este registro."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrona, que pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Assíncrona começa a operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       O registro acrescentado consumirá espaço que foi anteriormente reservado, usando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem-sucedida, ela consumirá menor área de reserva que pode manter os dados e área de reserva será removida da coleção.       Normalmente, esse método é concluído antes do registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para este registro."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrona, que pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicia uma operação assíncrona de liberação, usando o espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado pelo método atual para o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método para garantir que a liberação é concluída e os recursos são liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Se ocorrer um erro durante um movimento assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       Chamar esse método garante que todos os registros que foram acrescentados ao <xref:System.IO.Log.LogRecordSequence>são gravados de maneira durável.</xref:System.IO.Log.LogRecordSequence>       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação de liberação assíncrona, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro mais recente que deve ser gravado. Se este <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registros devem ser gravados."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a limpeza é concluída."
    - id: state
      type: System.Object
      description: "Um objeto definido pelo usuário que distingue esta solicitação de liberação assíncrona específica de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona operação de liberação, que ainda pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>não é válido para essa sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log especificado não tem nenhuma extensão. Uma ou mais extensões devem ser criados antes de uma sequência de registro pode ser usada."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma reserva assíncrona e operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.       Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para fazer reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas de fazer, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa essa operação assíncrona, o que poderia estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma reserva assíncrona e operação de acréscimo. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método para garantir que a operação de acréscimo foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante um acréscimo assíncrono, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.       Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para fazer reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas de fazer, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a acrescentar for concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecido pelo usuário que distingue esse determinado assíncrona acrescentar uma solicitação de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa essa operação assíncrona, o que poderia estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao anexar o registro."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter o novo registro, ou fazer a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicia uma operação de gravação de área assíncrona de reinicialização, usando o espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante uma operação de gravação assíncrona reinicialização área, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem-sucedido, ele consumirá a reserva de menor que pode manter os dados e reserva será removida da coleção.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Segmentos de matriz de bytes concatenados, que serão anexados como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para a área de reinicialização."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a gravação de área de reinicialização é concluída."
    - id: state
      type: System.Object
      description: "Um objeto definido pelo usuário que distingue esta solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de gravação de área, que ainda pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>não é válido para essa sequência.       - ou - o número de sequência de início de enumeração de log especificado é inválido.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservation</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido.       - ou - <code> newBaseSeqNum </code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicia uma operação de gravação de área assíncrona de reinicialização, usando o espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Você deve transmitir o <xref:System.IAsyncResult>retornado por esse método para o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método para garantir que a operação de gravação de área de reinicialização foi concluída e recursos podem ser liberados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se ocorreu um erro durante uma operação de gravação assíncrona reinicialização área, uma exceção não é lançada até que o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>retornado por esse método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       Quando a operação for concluída com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem-sucedido, ele consumirá a reserva de menor que pode manter os dados e reserva será removida da coleção.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para a área de reinicialização."
    - id: callback
      type: System.AsyncCallback
      description: "Um opcional retorno de chamada assíncrono, a ser chamado quando a gravação de área de reinicialização é concluída."
    - id: state
      type: System.Object
      description: "Um objeto definido pelo usuário que distingue esta solicitação de gravação de área de reinicialização assíncrona específica de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de gravação de área, que ainda pode estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>não é válido para essa sequência.       - ou - o número de sequência de início de enumeração de log especificado é inválido.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservationCollection</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido.       - ou - <code> newBaseSeqNum </code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Cria um novo <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Este método não pode ser herdado."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Recém-criado <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Libera os recursos usados pelo componente."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Conclui uma assíncrona a operação de acréscimo. Este método não pode ser herdado."
  remarks: "Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando EndAppend é chamado.       Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>retornado pelo <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para a solicitação de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>já foi chamado para essa operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Termina uma operação assíncrona de liberação. Este método não pode ser herdado."
  remarks: "Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de liberação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando EndFlush é chamado.       Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>retornado pelo <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para a solicitação de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registro gravado."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para essa operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Conclui uma assíncrona reserva e operação de acréscimo. Este método não pode ser herdado."
  remarks: "Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando EndReserveAndAppend é chamado.       Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>retornado pelo <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para a solicitação de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para essa operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Termina uma operação de gravação assíncrona reinicialização área. Este método não pode ser herdado."
  remarks: "Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, se tornam visíveis quando EndWriteRestartArea é chamado.       Esse método deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>retornado pelo <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para a solicitação de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log gravado."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>não é válido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para essa operação assíncrona."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Garante que todos os registros acrescentados foram gravados. Este método não pode ser herdado."
  remarks: "Chamar esse método garante que todos os registros que foi acrescentada ao <xref:System.IO.Log.LogRecordSequence>tenha sido escrito de forma duradoura.</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registro gravado."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao liberar os dados."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não há suporte para esta operação."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log especificado não tem nenhuma extensão. Uma ou mais extensões devem ser criados antes de uma sequência de registro pode ser usada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Garante que todos os registros anexados até e incluindo o registro com o número de sequência especificado foram gravados muito tempo. Este método não pode ser herdado."
  remarks: "Chamar que esse método garante que todos os registros com sequência de números até e incluindo o número de sequência especificado foram gravados muito tempo."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro mais recente que deve ser gravado. Se este <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registros devem ser gravados."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registro gravado."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>não é válido para essa sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O log especificado não tem nenhuma extensão. Uma ou mais extensões devem ser criados antes de uma sequência de registro pode ser usada."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência que é maior que o último registro anexado"
  remarks: "Esta propriedade contém um número de sequência é garantido para ser maior do que o número de sequência do último registro de anexado. Números de sequência são maiores que ou igual a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>e menor que LastSequenceNumber.</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> Todos os outros números de sequência são inválidos."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Uma sequência numérica que é maior que o último registro anexado."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que contém os dados para esta sequência de registro. Este método não pode ser herdado."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que contém os dados para esta sequência de registro."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o tamanho máximo de um registro que pode ser adicionado a esta sequência de registro."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "O tamanho máximo de um registro que pode ser adicionado a esta sequência de registro."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Retorna uma coleção enumerável de registros na sequência. Este método não pode ser herdado."
  remarks: "Esse método retorna uma coleção enumerável de registros na sequência. A ordem dos registros de enumerada depende do valor da `logRecordEnum` parâmetro."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do primeiro registro de onde a leitura começa."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Uma opção válida <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> valor que especifica a maneira como (ou seja, para frente ou para trás) no qual os registros devem ser lidos de um <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumerável de registros na sequência."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>não é válido para essa sequência.       - ou - <code>logRecordEnum</code> é inválido.       - ou - o elemento especificado não foi encontrado na coleção."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s.       - ou o tamanho do buffer usado para gravar o registro de log é maior do que o tamanho do buffer usado para lê-lo.       - ou - a sequência de registro está corrompida.       - ou - a versão ou o formato de arquivo de log especificado é inválido.       - ou - o registro foi gravado com uma versão incompatível da sequência de registro."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida porque a enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>devem ser feitas.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Retorna uma coleção enumerável de áreas de reinicialização na sequência. Este método não pode ser herdado."
  remarks: "As áreas de reinicialização são enumeradas na ordem do número de sequência inversa, ou seja, do número de sequência mais alto para o menor número de sequência. Reiniciar somente áreas com números de sequência entre o último número de sequência e o número de sequência de base são enumeradas."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumerável das áreas de reinicialização na sequência."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s.       - ou o tamanho do buffer usado para gravar o registro de log é maior do que o tamanho do buffer usado para lê-lo.       - ou - a sequência de registro está corrompida.       - ou - a versão ou o formato de arquivo de log especificado é inválido.       - ou - o registro foi gravado com uma versão incompatível da sequência de registro."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida porque a enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>devem ser feitas.</xref:System.Collections.IEnumerator.MoveNext*>       - ou a enumeração terminou."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automaticamente faz com que uma única reserva e anexa um registro para a sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.       Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a coleção para fazer reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas de fazer, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não é válido para essa sequência.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservations</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automaticamente faz com que uma única reserva e anexa um registro para a sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será ser concatenado em uma matriz de byte único para acrescentar como o registro. No entanto, nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando o registro é lido.       As reservas especificadas são adicionadas para a reserva fornecida coleção em uma operação atômica com um registro de operação de acréscimo. Se a acrescentar falhar, nenhum espaço é reservado.       Normalmente, esse método pode ser concluída antes que o registro foi gravado. Para garantir que um registro foi gravado, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador usando o `recordAppendOptions` parâmetro ou chame o <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem especificada pelo usuário."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do próximo registro na ordem anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica como os dados devem ser gravados."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para fazer reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas de fazer, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registro de log anexado."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao anexar o registro."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter o novo registro, ou fazer a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não está entre os números de base e última sequência dessa sequência."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A operação não pode ser executada porque a sequência de registro foi aberta com acesso somente leitura."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva grande o suficiente para <code> data </code> pode ser encontrado em <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número total de bytes que foram reservados."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "O tamanho total de todas as reservas feitas nessa sequência de registro."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência da área de reinicialização mais próximo ao final do log."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Usando o <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>método, você pode remover o mais recentemente escrito reiniciar área.</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da área de reinicialização mais próximo ao final do log."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém ou define um valor que indica se ou não acrescenta são repetidas automaticamente se o log está cheio."
  remarks: "Se o valor dessa propriedade é `true`e um <xref:System.IO.Log.LogRecordSequence.Append%2A>chamada falha porque não há espaço suficiente na sequência, a sequência de registro tentará espaço livre e tente novamente a acrescentar.</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>se anexa são repetidas automaticamente se o log está cheio; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acessada depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Define o último registro de <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "O número de sequência especificado deve ser maior que o número de sequência de base.       Quando esse método é concluído, todos os registros que anteriormente tinham foi acrescentados com números de sequência maiores que o número de sequência especificado não estão acessíveis."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A última sequência novo número no <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>.       Isso deve consultar um registro atual válido no momento no log."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>não é válido para essa sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido.       - ou - <code> sequenceNumber </code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - o final do log foi atingido.       - ou - a versão ou o formato de arquivo de log especificado é inválido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Indica a necessidade de mover a parte final da sequência."
  remarks: "Esse evento quando a sequência de registro ficou sem espaço pode ser acionado. Quando esse evento é acionado, o final da sequência (ou seja, o número de sequência de base) é movido para frente para liberar espaço.       O evento pode ser acionado a qualquer momento quando a sequência de registro decide que ele deve liberar espaço, por qualquer motivo. Por exemplo, o mecanismo de políticas CLFS poderá acionar o evento quando ele determina as caudas dois clientes de log, compartilhando o mesmo arquivo de log estão muito distantes. Liberando espaço pode ser feito pelo escrever áreas de reinicialização ou truncar o log e usar o <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>método para liberar espaço.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> O exemplo de código na seção de exemplo demonstra a segunda abordagem.       Você também pode chamar o <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>método fora o evento TailPinned para liberar espaço.</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> Uma área de reinicialização é semelhante a um ponto de verificação em outros sistemas de processamento de log. Chamar este método indica que o aplicativo considera todos os registros anteriores antes da área de reinicialização como totalmente concluída e acrescenta pode ser usado para registro futuro. Semelhante a quaisquer outros registros, o registro gravado por este método requer espaço livre no log de função."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão ser concatenados em uma matriz de byte único para acrescentar como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Um segmento da matriz concatenado, que será anexado como o registro."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao gravar a área de reinicialização."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão ser concatenados em uma matriz de byte único para acrescentar como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao gravar a área de reinicialização."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> e atualiza o número de sequência de base. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.       Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao gravar a área de reinicialização."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> e atualiza o número de sequência de base. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.       Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao gravar a área de reinicialização."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> usando uma reserva e atualiza o número de sequência de base. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.       Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e reserva será removida da coleção.       Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para a área de reinicialização."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao gravar a área de reinicialização."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro não foi possível tornar o espaço livre suficiente para conter a nova área de reinicialização."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Grava uma área de reinício para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> usando uma reserva e atualiza o número de sequência de base. Este método não pode ser herdado."
  remarks: "Uma área de reinicialização é usada para armazenar temporariamente informações que contém a última operação de ponto de verificação do cliente. O Common Log arquivo CLFS (sistema) mantém que dois reiniciar áreas para garantir que pelo menos uma área válida está sempre disponível. Quando a recuperação é necessária, o CLFS lê sua área de reinicialização e todos os dados da última operação de ponto de verificação. Esses dados inicializa a tabela de transação, a tabela de páginas sujas e a tabela de arquivos abertos para que possam ser usados no processo de recuperação.       Uma área de reinicialização pode ser lida usando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinicialização é gravada, os dados nos segmentos de matriz de bytes são concatenados em uma matriz de byte único para acréscimo como o registro. Nenhum provisionamento é feito para dividir os dados novamente em segmentos de matriz quando a área de reinicialização é lida.       Se uma reserva for especificada, a área de reinicialização escrito consumirá espaço que foi anteriormente reservado, usando uma reserva contida na coleção. Se o método for bem-sucedido, ele consumirá a reserva de menor que pode conter os dados e reserva será removida da coleção.       Quando esse método é concluído com êxito, o número de sequência de base foi atualizado. Todos os registros de log com números de sequência menor que o novo número de sequência de base não estão acessíveis.       Se uma sequência de registro foi descartada, ou se você passar um argumento inválido, as exceções são geradas imediatamente nessa operação. Erros ocorridos durante uma solicitação assíncrona acréscimo, por exemplo, uma falha durante a solicitação de e/s de disco resulta em exceções que está sendo geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes concatenado, que será anexado como o registro."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência de base. O número de sequência especificado deve ser maior ou igual ao número de sequência de base atual."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Um <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser usada para a área de reinicialização."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da escrita reinicialização área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>não é válido para essa sequência.       - ou - o número de sequência de início de enumeração de log especificado é inválido.       - ou - <code>data</code> não pode ser anexado porque ele é maior que o tamanho máximo do registro.       - ou - <code>reservationCollection</code> não foi criado por essa sequência de registro."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente final ou uma base do log ativo é inválido.       - ou - <code> newBaseSeqNum </code> não está entre os números de base e última sequência dessa sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A solicitação não pôde ser executada devido a uma exceção de e/s inesperada.       - ou - a solicitação não pôde ser executada devido a um erro de dispositivo de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para a sequência de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
