### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Representa um domínio de aplicativo, que é um ambiente isolado em que os aplicativos são executados. Essa classe não pode ser herdada."
  remarks: "Domínios de aplicativo, que são representados por objetos de AppDomain, ajudam a fornecer limites, descarregamento, segurança e isolamento para código gerenciado em execução.      -Use domínios de aplicativo para isolar as tarefas que podem colocar um processo. Se o estado do AppDomain que está executando uma tarefa se tornar instável, AppDomain pode ser descarregado sem afetar o processo. Isso é importante quando um processo deve ser executado por longos períodos sem reiniciar. Você também pode usar domínios de aplicativo para isolar as tarefas que não devem compartilhar dados.      -Se um assembly é carregado no domínio de aplicativo padrão, ele não pode ser descarregado da memória enquanto o processo está em execução. No entanto, se você abrir um segundo domínio de aplicativo para carregar e executar o assembly, o assembly é descarregado quando o domínio de aplicativo é descarregado. Use essa técnica para minimizar o conjunto de trabalho de processos de execução demorada que usam ocasionalmente DLLs grandes.       Vários domínios de aplicativo podem executar em um único processo; No entanto, não há uma correlação entre domínios de aplicativo e segmentos. Vários threads podem pertencer a um único domínio de aplicativo e, enquanto um determinado thread não está limitado a um único domínio de aplicativo, a qualquer momento determinado, um thread é executado em um único domínio de aplicativo.       Domínios de aplicativo são criados usando o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> Instâncias de AppDomain são usadas para carregar e executar assemblies (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Quando um AppDomain não estiver mais em uso, ele pode ser descarregado.       A classe AppDomain implementa um conjunto de eventos que habilitam aplicativos para responder quando um assembly é carregado, quando um domínio de aplicativo será descarregado, ou quando uma exceção sem tratamento.       Para obter mais informações sobre como usar domínios de aplicativo, consulte [domínios de aplicativo](~/add/includes/ajax-current-ext-md.md).       Essa classe implementa o <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory>interfaces.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       Você nunca deve criar um wrapper remota de um objeto de AppDomain. Isso foi possível publicar uma referência remota ao AppDomain, expor métodos, como <xref:System.AppDomain.CreateInstance%2A>para acesso remoto e efetivamente destruição de segurança de acesso ao código para AppDomain.</xref:System.AppDomain.CreateInstance%2A> Mal-intencionado clientes conectando-se de um AppDomain remota podem obter acesso a qualquer recurso que AppDomain em si tem acesso. Não criar wrappers remota para qualquer tipo que estende <xref:System.MarshalByRefObject>e que implementa os métodos que podem ser usados por clientes mal-intencionado para ignorar o sistema de segurança.</xref:System.MarshalByRefObject>      > [!CAUTION] > O valor padrão para o <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>é de propriedade `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Essa configuração não é segura para serviços. Para impedir que serviços baixando código parcialmente confiável, defina essa propriedade como `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o contexto de ativação para o domínio de aplicativo atual."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Um objeto que representa o contexto de ativação para o domínio de aplicativo atual, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o domínio não tiver nenhum contexto de ativação."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anexa o nome do diretório especificado para a lista de caminho particular."
  remarks: "O uso dessa propriedade não é recomendável, pois ele pode alterar o caminho de sondagem para assemblies depois que já foram carregados. Use o <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>propriedade em vez disso.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       O caminho particular ou caminho de pesquisa relativo é o caminho relativo para o diretório base onde o resolvedor de assembly sondas de assemblies privados."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "O nome do diretório a ser acrescentado ao caminho particular."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém a identidade do aplicativo no domínio do aplicativo."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Um objeto que identifica o aplicativo no domínio do aplicativo."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as informações que descrevem as permissões concedidas a um aplicativo e se o aplicativo tem um nível de confiança que permite que ele seja executado."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Um objeto que encapsula as informações de permissão e a relação de confiança para o aplicativo no domínio do aplicativo."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retorna o nome para exibição do assembly depois que a diretiva foi aplicada."
  remarks: "O método usa um assembly de ApplyPolicy nome para exibição e retorna o nome de exibição de pós política de. Isso é útil se você precisar carregar um assembly usando a política, porque o contexto exclusivo de reflexão não se aplica a política."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O assembly exibe nome, no formato fornecido pelo &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.String
      description: "Uma cadeia de caracteres que contém o assembly de nome de exibição depois que a diretiva foi aplicada."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando um assembly é carregado."
  remarks: "O <xref:System.AssemblyLoadEventHandler>delegar para esse evento indica que o assembly foi carregado.</xref:System.AssemblyLoadEventHandler>       Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um assembly falha."
  remarks: "É responsabilidade do <xref:System.ResolveEventHandler>para esse evento retornar o assembly que é especificado pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade, ou para retornar null se o assembly não é reconhecido.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> O assembly deve ser carregado em um contexto de execução; Se ele é carregado no contexto exclusivo de reflexão, a carga que causou este evento a ser gerado falhará.       Para obter diretrizes sobre o uso desse evento, consulte [Resolvendo carregamentos de Assembly](~/add/includes/ajax-current-ext-md.md).       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade retorna o assembly que pediu a carga de assembly não pôde ser resolvida.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Por exemplo, o carregador pode ser não é possível carregar uma dependência do solicitante assembly porque o assembly solicitante e sua dependência não estão no caminho de investigação. Saber a identidade do solicitante assembly pode ser úteis na localização de dependência ou identificar a versão correta, se houver mais de uma versão da dependência. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], o <xref:System.ResolveEventHandler>é gerado para todos os assemblies, incluindo módulos de recursos.</xref:System.ResolveEventHandler> Em versões anteriores, o evento não foi gerado para módulos de recursos. Se o sistema operacional está localizado, o manipulador pode ser chamado várias vezes: uma vez para cada cultura na cadeia de fallback.       Para esse evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade retorna o nome do assembly, antes da política é aplicada.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Se mais de um manipulador de eventos é registrado para esse evento, o evento handlersarecalled na ordem até que um manipulador de eventos retorna um valor que não é `null`. Manipuladores de eventos subsequentes serão ignorados.       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o diretório base que usa o resolvedor de assembly de teste para assemblies."
  remarks: "Essa propriedade corresponde do <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>propriedade.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Ele também pode ser recuperado usando o <xref:System.AppDomain.GetData%2A>método com a cadeia de caracteres &quot;APPBASE&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "O diretório base que usa o resolvedor de assembly de teste para assemblies."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Redefine o caminho que especifica o local dos assemblies privados para a cadeia de caracteres vazia (&quot;&quot;)."
  remarks: "O caminho particular é um caminho relativo para o diretório base do que o common language runtime pesquisa para localizar assemblies privados.       Para obter mais informações, consulte <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Redefine a lista de diretórios que contêm assemblies de cópia de sombra para a cadeia de caracteres vazia (&quot;&quot;)."
  remarks: "O caminho de cópia de sombra é uma lista de diretórios onde a sombra copiados assemblies são armazenados.       Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>e [cópia de sombra de Assemblies](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância de um tipo COM especificado. Parâmetros especificam o nome de um arquivo que contém um assembly que contém o tipo e o nome do tipo."
  remarks: "Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.       O valor de retorno deve para ser desencapsulamento para acessar o objeto real.       Um<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException>é gerada.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de um arquivo que contém um assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome do tipo solicitado."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "O tipo não pode ser carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público sem parâmetros foi encontrado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>é uma classe abstrata.       - ou - este membro foi chamado com um mecanismo de associação tardia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>é uma cadeia de caracteres vazia (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O objeto COM que está sendo referenciado é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância de um tipo COM especificado. Parâmetros especificam o nome de um arquivo que contém um assembly que contém o tipo e o nome do tipo."
  remarks: "Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.       O valor de retorno deve para ser desencapsulamento para acessar o objeto real.       Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException>é gerada.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome de um arquivo que contém um assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome do tipo solicitado."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código de hash computado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo de hash usado pelo manifesto do assembly."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "O tipo não pode ser carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público sem parâmetros foi encontrado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>é uma classe abstrata.       - ou - este membro foi chamado com um mecanismo de associação tardia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>é a cadeia de caracteres vazia (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O objeto COM que está sendo referenciado é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo com o nome especificado."
  remarks: "O `friendlyName` parâmetro destina-se para identificar o domínio de uma maneira que seja significativa para os usuários. Essa cadeia de caracteres deve ser adequada para exibição nas interfaces do usuário.       Essa sobrecarga de método usa o <xref:System.AppDomainSetup>informações do domínio de aplicativo padrão.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo com o nome especificado usando a evidência fornecida."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Esse nome amigável pode ser exibido em interfaces de usuário para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidência que estabelece a identidade do código que é executado no domínio de aplicativo. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar a evidência do domínio do aplicativo atual."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo usando o nome especificado, evidência e informações de configuração de domínio de aplicativo."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Esse nome amigável pode ser exibido em interfaces de usuário para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidência que estabelece a identidade do código que é executado no domínio de aplicativo. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar a evidência do domínio do aplicativo atual."
    - id: info
      type: System.AppDomainSetup
      description: "Um objeto que contém informações de inicialização de domínio de aplicativo."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo usando o nome especificado, evidência, informações de configuração de domínio de aplicativo, conjunto de permissões padrão e o conjunto de assemblies totalmente confiáveis."
  remarks: "Você deve definir o <xref:System.AppDomainSetup.ApplicationBase%2A>propriedade o <xref:System.AppDomainSetup>objeto que você fornecer para `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> Caso contrário, uma exceção será lançada.       Se `securityInfo` não é fornecido, a evidência do atual domínio de aplicativo é usada.       As informações fornecidas para `grantSet` e `fullTrustAssemblies` é usado para criar um <xref:System.Security.Policy.ApplicationTrust>objeto para o novo domínio de aplicativo.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Esse nome amigável pode ser exibido em interfaces de usuário para identificar o domínio. Para obter mais informações, consulte a descrição de <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidência que estabelece a identidade do código que é executado no domínio de aplicativo. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar a evidência do domínio do aplicativo atual."
    - id: info
      type: System.AppDomainSetup
      description: "Um objeto que contém informações de inicialização de domínio de aplicativo."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Um conjunto de permissões padrão concedidas a todos os assemblies carregados no novo domínio de aplicativo que não têm concessões específicas."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "Uma matriz de nomes fortes que representa os assemblies a serem considerados totalmente confiável no novo domínio de aplicativo."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O domínio de aplicativo é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - ou - o <xref:System.AppDomainSetup.ApplicationBase*>propriedade não está definida no <xref href=&quot;System.AppDomainSetup&quot;> </xref> objeto que é fornecido para <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregado no domínio de aplicativo."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Esse nome amigável pode ser exibido em interfaces de usuário para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidência que estabelece a identidade do código que é executado no domínio de aplicativo. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar a evidência do domínio do aplicativo atual."
    - id: appBasePath
      type: System.String
      description: "O diretório base que usa o resolvedor de assembly de teste para assemblies. Para obter mais informações, consulte <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "O caminho relativo para o diretório base onde o resolvedor de assembly deve investigar assemblies privados. Para obter mais informações, consulte <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Se <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, uma cópia de sombra de um assembly é carregada para esse domínio de aplicativo."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregado no domínio de aplicativo. Especifica um método de retorno de chamada que é invocado quando o domínio de aplicativo é inicializado e uma matriz de argumentos de cadeia de caracteres para passar o método de retorno de chamada."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Esse nome amigável pode ser exibido em interfaces de usuário para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Evidência que estabelece a identidade do código que é executado no domínio de aplicativo. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para usar a evidência do domínio do aplicativo atual."
    - id: appBasePath
      type: System.String
      description: "O diretório base que usa o resolvedor de assembly de teste para assemblies. Para obter mais informações, consulte <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "O caminho relativo para o diretório base onde o resolvedor de assembly deve investigar assemblies privados. Para obter mais informações, consulte <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para carregar uma cópia de sombra de um assembly no domínio de aplicativo."
    - id: adInit
      type: System.AppDomainInitializer
      description: "Um <xref href=&quot;System.AppDomainInitializer&quot;> </xref> delegado que representa um método de retorno de chamada para invocar quando o novo <xref href=&quot;System.AppDomain&quot;> </xref> objeto é inicializado."
    - id: adInitArgs
      type: System.String[]
      description: "Uma matriz de argumentos de cadeia de caracteres a serem passados para o retorno de chamada representado por `adInit`, quando o novo <xref href=&quot;System.AppDomain&quot;> </xref> objeto é inicializado."
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo recém-criado."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no assembly especificado."
  remarks: "Este método chama o construtor padrão para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar CreateInstance em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino. Como um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tentar retornar o <xref:System.Reflection.Assembly>para o assembly carregado para o domínio de aplicativo atual, o common language runtime tentará carregar o assembly no domínio de aplicativo atual e a carga pode falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> O assembly que é carregado no domínio do aplicativo atual pode ser diferente do assembly que foi carregado pela primeira vez, se as configurações de caminho para os domínios de dois aplicativo são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no assembly especificado. Um parâmetro especifica uma matriz de atributos de ativação."
  remarks: "Este método chama o construtor padrão para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>em um destino de domínio de aplicativo que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstance%2A> Como um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tentar retornar o <xref:System.Reflection.Assembly>para o assembly carregado para o domínio de aplicativo atual, o common language runtime tentará carregar o assembly no domínio de aplicativo atual e a carga pode falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> O assembly que é carregado no domínio do aplicativo atual pode ser diferente do assembly que foi carregado pela primeira vez, se as configurações de caminho para os domínios de dois aplicativo são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no assembly especificado. Parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, informações específicas de cultura usada para interpretar os argumentos e atributos de ativação opcional."
  remarks: "Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>em um destino de domínio de aplicativo que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstance%2A> Como um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tentar retornar o <xref:System.Reflection.Assembly>para o assembly carregado para o domínio de aplicativo atual, o common language runtime tentará carregar o assembly no domínio de aplicativo atual e a carga pode falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> O assembly que é carregado no domínio do aplicativo atual pode ser diferente do assembly que foi carregado pela primeira vez, se as configurações de caminho para os domínios de dois aplicativo são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos usando a reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - <code>assemblyName</code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor correspondente foi encontrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no assembly especificado. Parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, usado para interpretar os argumentos, atributos de ativação e autorização para criar o tipo de informações de cultura específica."
  remarks: "Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>em um destino de domínio de aplicativo que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstance%2A> Como um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tentar retornar o <xref:System.Reflection.Assembly>para o assembly carregado para o domínio de aplicativo atual, o common language runtime tentará carregar o assembly no domínio de aplicativo atual e a carga pode falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> O assembly que é carregado no domínio do aplicativo atual pode ser diferente do assembly que foi carregado pela primeira vez, se as configurações de caminho para os domínios de dois aplicativo são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos usando a reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações usadas para autorizar a criação de `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância especificado por <code> typeName </code>. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor correspondente foi encontrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code> securityAttributes </code> devem ser<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Parâmetros especificam o assembly em que o tipo é definido e o nome do tipo."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Este método chama o construtor padrão para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade de formato de `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se você fazer uma chamada early bound para um método `M` de um objeto do tipo `T1` que foi retornado por CreateInstanceAndUnwrap e esse método faz uma chamada early bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou o assembly que contém `T1`, assembly `C` é carregado no domínio do aplicativo atual. Esse carregamento ocorre mesmo se chamada early bound `T1.M()` foi feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou em outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio padrão, o assembly `C` não pode ser descarregado até que o processo termina. Se o domínio atual posteriormente tentar carregar o assembly `C`, a carga pode falhar."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Parâmetros especificam o assembly em que o tipo é definido, o nome do tipo e uma matriz de atributos de ativação."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Este método chama o construtor padrão para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade de formato de `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se você fazer uma chamada early bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e o método faz uma chamada early bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou o assembly que contém `T1`, assembly `C` é carregado no domínio do aplicativo atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Esse carregamento ocorre mesmo se chamada early bound `T1.M()` foi feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou em outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio padrão, o assembly `C` não pode ser descarregado até que o processo termina. Se o domínio atual posteriormente tentar carregar o assembly `C`, a carga pode falhar."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no assembly especificado, especificando se o caso do nome do tipo é ignorado; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade de formato de `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se você fazer uma chamada early bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e o método faz uma chamada early bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou o assembly que contém `T1`, assembly `C` é carregado no domínio do aplicativo atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Esse carregamento ocorre mesmo se chamada early bound `T1.M()` foi feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou em outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio padrão, o assembly `C` não pode ser descarregado até que o processo termina. Se o domínio atual posteriormente tentar carregar o assembly `C`, a carga pode falhar."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos usando a reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Um objeto de específicos de cultura usado para controlar a coerção de tipos. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> para o segmento atual é usado."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto. que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor correspondente foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - <code>assemblyName</code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Parâmetros especificam o nome do tipo e como ele é encontrado e criado."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Consulte <xref:System.Reflection.AssemblyName>para o formato de `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade de formato de `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se você fazer uma chamada early bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e o método faz uma chamada early bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou o assembly que contém `T1`, assembly `C` é carregado no domínio do aplicativo atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Esse carregamento ocorre mesmo se chamada early bound `T1.M()` foi feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou em outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio padrão, o assembly `C` não pode ser descarregado até que o processo termina. Se o domínio atual posteriormente tentar carregar o assembly `C`, a carga pode falhar."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos usando a reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Um objeto de específicos de cultura usado para controlar a coerção de tipos. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> para o segmento atual é usado."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações usadas para autorizar a criação de `typeName`."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor correspondente foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "O construtor padrão para `typeName` é invocado.       Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o método CreateInstanceFrom é usado para criar uma instância em um domínio de aplicativo de destino, que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino. No entanto, se a instância for desfeita no domínio do aplicativo de chamada, usando a instância não encapsulada de determinadas maneiras pode causar o assembly a ser carregados para o domínio de aplicativo de chamada. Por exemplo, depois que a instância for desfeita, as informações de tipo podem ser solicitadas, para chamar seus métodos de associação tardia. Quando o assembly é carregado para o domínio de aplicativo de chamada, exceções podem ocorrer.      -Se a outra versão do mesmo assembly foi carregada anteriormente no domínio de aplicativo chamada, ou se o caminho de carregamento do domínio do aplicativo de chamada é diferente do domínio de aplicativo de destino, exceções, como <xref:System.MissingMethodException>pode ocorrer.</xref:System.MissingMethodException>      -Se o domínio de aplicativo chamada faz chamadas early bound ao tipo de instância, <xref:System.InvalidCastException>pode ser gerada quando é feita uma tentativa de converter a instância.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público sem parâmetros foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "O construtor padrão para `typeName` é invocado.       Para obter mais informações sobre esse método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é usado para criar uma instância em um domínio de aplicativo de destino, que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância for desfeita no domínio do aplicativo de chamada, usando a instância não encapsulada de determinadas maneiras pode causar o assembly a ser carregados para o domínio de aplicativo de chamada. Por exemplo, depois que a instância for desfeita, as informações de tipo podem ser solicitadas, para chamar seus métodos de associação tardia. Quando o assembly é carregado para o domínio de aplicativo de chamada, exceções podem ocorrer.      -Se a outra versão do mesmo assembly foi carregada anteriormente no domínio de aplicativo chamada, ou se o caminho de carregamento do domínio do aplicativo de chamada é diferente do domínio de aplicativo de destino, exceções, como <xref:System.MissingMethodException>pode ocorrer.</xref:System.MissingMethodException>      -Se o domínio de aplicativo chamada faz chamadas early bound ao tipo de instância, <xref:System.InvalidCastException>pode ser gerada quando é feita uma tentativa de converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é usado para criar uma instância em um domínio de aplicativo de destino, que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância for desfeita no domínio do aplicativo de chamada, usando a instância não encapsulada de determinadas maneiras pode causar o assembly a ser carregados para o domínio de aplicativo de chamada. Por exemplo, depois que a instância for desfeita, as informações de tipo podem ser solicitadas, para chamar seus métodos de associação tardia. Quando o assembly é carregado para o domínio de aplicativo de chamada, exceções podem ocorrer.      -Se a outra versão do mesmo assembly foi carregada anteriormente no domínio de aplicativo chamada, ou se o caminho de carregamento do domínio do aplicativo de chamada é diferente do domínio de aplicativo de destino, exceções, como <xref:System.MissingMethodException>pode ocorrer.</xref:System.MissingMethodException>      -Se o domínio de aplicativo chamada faz chamadas early bound ao tipo de instância, <xref:System.InvalidCastException>pode ser gerada quando é feita uma tentativa de converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos por meio de reflexo.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - <code>assemblyFile</code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "Para obter mais informações sobre esse método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é usado para criar uma instância em um domínio de aplicativo de destino, que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância for desfeita no domínio do aplicativo de chamada, usando a instância não encapsulada de determinadas maneiras pode causar o assembly a ser carregados para o domínio de aplicativo de chamada. Por exemplo, depois que a instância for desfeita, as informações de tipo podem ser solicitadas, para chamar seus métodos de associação tardia. Quando o assembly é carregado para o domínio de aplicativo de chamada, exceções podem ocorrer.      -Se a outra versão do mesmo assembly foi carregada anteriormente no domínio de aplicativo chamada, ou se o caminho de carregamento do domínio do aplicativo de chamada é diferente do domínio de aplicativo de destino, exceções, como <xref:System.MissingMethodException>pode ocorrer.</xref:System.MissingMethodException>      -Se o domínio de aplicativo chamada faz chamadas early bound ao tipo de instância, <xref:System.InvalidCastException>pode ser gerada quando é feita uma tentativa de converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos por meio de reflexo.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações usadas para autorizar a criação de `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que é um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno precisa ser desencapsulamento para acessar o objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code> securityAttributes </code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Este método chama o construtor padrão para `typeName`.       Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de arquivo e caminho do assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Object
      description: "O objeto solicitado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público sem parâmetros foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Este método chama o construtor padrão para `typeName`.       Para obter mais informações sobre esse método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de arquivo e caminho do assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly (consulte o &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade)."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "O objeto solicitado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público sem parâmetros foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado, especificando se o caso do nome do tipo é ignorado; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Para obter mais informações sobre esse método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome de arquivo e caminho do assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos por meio de reflexo.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "O objeto solicitado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - <code>assemblyName</code> foi compilado com uma versão posterior do common language runtime que a versão que está sendo carregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado."
  remarks: "Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Para obter mais informações sobre esse método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de arquivo e caminho do assembly que define o tipo solicitado."
    - id: typeName
      type: System.String
      description: "O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly, conforme retornado pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite que a associação, a coerção de argumento, chamada de membros e a recuperação de <xref:System.Reflection.MemberInfo>objetos por meio de reflexo.</xref:System.Reflection.MemberInfo> Se `binder` é null, o associador padrão é usado."
    - id: args
      type: System.Object[]
      description: "Os argumentos para passar para o construtor. Essa matriz de argumentos deve corresponder em número, ordem e digite os parâmetros do construtor para invocar. Se o construtor padrão é preferencial, `args` deve ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que governam a coerção de `args` para os tipos formais declarados para o `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o <xref:System.Globalization.CultureInfo>para o segmento atual é usado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar de ativação. Normalmente, uma matriz que contém um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica a URL que é necessária para ativar um objeto remoto.       Esse parâmetro está relacionado aos objetos de cliente ativado. Ativação do cliente é uma tecnologia herdada que é mantida para compatibilidade com versões anteriores, mas não é recomendada para novo desenvolvimento. Aplicativos distribuídos em vez disso, devem usar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações usadas para autorizar a criação de `typeName`."
    return:
      type: System.Object
      description: "O objeto solicitado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O chamador não pode fornecer os atributos de ativação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nenhum construtor público correspondente foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissões suficientes para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyName</code> foi compilado com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o domínio atual do aplicativo atual <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "O domínio de aplicativo atual."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico com o modo de acesso e do nome especificado."
  remarks: "Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para o assembly dinâmico."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o modo de acesso e do nome especificado."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico com o nome especificado, o modo de acesso e os atributos personalizados."
  remarks: "Use essa sobrecarga de método para especificar atributos que não funcionam corretamente, a menos que elas são aplicadas quando um assembly dinâmico é criado. Por exemplo, atributos de segurança, como <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionarão corretamente se eles são adicionados depois que um assembly dinâmico foi criado.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para o assembly dinâmico."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumerável de atributos a serem aplicados ao assembly, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se não houver nenhum atributo."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso e a evidência."
  remarks: "Somente confiáveis os chamadores podem fornecer seus `evidence` ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões, ou seja, o atual grant e deny conjuntos, do chamador <xref:System.Reflection.Assembly>para dinâmico <xref:System.Reflection.Assembly>que está sendo definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinâmico <xref:System.Reflection.Assembly>é salvo em disco, carregamentos subsequentes receberá concessões com base nas políticas associadas ao local onde o <xref:System.Reflection.Assembly>foi salvo.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso e o diretório de armazenamento."
  remarks: "Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório padrão é o diretório atual."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico com o nome especificado, o modo de acesso e os atributos personalizados e usando a origem especificada para o seu contexto de segurança."
  remarks: "Use essa sobrecarga de método para especificar atributos que não funcionam corretamente, a menos que elas são aplicadas quando um assembly dinâmico é criado. Por exemplo, atributos de segurança, como <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionarão corretamente se eles são adicionados depois que um assembly dinâmico foi criado.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para o assembly dinâmico."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumerável de atributos a serem aplicados ao assembly, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se não houver nenhum atributo."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "A origem do contexto de segurança."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> securityContextSource </code> não era um dos valores de enumeração."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento e evidência."
  remarks: "Somente confiáveis os chamadores podem fornecer seus `evidence` ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões, ou seja, o atual grant e deny conjuntos, do chamador <xref:System.Reflection.Assembly>para dinâmico <xref:System.Reflection.Assembly>que está sendo definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinâmico <xref:System.Reflection.Assembly>é salvo em disco, carregamentos subsequentes receberá concessões com base nas políticas associadas ao local onde o <xref:System.Reflection.Assembly>foi salvo.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório padrão é o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso e a solicitações de permissão."
  remarks: "As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória. Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo em disco, use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence>objeto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento e opção de sincronização."
  remarks: "Use essa sobrecarga de método para especificar atributos que não funcionam corretamente, a menos que elas são aplicadas quando um assembly dinâmico é criado. Por exemplo, atributos de segurança, como <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionarão corretamente se eles são adicionados depois que um assembly dinâmico foi criado.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro é concluído."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly dinâmico será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório atual é usado."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumerável de atributos a serem aplicados ao assembly, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se não houver nenhum atributo."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, evidência e solicitações de permissão."
  remarks: "As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Somente confiáveis os chamadores podem fornecer seus `evidence` ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões, ou seja, o atual grant e deny conjuntos, do chamador <xref:System.Reflection.Assembly>para dinâmico <xref:System.Reflection.Assembly>que está sendo definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinâmico <xref:System.Reflection.Assembly>é salvo em disco, carregamentos subsequentes receberá concessões com base nas políticas associadas ao local onde o <xref:System.Reflection.Assembly>foi salvo.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, o diretório de armazenamento e a solicitações de permissão."
  remarks: "As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória. Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo em disco, use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence>objeto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica a evidência e permissões, forneça a evidência que você deseja que o assembly dinâmico, e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório padrão é o diretório atual."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento, evidência e solicitações de permissão."
  remarks: "As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Somente confiáveis os chamadores podem fornecer seus `evidence` ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões, ou seja, o atual grant e deny conjuntos, do chamador <xref:System.Reflection.Assembly>para dinâmico <xref:System.Reflection.Assembly>que está sendo definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinâmico <xref:System.Reflection.Assembly>é salvo em disco, carregamentos subsequentes receberá concessões com base nas políticas associadas ao local onde o <xref:System.Reflection.Assembly>foi salvo.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Esse método só deve ser usado para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório padrão é o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento, evidência, solicitações de permissão e opção de sincronização."
  remarks: "As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>em `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro garante que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Somente os chamadores totalmente confiáveis podem fornecer seu evidência ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer `null` para o `evidence` parâmetro. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões, ou seja, o atual grant e deny conjuntos, do chamador <xref:System.Reflection.Assembly>para dinâmico <xref:System.Reflection.Assembly>que está sendo definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se dinâmico <xref:System.Reflection.Assembly>é salvo em disco, carregamentos subsequentes receberá concessões com base nas políticas associadas ao local onde o <xref:System.Reflection.Assembly>foi salvo.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que outra seja concluída."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly dinâmico será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório padrão é o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define um assembly dinâmico com o nome especificado, o modo de acesso, diretório de armazenamento, evidência, solicitações de permissão, opção de sincronização e atributos personalizados."
  remarks: "Use essa sobrecarga de método para especificar atributos que não funcionam corretamente, a menos que elas são aplicadas quando um assembly dinâmico é criado. Por exemplo, atributos de segurança, como <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionarão corretamente se eles são adicionados depois que um assembly dinâmico foi criado.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       As solicitações de permissão especificadas para o `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parâmetros são usados somente se o `evidence` parâmetro também é fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.      > [!NOTE] > Ao desenvolver o código que emite assemblies dinâmicos, recomendamos que você inclua o <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>sinalizador no `refusedPermissions` parâmetro.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> A inclusão do sinalizador garante que a Microsoft intermediate language (MSIL) será verificado. Essa técnica detectará a geração não intencional de código não verificado, o que, normalmente, é muito difícil de detectar. Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException>seja gerada quando é usado com o código que exige confiança total.</xref:System.Security.SecurityException>       Somente os chamadores totalmente confiáveis podem fornecer evidências ao definir um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeia o <xref:System.Security.Policy.Evidence>por meio da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente confiável chamadores devem fornecer `null` para o `evidence` parâmetro. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões (isto é, a concessão atual e negar conjuntos) do assembly do chamador para o assembly dinâmico que está sendo definido e marca a política como resolvido.       Se o assembly dinâmico é salvo em disco, subsequente cargas receberá concessões com base nas políticas que estão associadas com o local onde o assembly dinâmico foi salvo.       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro é concluído.       Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva do assembly dinâmico."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo no qual o assembly dinâmico será acessado."
    - id: dir
      type: System.String
      description: "O nome do diretório onde o assembly dinâmico será salvo. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório atual é usado."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A evidência que é fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado para resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões opcionais."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Solicitam as permissões recusadas."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumerável de atributos a serem aplicados ao assembly, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se não houver nenhum atributo."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Um assembly dinâmico com o nome especificado e recursos."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com espaço em branco ou contém uma barra para frente ou para trás."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o código em outro domínio de aplicativo que é identificado pelo delegado especificado."
  remarks: '`callBackDelegate`pode especificar um marshal-por-valor, <xref:System.MarshalByRefObject>, ou <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Um delegado que especifica um método de chamada."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o Gerenciador de domínio que foi fornecido pelo host quando o domínio de aplicativo foi inicializado."
  remarks: "Um host não gerenciado do common language runtime (CLR) pode fornecer um Gerenciador de domínio. O Gerenciador de domínio pode participar de inicializar o novo domínio de aplicativo e fornece outros gerentes, como um <xref:System.Security.HostSecurityManager>, que participam de operações do domínio do aplicativo.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Um objeto que representa o Gerenciador de domínio fornecido pelo host quando o domínio de aplicativo foi inicializado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum Gerenciador de domínio foi fornecido."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando uma <xref href=&quot;System.AppDomain&quot;> </xref> está prestes a ser descarregado."
  remarks: "O <xref:System.EventHandler>delegar para esse evento pode executar as atividades de encerramento antes que o domínio de aplicativo seja descarregado.</xref:System.EventHandler>       Cada domínio de aplicativo que precisa executar o processamento quando ela é descarregada deve registrar um manipulador de eventos para esse evento. Um manipulador de eventos compartilhado não deve ser usado porque o <xref:System.EventHandler>delegado não identifica o domínio que está sendo descarregado.</xref:System.EventHandler>      > [!NOTE] > Nunca, esse evento é gerado no domínio de aplicativo padrão.       Não faça suposições sobre o thread em que o evento é gerado em. O evento pode ser gerado em um thread diferente daquela que chamou o <xref:System.AppDomain.Unload%2A>método.</xref:System.AppDomain.Unload%2A>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o diretório que usa o resolvedor de assembly de teste para assemblies criados dinamicamente."
  remarks: "Para definir o diretório dinâmico, atribua um caminho de diretório base para o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>propriedade o <xref:System.AppDomainSetup>objeto que será usado para criar o novo domínio de aplicativo.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> O caminho do diretório base atribuído à propriedade é modificado pela adição de um subdiretório, cujo nome simple é o código hash da cadeia de caracteres que você atribui ao <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>propriedade, portanto, o formato do diretório base é *caminho original*\\\\*o código hash*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> O diretório dinâmico é uma subpasta desta pasta base. O nome simple é o valor da <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>propriedade, portanto, seu formato é *caminho original*\\\\*o código hash*\\\\*nome do aplicativo*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "O diretório que usa o resolvedor de assembly de teste para assemblies criados dinamicamente."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> associados a esse domínio de aplicativo."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "A evidência associada a esse domínio de aplicativo."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Para criar o <xref:System.AppDomain>para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado, usando a evidência especificada."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       O <xref:System.AppDomain.ExecuteAssembly%2A>método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.</xref:System.AppDomain.ExecuteAssembly%2A>       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado, usando os argumentos especificados."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada do assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - <code>assemblyFile</code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado, usando a evidência especificada e os argumentos."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada do assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code>assemblySecurity</code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado, usando os argumentos especificados, o valor de hash e o algoritmo de hash."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada do assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código de hash computado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo de hash usado pelo manifesto do assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - <code>assemblyFile</code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly contido no arquivo especificado, usando a evidência especificada, a argumentos, o valor de hash e o algoritmo de hash."
  remarks: "O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Esse método carrega assemblies que usam o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Você também pode executar assemblies usando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, que carrega assemblies que usam o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do arquivo que contém o assembly para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A evidência fornecida para o assembly."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada do assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código de hash computado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo de hash usado pelo manifesto do assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyFile</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code>assemblySecurity</code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa um assembly fornecido seu nome de exibição."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.       Para criar o <xref:System.AppDomain>para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code> assemblyName </code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly devido a um <xref:System.Reflection.AssemblyName>, usando os argumentos especificados.</xref:System.Reflection.AssemblyName>"
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Um <xref:System.Reflection.AssemblyName>objeto que representa o nome do assembly.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - <code> assemblyName </code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa um assembly fornecido seu nome de exibição, usando a evidência especificada."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>parâmetros, partes de evidência são mesclados.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituir partes de evidência fornecida pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code> assemblyName </code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly fornecido seu nome de exibição, usando os argumentos especificados."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - <code> assemblyName </code> foi compilado com uma versão posterior do common language runtime que a versão que está atualmente carregada."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly devido a um <xref:System.Reflection.AssemblyName>, usando a evidência especificada e os argumentos.</xref:System.Reflection.AssemblyName>"
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.      > [!NOTE] > Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>parâmetros, partes de evidência são mesclados.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituir partes de evidência fornecida pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Um <xref:System.Reflection.AssemblyName>objeto que representa o nome do assembly.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    - id: args
      type: System.String[]
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code> assemblyName </code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code>assemblySecurity</code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o assembly fornecido seu nome de exibição, usando a evidência especificada e os argumentos."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, mas Especifica o assembly por nome de exibição ou <xref:System.Reflection.AssemblyName>, em vez de local do arquivo.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Portanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblies com o <xref:System.Reflection.Assembly.Load%2A>método em vez de <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       O assembly de início da execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.      > [!NOTE] > Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>parâmetros, partes de evidência são mesclados.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituir partes de evidência fornecida pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    - id: args
      type: System.String[]
      description: "Argumentos de linha de comando para passar ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor retornado pelo ponto de entrada do assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O assembly especificado por <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "O assembly especificado por <code> assemblyName </code> foi encontrado, mas não pôde ser carregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "O assembly especificado por <code> assemblyName </code> não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code> assemblyName </code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code>assemblySecurity</code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "O assembly especificado não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando uma exceção é gerada no código gerenciado, antes do tempo de execução procura a pilha de chamadas para um manipulador de exceção no domínio do aplicativo."
  remarks: "Esse evento é apenas uma notificação. O evento não lidar com a exceção ou afetar de qualquer forma de tratamento de exceção subsequente. Depois que o evento foi gerado e manipuladores de eventos tiveram sido chamados, o common language runtime (CLR) começa a procurar por um manipulador para a exceção. FirstChanceException fornece o domínio de aplicativo com a primeira oportunidade de examinar qualquer exceção gerenciada.       O evento pode ser tratado por domínio de aplicativo. Se um thread passa por vários domínios de aplicativo durante a execução de uma chamada, o evento é gerado em cada domínio de aplicativo que registrou um manipulador de eventos, antes do CLR começa a procurar por um manipulador de exceção correspondente no domínio de aplicativo. Depois que o evento foi tratado, uma pesquisa é feita para um manipulador de exceção correspondente no domínio de aplicativo. Se nenhum for encontrado, o evento é gerado no próximo domínio de aplicativo.       Você deve tratar todas as exceções que ocorrem no manipulador para o evento FirstChanceException. Caso contrário, FirstChanceException será gerado recursivamente. Isso pode resultar em um estouro de pilha e o encerramento do aplicativo. É recomendável que você implemente os manipuladores de eventos para esse evento como regiões de execução restrita (CERs), para evitar exceções relacionadas à infraestrutura, como o estouro de pilha ou falta de memória que afetam a máquina virtual enquanto a notificação de exceção está sendo processada.       Esse evento não é gerado para exceções que indicam corrupção do estado do processo, como violações de acesso, a menos que o manipulador de eventos é crítico de segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       O common language runtime suspende anulações de thread enquanto este evento de notificação está sendo tratado."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o nome amigável deste domínio de aplicativo."
  remarks: "O nome amigável do domínio de aplicativo padrão é o nome do arquivo do processo do executável. Por exemplo, se o executável usado para iniciar o processo é `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, o nome amigável do domínio de aplicativo padrão é `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "O nome amigável deste domínio de aplicativo."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém os assemblies que foram carregados no contexto de execução desse domínio de aplicativo."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Uma matriz de assemblies neste domínio de aplicativo."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o identificador de thread atual."
  remarks: "Use o <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>propriedade, que é estável, mesmo quando o .NET Framework é hospedado por um ambiente que oferece suporte a fibras (ou seja, leve threads).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "Um inteiro assinado de 32 bits que é o identificador do thread atual."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o valor armazenado no domínio do aplicativo atual para o nome especificado."
  remarks: "Use esse método para recuperar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância do <xref:System.AppDomain>.</xref:System.AppDomain> Observe que a comparação de `name` com o nome de pares chave-valor diferencia maiusculas de minúsculas.       O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Você pode inspecionar os valores com o método GetData, ou equivalente <xref:System.AppDomainSetup>Propriedades.</xref:System.AppDomainSetup>       Você pode inserir ou modificar seus próprios pares de dados de nome definido pelo usuário com o <xref:System.AppDomain.SetData%2A>método e inspecionar os valores com o método GetData.</xref:System.AppDomain.SetData%2A>       A tabela a seguir descreve o `name` de cada entrada do sistema e correspondente predefinidos <xref:System.AppDomainSetup>propriedade.</xref:System.AppDomainSetup>      | Valor de &quot;name&quot; | Propriedade |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (nenhuma propriedade)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; representa a URL solicitada originalmente pelo usuário, antes de qualquer redirecionamento. Ele está disponível somente quando o aplicativo foi iniciado com um navegador como o Internet Explorer. Nem todos os navegadores fornecem esse valor. |   |&quot; APP_NAME &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (nenhuma propriedade) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;, ou uma cadeia de caracteres específica do aplicativo | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (nenhuma propriedade) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; não é uma entrada de sistema e seu valor pode ser definido chamando o método <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicativo predefinido, ou o nome de uma propriedade de domínio de aplicativo que você definiu."
    return:
      type: System.Object
      description: "O valor de <code> name </code> propriedade, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se a propriedade não existe."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tipo da instância atual."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "O tipo da instância atual."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor de inteiro que identifica exclusivamente o domínio de aplicativo dentro do processo."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Um inteiro que identifica o domínio de aplicativo."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornece o <xref href=&quot;System.AppDomain&quot;> </xref> um tempo de vida infinito, impedindo que uma concessão que está sendo criado."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor anulável booliano que indica se todos os comutadores compatibilidade são definidos e nesse caso, se a opção de compatibilidade especificada está definida."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "A opção de compatibilidade para testar."
    return:
      type: System.Nullable{System.Boolean}
      description: "Uma referência nula (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> no Visual Basic) se nenhuma opção de compatibilidade for definida; caso contrário, um valor booliano que indica se a compatibilidade do comutador que é especificado pelo <code> value </code> está definido."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retorna um valor que indica se o domínio de aplicativo é o domínio de aplicativo padrão para o processo."
  remarks: "Cada processo gerenciado tem um domínio de aplicativo padrão. Início da execução do domínio padrão."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o atual <xref href=&quot;System.AppDomain&quot;> </xref> objeto representa o domínio de aplicativo padrão para o processo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Indica se este domínio de aplicativo está descarregando e os objetos que ele contém finalizados pelo common language runtime."
  remarks: "O método de finalização de um objeto fornece a oportunidade de executar quaisquer operações de limpeza necessária antes que o objeto é coletado como lixo. Após a finalização, o objeto é acessível, mas em um estado inválido e, portanto, inutilizável. Eventualmente, a coleta de lixo é concluída e recupera o objeto.       Método de finalização de um objeto é chamado em uma das seguintes situações: durante a coleta de lixo, quando o common language runtime está sendo desligado, ou quando o domínio de aplicativo que contém o objeto é descarregado. O método IsFinalizingForUnload retorna `true` somente no último caso; ele não retorna `true` se finalização resulta da coleta de lixo de rotina ou do desligamento do CLR.      > [!NOTE] > Para determinar se a finalização é devido ao desligamento do CLR, use o <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>propriedade.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Ele retorna `true` se finalização é devido a um domínio de aplicativo que está sendo descarregado ou ao CLR que está sendo desligado.       Durante a execução em seu método de finalização durante descarregamento do domínio, você talvez queira acessar outro objeto que é referenciado por um campo estático e tem um método de finalização. No entanto, não é possível confiável porque o objeto acessado pode já ter foi finalizado.      > [!NOTE] > Uma exceção a essa regra é o <xref:System.Console>classe, que contém campos estáticos que fazem referência a objetos de fluxo, mas é implementada especialmente para você sempre pode gravar no console do sistema, mesmo durante o desligamento de descarregar ou sistema do domínio.</xref:System.Console>       Use esse método no método de finalização de um objeto para determinar se o domínio de aplicativo que contém o objeto está descarregando. Se esse for o caso, você não pode acessar com segurança qualquer objeto que tem um método de finalização e é referenciado por um campo estático."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esse domínio de aplicativo é descarregar e o common language runtime iniciou invocar finalizadores; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor que indica se os assemblies são carregados no domínio do aplicativo atual executar com confiança total."
  remarks: "Esse método sempre retorna `true` para o domínio de aplicativo padrão de um aplicativo que é executado na área de trabalho. Ele retorna `false` para um domínio de aplicativo na área restrita foi criado usando o [AppDomain.CreateDomain (cadeia de caracteres, evidência, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) sobrecarga do método, a menos que as permissões que são concedidas ao domínio do aplicativo são equivalentes a confiança total."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os assemblies são carregados no domínio do aplicativo atual executar com confiança total; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor que indica se o domínio de aplicativo atual tem um conjunto de permissões que é concedido a todos os assemblies que são carregados no domínio de aplicativo."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o domínio de aplicativo atual tiver um homogêneo conjunto de permissões; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega o <xref:System.Reflection.Assembly>com uma imagem comum do formato COFF com base em arquivo objeto contendo um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitido</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.       Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem baseada em COFF que contém um assembly emitido."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>rawAssembly</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>dado seu <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Se uma versão do assembly solicitado já está carregada, esse método retorna o assembly carregado, mesmo se for solicitada uma versão diferente.       Fornecendo um nome de assembly parcial para `assemblyRef` não é recomendado. (Um nome parcial omite um ou mais da cultura, versão ou token de chave pública. Para sobrecargas que têm uma cadeia de caracteres em vez de um <xref:System.Reflection.AssemblyName>objeto, &quot;MyAssembly, Version =&1;.0.0.0&quot; é um exemplo de um nome parcial e &quot;MyAssembly, Version =&1;.0.0.0, Culture = neutral, PublicKeyToken =&18;ab3442da84b47&quot; é um exemplo de um nome completo.)</xref:System.Reflection.AssemblyName> Usar nomes parciais tem um efeito negativo no desempenho. Além disso, um nome de assembly parcial pode carregar um assembly do cache de assembly global somente se houver uma cópia exata do assembly no diretório base do aplicativo (<xref:System.AppDomain.BaseDirectory%2A> ou <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Se o atual <xref:System.AppDomain>objeto representa o domínio de aplicativo `A`e o <xref:System.AppDomain.Load%2A>método é chamado de domínio de aplicativo `B`, o assembly é carregado em ambos os domínios de aplicativo.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Por exemplo, o código a seguir carrega `MyAssembly` no novo domínio de aplicativo `ChildDomain` e também no domínio de aplicativo onde o código é executado: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] o assembly é carregado em ambos os domínios porque <xref:System.Reflection.Assembly>não deriva de <xref:System.MarshalByRefObject>e, portanto, o valor de retorno de <xref:System.AppDomain.Load%2A>método não pode ser empacotado.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     Em vez disso, o common language runtime tenta carregar o assembly no domínio de aplicativo de chamada. Os assemblies que são carregados nos domínios do duas aplicativo podem ser diferentes se as configurações de caminho para os domínios de dois aplicativo são diferentes.      > [!NOTE] > Se o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>propriedade estiver definida, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>propriedade).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Se o arquivo não for encontrado, o <xref:System.Reflection.AssemblyName.CodeBase%2A>propriedade é usada para pesquisar o assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se a correspondência falhar, um <xref:System.IO.FileLoadException>é gerada.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Um objeto que descreve o assembly a ser carregado."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyRef</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>recebe seu nome de exibição.</xref:System.Reflection.Assembly>"
  remarks: "Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyString</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega o <xref:System.Reflection.Assembly>com uma imagem comum do formato COFF com base em arquivo objeto contendo um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitido</xref:System.Reflection.Assembly> Os bytes brutos que representa os símbolos para o <xref:System.Reflection.Assembly>também são carregados.</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.       Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem baseada em COFF que contém um assembly emitido."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que contém os bytes brutos que representa os símbolos para o assembly."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>rawAssembly</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>dado seu <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Um objeto que descreve o assembly a ser carregado."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyRef</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>recebe seu nome de exibição.</xref:System.Reflection.Assembly>"
  remarks: "Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "O nome para exibição do assembly. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>assemblyString</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega o <xref:System.Reflection.Assembly>com uma imagem comum do formato COFF com base em arquivo objeto contendo um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitido</xref:System.Reflection.Assembly> Os bytes brutos que representa os símbolos para o <xref:System.Reflection.Assembly>também são carregados.</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.       Esse método deve ser usado somente para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma conveniência para chamadores de interoperabilidade que não é possível chamar estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para obter informações que são comuns a todas as sobrecargas do método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem baseada em COFF que contém um assembly emitido."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que contém os bytes brutos que representa os símbolos para o assembly."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Evidência para carregar o assembly."
    return:
      type: System.Reflection.Assembly
      description: "O assembly carregado."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>não é um assembly válido.       - ou - versão 2.0 ou posterior do common language runtime está carregado no momento e <code>rawAssembly</code> foi compilado com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Um assembly ou módulo foi carregado duas vezes com dois evidências diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política de CAS legada não estiver habilitada, <code>securityEvidence</code> devem ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém ou define um valor que indica se a CPU e memória de monitoramento de domínios de aplicativo está habilitado para o processo atual. Depois que o monitoramento está habilitado para um processo, ele não pode ser desativado."
  remarks: "Isso `static` propriedade (`Shared` propriedade no Visual Basic) controla a CPU e memória de monitoramento de todos os domínios de aplicativo no processo.       Se você tentar definir essa propriedade como `false`, um <xref:System.ArgumentException>exceção for lançada, mesmo se o valor atual da propriedade é `false`.</xref:System.ArgumentException>       Depois que o monitoramento estiver habilitado, você pode usar o <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>Propriedades para monitorar o uso de CPU e memória de domínios de aplicativos individuais da instância.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o monitoramento estiver habilitado; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo atual tentativa de atribuir o valor <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para essa propriedade."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o número de bytes que sobreviveram a última coleta e que são conhecidos por serem referenciados pelo domínio do aplicativo atual."
  remarks: "As estatísticas são atualizadas com cada coleta de lixo. No entanto, eles não têm garantia sejam precisos somente após um completo, bloqueio de uma coleção. ou seja, uma coleção que inclui todas as gerações e que interrompe o aplicativo durante a coleta ocorre. Por exemplo, o <xref:System.GC.Collect?displayProperty=fullName>sobrecarga do método executa um completo, bloqueio de coleta.</xref:System.GC.Collect?displayProperty=fullName> (Coleção simultânea ocorre em segundo plano e não bloqueia o aplicativo.)"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "O número de bytes restantes."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o total de bytes que sobreviveram da última coleção para todos os domínios de aplicativo no processo."
  remarks: "Depois de um conjunto completo, bloqueio, esse número representará o número de bytes contido em tempo real em heaps gerenciados. Ele deve ser o próximo o número relatado pelo <xref:System.GC.GetTotalMemory%2A>método.</xref:System.GC.GetTotalMemory%2A> Depois de uma coleção efêmera, esse número representará o número de bytes que estão retidas ao vivo em gerações efêmeras."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "O número total de bytes restantes para o processo."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tamanho total, em bytes, de todas as alocações de memória que foram feitas pelo domínio do aplicativo desde que ele foi criado, sem subtrair a memória que foram coletada."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "O tamanho total de todas as alocações de memória."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tempo total do processador que foi usado por todos os threads em execução no domínio de aplicativo atual, desde o início."
  remarks: "O tempo total que é relatado para um domínio de aplicativo inclui o tempo gasto em cada thread no processo de execução no domínio de aplicativo.       Um thread que chamam o código não gerenciado ainda está associado com um domínio de aplicativo e o tempo do processador gasto na execução que de código não gerenciado é relatado para o domínio de aplicativo em que a chamada foi feita.       Quando um thread está bloqueado ou suspenso, ele não consome tempo do processador."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Tempo total do processador para o domínio de aplicativo atual."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o conjunto de permissões de um domínio de aplicativo na área restrita."
  remarks: "Domínios de aplicativo no modo seguro que foram criados usando o [AppDomain.CreateDomain (cadeia de caracteres, evidência, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) sobrecarga de método tem um homogêneo conjunto de permissões; isto é, o mesmo conjunto de permissões é concedido a todos os assemblies parcialmente confiáveis que são carregados no domínio do aplicativo. Opcionalmente, um domínio de aplicativo na área restrita tem uma lista de assemblies de nomes fortes que são isentos essa permissão definida e, em vez disso, é executado com confiança total."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões do domínio do aplicativo em modo seguro."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando o processo do pai do domínio de aplicativo padrão."
  remarks: "O <xref:System.EventHandler>para esse evento pode executar atividades de término, como fechar arquivos, liberação de armazenamento e assim por diante, antes do término do processo.</xref:System.EventHandler>       Começando com o .NET Framework versão 2.0, esse evento é gerado em cada domínio de aplicativo que registra um manipulador de eventos.      > [!NOTE] > O tempo de execução total de todos os manipuladores de eventos ProcessExit é limitado, assim como o tempo de execução total de todos os finalizadores é limitado no encerramento do processo. O padrão é dois segundos. Um host não gerenciado pode alterar esse tempo de execução chamando o [ICLRPolicyManager](~/add/includes/ajax-current-ext-md.md) método com o [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) valor de enumeração.       Nas versões do .NET Framework 1.0 e 1.1, esse evento é gerado apenas no domínio de aplicativo padrão e somente se um manipulador de eventos é registrado no domínio de aplicativo padrão.       Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um assembly falha no contexto exclusivo de reflexão."
  remarks: "No contexto exclusivo de reflexão, dependências não são resolvidas automaticamente. Eles devem ser pré-carregados ou retornados pelo manipulador para este evento. Esse evento é gerado quando um assembly tem uma dependência que já não foi carregada no contexto exclusivo de reflexão. A dependência ausente é especificada pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> O <xref:System.ResolveEventHandler>para esse evento deve retornar um assembly que satisfaz a dependência.</xref:System.ResolveEventHandler> O assembly que é retornado deve ser carregado no contexto exclusivo de reflexão.      > [!IMPORTANT] > Esse evento é gerado apenas para dependências ausentes do assembly que você está carregando no contexto de somente reflexão (por exemplo, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>método).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Ele não será gerado se o assembly que você está carregando não pode ser encontrado.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade retorna o assembly que pediu a carga de assembly não pôde ser resolvida.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Saber a identidade do solicitante assembly pode ser útil para identificar a versão correta da dependência, se houver mais de uma versão. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para esse evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade retorna o nome do assembly, antes da política é aplicada.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retorna os assemblies que tiverem sido carregados no contexto exclusivo de reflexão do domínio do aplicativo."
  remarks: "Esse método retorna os assemblies que tiverem sido carregados no contexto exclusivo de reflexão. Para obter os módulos que foram carregados para execução, use o <xref:System.AppDomain.GetAssemblies%2A>método.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Uma matriz de <xref:System.Reflection.Assembly>objetos que representam os assemblies carregados no contexto de somente reflexão do domínio do aplicativo.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Uma operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o caminho sob o diretório base onde o resolvedor de assembly deve investigação de assemblies privados."
  remarks: "Assemblies privados são implantados na mesma estrutura de diretório do aplicativo. Se o caminho especificado pela propriedade RelativeSearchPath não está sob <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, ele será ignorado.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Essa propriedade retorna o valor definido usando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "O caminho sob o diretório base onde o resolvedor de assembly deve investigar assemblies privados."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um recurso falha porque o recurso não é um recurso incorporado ou vinculado válido no assembly."
  remarks: "O <xref:System.ResolveEventHandler>para esse evento pode tentar localizar o assembly que contém o recurso e retornar o proprietário.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Esse evento não será gerado se a resolução falhar porque o arquivo não pode ser encontrado para um recurso vinculado válido. Ele é gerado se um fluxo de recurso de manifesto não pode ser encontrado, mas não será gerado se uma chave de recurso individual não pode ser encontrada.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade contém o assembly que o recurso solicitado.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o nível de política de segurança para esse domínio de aplicativo."
  remarks: "Chamar esse método antes de um assembly é carregado para o <xref:System.AppDomain>em ordem para a política de segurança para ter efeito.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "O nível de política de segurança."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "O nível de política de segurança já foi definido."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho de diretório especificado como o local onde os assemblies são feitas cópias de sombra."
  remarks: "O caminho do cache será ignorado se o <xref:System.AppDomainSetup.ApplicationName%2A>propriedade não está definida.</xref:System.AppDomainSetup.ApplicationName%2A> Consulte o <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>propriedade.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "O caminho totalmente qualificado para o local da cópia de sombra."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Atribui o valor especificado para a propriedade de domínio de aplicativo especificado."
  remarks: "Use esse método para inserir uma entrada ou modificar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância do <xref:System.AppDomain>.</xref:System.AppDomain>       O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Não é possível inserir ou modificar as entradas de sistema com esse método. Uma chamada de método que tenta modificar uma entrada de sistema não tem nenhum efeito; o método não lançará uma exceção. Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A>método, ou equivalente <xref:System.AppDomainSetup>propriedades descritas <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>       Você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar padrões de expressão regular pela fonte de &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; como o valor da `name` argumento e uma <xref:System.TimeSpan>valor que representa o intervalo de tempo limite como o valor da `data` argumento.</xref:System.TimeSpan> Você também pode inserir ou modificar seus próprios pares de dados de nome definido pelo usuário com esse método e inspecionar os valores com o <xref:System.AppDomain.GetData%2A>método.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicativo definidas pelo usuário para criar ou alterar."
    - id: data
      type: System.Object
      description: "O valor da propriedade."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Atribui o valor especificado para a propriedade de domínio de aplicativo especificado, com uma permissão especificada a demanda do chamador quando a propriedade é recuperada."
  remarks: "Use esse método para inserir ou modificar suas próprias entradas definidas pelo usuário em um cache interno de pares de nome/dados que descrevem as propriedades do domínio do aplicativo. Quando você insere uma entrada, você pode especificar uma demanda de permissão para impor quando a entrada é recuperada. Além disso, você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar padrões de expressão regular pela fonte de &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; como o valor da `name` argumento e uma <xref:System.TimeSpan>valor que representa o intervalo de tempo limite como o valor da `data` argumento.</xref:System.TimeSpan>       Você não pode usar esse método para atribuir uma exigência de segurança para uma cadeia de caracteres de propriedade definidos pelo sistema.       O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Não é possível inserir ou modificar as entradas de sistema com esse método. Uma chamada de método que tenta modificar uma entrada de sistema não tem nenhum efeito; o método não lançará uma exceção. Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A>método ou o equivalente <xref:System.AppDomainSetup>propriedades descritas na seção comentários para o <xref:System.AppDomain.GetData%2A>método.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicativo definidas pelo usuário para criar ou alterar."
    - id: data
      type: System.Object
      description: "O valor da propriedade."
    - id: permission
      type: System.Security.IPermission
      description: "A permissão a demanda do chamador quando a propriedade é recuperada."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Especifica uma cadeia de caracteres de propriedade definida pelo sistema e <code>permission</code> não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho de diretório especificado como o diretório base para subdiretórios onde os arquivos gerados dinamicamente são armazenados e acessados."
  remarks: "Esse método define o <xref:System.AppDomainSetup.DynamicBase%2A>propriedade interno <xref:System.AppDomainSetup>associado a esta instância.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "O caminho totalmente qualificado que é o diretório base para subpastas onde assemblies dinâmicos são armazenados."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Especifica como os objetos principal e identidade devem ser conectados a um thread se o thread de tentativas vincular a uma entidade de segurança durante a execução nesse domínio de aplicativo."
  remarks: "Definir esse valor só será eficaz se você defini-lo antes de usar o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>propriedade.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Por exemplo, se você definir <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>para uma determinada entidade (por exemplo, uma entidade de segurança genérica) e, em seguida, use o método SetPrincipalPolicy para definir o <xref:System.Security.Principal.PrincipalPolicy>para <xref:System.Security.Principal.PrincipalPolicy>, o principal atual permanecerá a entidade de segurança genérica.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Uma da <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> valores que especifica o tipo do objeto principal para anexar a threads."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ativa a cópia de sombra."
  remarks: "Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho de diretório especificado como o local da cópia de sombra de assemblies."
  remarks: "Por padrão, uma cópia de sombra inclui todos os assemblies localizados por meio de sondagem. O método SetShadowCopyPath restringe a cópia de sombra para os assemblies nos diretórios especificados pelo `path`.       O método SetShadowCopyPath não especificar diretórios adicionais a serem pesquisadas para assemblies. Assemblies a serem copiados de sombra já devem estar localizados no caminho de pesquisa, por exemplo, em <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> O método SetShadowCopyPath Especifica quais caminhos de pesquisa são qualificados para ser sombra copiado.       Esse método define o <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>propriedade interno <xref:System.AppDomainSetup>associado a esta instância.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Uma lista de nomes de diretórios, onde cada nome é separado por ponto e vírgula."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define o objeto principal padrão a ser anexado à threads caso eles tentem vincular a uma entidade de segurança durante a execução nesse domínio de aplicativo."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "O objeto principal para anexar a threads."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "A entidade de segurança do thread já foi definida."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as informações de configuração do domínio de aplicativo para esta instância."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "As informações de inicialização de domínio de aplicativo."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém uma indicação se o domínio de aplicativo é configurado para arquivos de cópia de sombra."
  remarks: "Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>e [cópia de sombra de Assemblies](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o domínio de aplicativo é configurado para arquivos de cópia de sombra; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação é tentada em um domínio de aplicativo descarregado."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Um conjunto de nomes é mapeado para um conjunto correspondente de identificadores de expedição."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a biblioteca MSDN."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reservado para uso futuro. Deve ser IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "No passado a matriz de nomes a serem mapeados."
    - id: cNames
      type: System.UInt32
      description: "Contagem dos nomes a serem mapeados."
    - id: lcid
      type: System.UInt32
      description: "O contexto de localidade no qual os nomes de interpretar."
    - id: rgDispId
      type: System.IntPtr
      description: "Matriz alocada pelo chamador que recebe as IDs correspondentes aos nomes."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Recupera as informações de tipo para um objeto, o que pode ser usada para obter as informações de tipo para uma interface."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a biblioteca MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "As informações de tipo para retornar."
    - id: lcid
      type: System.UInt32
      description: "O identificador de localidade para o tipo de informação."
    - id: ppTInfo
      type: System.IntPtr
      description: "Recebe um ponteiro para o objeto de informações do tipo solicitado."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Recupera o número de interfaces de informações de tipo que um objeto fornece (0 ou 1)."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a biblioteca MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornece acesso às propriedades e métodos expostos por um objeto."
  remarks: "Esse método é para acesso para classes gerenciadas do código não gerenciado e não deve ser chamado de código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a biblioteca MSDN."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifica o membro."
    - id: riid
      type: System.Guid
      description: "Reservado para uso futuro. Deve ser IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "O contexto de localidade na qual interpretar argumentos."
    - id: wFlags
      type: System.Int16
      description: "Sinalizadores que descrevem o contexto da chamada."
    - id: pDispParams
      type: System.IntPtr
      description: "Ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPIDs para argumentos nomeados e contas para o número de elementos nas matrizes."
    - id: pVarResult
      type: System.IntPtr
      description: "Ponteiro para o local onde o resultado a ser armazenado."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Ponteiro para uma estrutura que contém informações de exceção."
    - id: puArgErr
      type: System.IntPtr
      description: "O índice do primeiro argumento que tem um erro."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de associação tardia usando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém uma representação de cadeia de caracteres que inclui o nome amigável do domínio do aplicativo e as políticas de contexto."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia de caracteres formada pela concatenação de cadeia de caracteres literal &quot;nome:&quot;, o nome amigável do domínio do aplicativo e representações de cadeia de caracteres das políticas de contexto ou a cadeia de caracteres &quot;há políticas sem contexto.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "O domínio de aplicativo representado pelo atual <xref href=&quot;System.AppDomain&quot;> </xref> foi descarregado."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um tipo de falha."
  remarks: "O evento TypeResolve ocorre quando o common language runtime não é possível determinar o assembly que pode criar o tipo solicitado. Isso pode ocorrer se o tipo é definido em um assembly dinâmico, ou o tipo não está definido em um assembly dinâmico, mas o tempo de execução não sabe qual assembly o tipo é definido no. A segunda situação pode ocorrer quando <xref:System.Type.GetType%2A?displayProperty=fullName>é chamado com um nome de tipo que não está qualificado com o nome do assembly.</xref:System.Type.GetType%2A?displayProperty=fullName>       O <xref:System.ResolveEventHandler>para esse evento pode tentar localizar e criar o tipo.</xref:System.ResolveEventHandler>       No entanto, o evento TypeResolve não ocorrerá se o tempo de execução sabe que não é possível encontrar um tipo em determinados assemblies. Por exemplo, esse evento não ocorre se o tipo não é encontrado em um conjunto estático porque o tempo de execução sabe tipos não podem ser adicionados dinamicamente para assemblies estáticos.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade contém o assembly que o tipo solicitado.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando uma exceção não é capturada."
  remarks: "Esse evento fornece notificação de exceções não capturadas. Ele permite que o aplicativo registrar informações sobre a exceção antes do manipulador padrão do sistema relata a exceção para o usuário e encerra o aplicativo. Se houver informações suficientes sobre o estado do aplicativo, outras ações podem ser realizadas — como salvar dados de programa para recuperação posterior. Tenha cuidado, porque os dados de programa podem se tornar corrompidos quando são as exceções não tratadas.      > [!NOTE] > Nas versões do .NET Framework 1.0 e 1.1, opções de depuração e encerramento de aplicativos são relatados para o usuário antes desse evento é gerado, em vez de depois.       Esse evento pode ser tratado em qualquer domínio de aplicativo. No entanto, o evento não será necessariamente gerado no domínio do aplicativo onde ocorreu a exceção. Uma exceção é sem tratamento somente se a pilha inteira para o thread foi organizada sem encontrar um manipulador de exceção aplicável, portanto, é o primeiro lugar em que o evento pode ser gerado no domínio do aplicativo em que o thread foi originado.      > [!NOTE] > Versões no .NET Framework 1.0 e 1.1, esse evento ocorre somente para o domínio de aplicativo padrão que é criado pelo sistema quando um aplicativo é iniciado. Se um aplicativo cria domínios de aplicativo adicionais, especificar um delegado para esse evento nesses domínios de aplicativos não tem nenhum efeito.       Se o evento UnhandledException é tratado no domínio de aplicativo padrão, ele é gerado existe para qualquer exceção sem tratamento em qualquer thread, independentemente de qual domínio de aplicativo o thread foi iniciado no. Se o thread foi iniciado em um domínio de aplicativo que tem um manipulador de eventos para UnhandledException, o evento é gerado no domínio de aplicativo. Se o domínio de aplicativo não é o domínio de aplicativo padrão, e também há um manipulador de eventos no domínio de aplicativo padrão, o evento é gerado em ambos os domínios de aplicativo.       Por exemplo, suponha que um thread é iniciado no domínio de aplicativo &quot;IA1&quot;, chama um método no domínio de aplicativo &quot;AD2&quot; e a partir daí chama um método no domínio de aplicativo &quot;AD3&quot;, onde ele lança uma exceção. O primeiro domínio de aplicativo no qual o evento UnhandledException pode ser gerado é &quot;IA1&quot;. Se o domínio de aplicativo não é o domínio de aplicativo padrão, o evento também pode ser gerado no domínio de aplicativo padrão.      > [!NOTE] > O common language runtime suspende anulações de thread durante a execução de manipuladores de eventos para o evento UnhandledException.       Se o manipulador de eventos tem um <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>atributo com os sinalizadores apropriados, o manipulador de eventos é tratado como uma região de execução restrita.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], esse evento não é gerado para exceções que corromper o estado do processo, como o estouro de pilha ou violações de acesso, a menos que o manipulador de eventos é crítico de segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Nas versões do .NET Framework 1.0 e 1.1, uma exceção não tratada ocorre em um thread que não seja o thread principal do aplicativo é capturada pelo tempo de execução e, portanto, não faz com que o aplicativo seja finalizado. Assim, é possível que o evento UnhandledException a ser gerado sem encerramento do aplicativo. Iniciando com o .NET Framework versão 2.0, esta barreira de exceções sem tratamento em threads de filho foi removida, porque o efeito cumulativo de tais falhas silenciosas incluído degradação de desempenho, dados corrompidos e travamentos, que eram difíceis de depurar. Para obter mais informações, incluindo uma lista de casos em que não encerra o tempo de execução, consulte [exceções em Threads gerenciados](~/add/includes/ajax-current-ext-md.md).       Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é gerada.</xref:System.Security.SecurityException>       Para obter mais informações sobre a manipulação de eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md).      ## Outros eventos de exceções sem tratamento para determinado aplicativo modelos, o UnhandledException evento pode ser impedido por outros eventos se a exceção não tratada ocorrer no thread principal do aplicativo.       Em aplicativos que usam Windows Forms, exceções não tratadas na causa do thread principal do aplicativo a <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>evento ser gerado.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Se esse evento é lida, o comportamento padrão é que a exceção não tratada não encerra o aplicativo, embora o aplicativo for deixado em um estado desconhecido. Nesse caso, o evento UnhandledException não é gerado. Esse comportamento pode ser alterado usando o arquivo de configuração de aplicativo ou usando o <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>método para alterar o modo para <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>antes do <xref:System.Windows.Forms.Application.ThreadException>manipulador de eventos é ativo conectado</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Isso se aplica somente ao thread principal do aplicativo. O evento UnhandledException é gerado para exceções sem tratamento lançadas em outros threads.       A partir do Microsoft Visual Studio 2005, a estrutura de aplicativo do Visual Basic fornece outro evento de exceções sem tratamento no thread principal do aplicativo. Consulte o <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>evento.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Esse evento possui um objeto de argumentos de evento com o mesmo nome que o objeto de argumentos de evento usado pelo UnhandledException, mas com propriedades diferentes. Em particular, esse objeto de argumentos de evento tem um <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>propriedade que permite que o aplicativo continue em execução, ignorando a exceção não tratada (e sair do aplicativo em um estado desconhecido).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> Nesse caso, o evento UnhandledException não é gerado."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "A ser adicionado."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Descarrega o domínio de aplicativo especificado."
  remarks: "No .NET Framework versão 2.0 há um thread dedicado para o descarregamento de domínios de aplicativo. Isso melhora a confiabilidade, especialmente quando o .NET Framework está hospedado. Quando um thread chama Unload, o domínio de destino está marcado para descarregar. O thread dedicado tenta descarregar o domínio, e todos os threads no domínio serão anulados. Se um thread não cancelar, por exemplo, porque ele está executando o código não gerenciado, ou porque ele está sendo executado um `finally` bloco, em seguida, após um período de tempo um <xref:System.CannotUnloadAppDomainException>é lançada no thread que originalmente chamado Unload.</xref:System.CannotUnloadAppDomainException> Se o thread que não puderam ser anulado eventualmente termina, o domínio de destino não é descarregado. Portanto, no .NET Framework versão 2.0 `domain` não é garantido para descarregar, porque pode não ser possível encerrar threads em execução.      > [!NOTE] > Em alguns casos, chamar Unload faz com que um imediata <xref:System.CannotUnloadAppDomainException>, por exemplo se for chamado em um finalizador.</xref:System.CannotUnloadAppDomainException>       Os threads nos `domain` são encerradas usando o <xref:System.Threading.Thread.Abort%2A>método, que gera um <xref:System.Threading.ThreadAbortException>no thread.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Embora o thread deve encerrar imediatamente, ele poderá continuar em execução por um período imprevisível em um `finally` cláusula.      ## Versão compatibilidade no .NET Framework versão 1.0 e 1.1 se estiver executando o thread que chama Unload em `domain`, outro thread é iniciado para realizar a operação. Se `domain` não pode ser descarregado, um <xref:System.CannotUnloadAppDomainException>é lançada nesse thread, não no thread original que é chamado de descarregamento.</xref:System.CannotUnloadAppDomainException> No entanto, se o thread que chama Unload está em execução fora `domain`, thread recebe a exceção."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Um domínio de aplicativo ser descarregado."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>não pôde ser descarregado."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Ocorreu um erro durante o processo de descarregamento."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
