### YamlMime:ManagedReference
items:
- uid: System.IO.Log.ReservationCollection
  id: ReservationCollection
  children:
  - System.IO.Log.ReservationCollection.#ctor
  - System.IO.Log.ReservationCollection.Add(System.Int64)
  - System.IO.Log.ReservationCollection.Clear
  - System.IO.Log.ReservationCollection.Contains(System.Int64)
  - System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  - System.IO.Log.ReservationCollection.Count
  - System.IO.Log.ReservationCollection.Finalize
  - System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  - System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  - System.IO.Log.ReservationCollection.GetEnumerator
  - System.IO.Log.ReservationCollection.IsReadOnly
  - System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  - System.IO.Log.ReservationCollection.Remove(System.Int64)
  - System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  - System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  - System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  langs:
  - csharp
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
  type: Class
  summary: "Gerencia a coleção de reserva de espaço feitas em uma sequência de registro."
  remarks: "Essa classe representa um conjunto de áreas de reserva que são feitas em uma sequência de registro. Adicionar itens à coleção aloca reservas de novo. Remover itens da coleção libera as reservas.       Um aplicativo reserva espaço no log quando ele tem dados que deve ser gravado no log no futuro, mas não é possível gravá-la imediatamente. As reservas de fornecem uma garantia de que os dados podem ser gravados no log quando os dados estão disponíveis a serem gravados. Ao usar logs, aplicativos geralmente reservam um ou mais registros de log em uma área de controle. Você deve reservar registros antes da anexação.       As reservas de podem ser usadas para garantir que uma operação pode ser concluída antes dos dados são confirmados. Caso contrário, as alterações serão revertidas. Ele também pode ser usado para gravar uma &quot;ação de desfazer&quot; no log. Durante uma operação de reversão, um Gerenciador de recursos transacional (RM) deve ser capaz de recuperar seu estado, se o RM for interrompido durante a operação de reversão. Usando uma área de reserva, um RM pode reservar espaço em um log antes de ser usada.       O <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>método pode reservar espaço ou acrescentar dados, ou ambos, dependendo dos parâmetros que são especificados ao fazer a chamada.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Como o progresso do trabalho em uma transação, um aplicativo pode acrescentar as informações de desfazer e reservar espaço para registros de compensação. Durante uma operação de reversão, registros de compensação que são criados indicam que foi desfeito no disco. Os registros são adicionados usando o espaço que foi reservado anteriormente. Isso garante que um RM não é executado fora do espaço de log, que é uma condição fatal, ao executar uma operação de reversão. Se um log ficar cheio durante uma transação, um aplicativo pode com segurança reverter uma transação sem corromper os dados duráveis.       CLFS é um sistema de registro em log ARIES compatíveis, destinam-se para log write-ahead. No registro em log write-ahead, um aplicativo grava um registro de desfazer antes de executar a operação, reservando a quantidade de espaço necessário no log para gravar um registro de compensação, que pode ser usado durante a reversão. Posteriormente, o espaço reservado é usado quando o registro de compensação, na verdade, ser gravado.       Aplicativos podem reservar ou acessar espaço longo em um determinado momento (são operações mutuamente exclusivas). Após uma confirmação de registro é gravado no log, um aplicativo pode liberar as reservas para os registros de compensação. Esta ação pode ser feita chamando a <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>ou <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>método.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> </xref:System.IO.Log.ReservationCollection.FreeReservation%2A> Chamar o <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>método garante que a operação é atômica, ao chamar o <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>método não.</xref:System.IO.Log.ReservationCollection.FreeReservation%2A> </xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>       Quando você liberar registros, você deve liberar os mesmos registros que você reservou juntos em uma chamada anterior para o <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>método.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>      > [!NOTE] > Sua implementação de <xref:System.IO.Log.IRecordSequence>deve implementar a <xref:System.IO.Log.ReservationCollection.MakeReservation%2A>e <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>métodos para executar a alocação de reserva real e a desalocação.</xref:System.IO.Log.ReservationCollection.FreeReservation%2A> </xref:System.IO.Log.ReservationCollection.MakeReservation%2A> </xref:System.IO.Log.IRecordSequence> Além disso, sua implementação também deve chamar <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A>quando um registro é gravado em um espaço reservado.</xref:System.IO.Log.ReservationCollection.ReservationFreed%2A>"
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: 'public abstract class ReservationCollection : System.Collections.Generic.ICollection<long>, System.Collections.Generic.IEnumerable<long>'
  inheritance:
  - System.Object
  implements:
  - System.Collections.Generic.ICollection<System.Int64>
  - System.Collections.Generic.IEnumerable<System.Int64>
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.#ctor
  id: '#ctor'
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationCollection()
  nameWithType: ReservationCollection.ReservationCollection()
  fullName: System.IO.Log.ReservationCollection.ReservationCollection()
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> classe."
  syntax:
    content: protected ReservationCollection ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Add(System.Int64)
  id: Add(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Add(Int64)
  nameWithType: ReservationCollection.Add(Int64)
  fullName: System.IO.Log.ReservationCollection.Add(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Aloca uma reserva e o adiciona à coleção. Este método não pode ser herdado."
  remarks: ''
  example:
  - "The following example shows how to manually make a reservation. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public void Add (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho da reserva solicitado, em bytes."
  overload: System.IO.Log.ReservationCollection.Add*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>não está entre os números de base e última sequência dessa sequência."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>size</code>é inválido ou excede o tamanho máximo de reserva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Clear
  id: Clear
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Clear()
  nameWithType: ReservationCollection.Clear()
  fullName: System.IO.Log.ReservationCollection.Clear()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Libera todas as reservas na coleção. Este método não pode ser herdado."
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.Clear*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>size</code>é inválido ou excede o tamanho máximo de reserva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Contains(System.Int64)
  id: Contains(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Contains(Int64)
  nameWithType: ReservationCollection.Contains(Int64)
  fullName: System.IO.Log.ReservationCollection.Contains(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Determina se foi feita uma reserva do tamanho especificado. Este método não pode ser herdado."
  syntax:
    content: public bool Contains (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho a ser localizado na coleção."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se pelo menos uma reserva do tamanho especificado foi feita; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.Contains*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  id: CopyTo(System.Int64[],System.Int32)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: CopyTo(Int64[],Int32)
  nameWithType: ReservationCollection.CopyTo(Int64[],Int32)
  fullName: System.IO.Log.ReservationCollection.CopyTo(Int64[],Int32)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Copia toda a coleção para uma matriz unidimensional, começando no índice especificado da matriz de destino. Este método não pode ser herdado."
  syntax:
    content: public void CopyTo (long[] array, int arrayIndex);
    parameters:
    - id: array
      type: System.Int64[]
      description: "A matriz de destino da cópia."
    - id: arrayIndex
      type: System.Int32
      description: "O índice baseado em zero na matriz na qual a cópia é iniciada."
  overload: System.IO.Log.ReservationCollection.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>or <code>arrayIndex</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>é menor que zero, ou maior que ou igual ao comprimento da <code>array</code>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Não há espaço suficiente na matriz especificada para copiar os dados.       - ou - <code> array </code> não é uma matriz dimensional única, que é o único tipo com suporte para a ação solicitada."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Count
  id: Count
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Count
  nameWithType: ReservationCollection.Count
  fullName: System.IO.Log.ReservationCollection.Count
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de reservas da coleção."
  syntax:
    content: public int Count { get; }
    return:
      type: System.Int32
      description: "O número de reservas da coleção."
  overload: System.IO.Log.ReservationCollection.Count*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Finalize
  id: Finalize
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReservationCollection.Finalize()
  fullName: System.IO.Log.ReservationCollection.Finalize()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Permite que o <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> para liberar recursos antes de ele é destruído pelo coletor de lixo."
  syntax:
    content: ~ReservationCollection ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  id: FreeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: FreeReservation(Int64)
  nameWithType: ReservationCollection.FreeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.FreeReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, libera uma reserva do tamanho especificado."
  syntax:
    content: protected abstract void FreeReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho de reserva para liberar."
  overload: System.IO.Log.ReservationCollection.FreeReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  id: GetBestMatchingReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: GetBestMatchingReservation(Int64)
  nameWithType: ReservationCollection.GetBestMatchingReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.GetBestMatchingReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, obtém a melhor correspondência de reserva para um determinado tamanho."
  remarks: "Este método é chamado normalmente ao anexar um registro de espaço reservado para uma sequência de registro. Quando retorna, uma reserva de tamanho retornado foi removida da coleção. Se, por algum motivo, o espaço reservado não é realmente acessado, o <xref:System.IO.Log.ReservationCollection.ReservationMade%2A>método deve ser chamado para garantir que o <xref:System.IO.Log.ReservationCollection>representa com precisão a quantidade de espaço reservado na sequência de registro.</xref:System.IO.Log.ReservationCollection> </xref:System.IO.Log.ReservationCollection.ReservationMade%2A>"
  syntax:
    content: protected long GetBestMatchingReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho de reserva que deve ser ajustado."
    return:
      type: System.Int64
      description: "Uma reserva da coleção que é maior que ou igual ao tamanho especificado, ou -1 se tal reserva não existe."
  overload: System.IO.Log.ReservationCollection.GetBestMatchingReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.GetEnumerator
  id: GetEnumerator
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: ReservationCollection.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.GetEnumerator()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Retorna um enumerador que pode iterar por meio de <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Este método não pode ser herdado."
  syntax:
    content: public System.Collections.Generic.IEnumerator<long> GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerator{System.Int64}
      description: "Um enumerador que pode iterar por meio de <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.GetEnumerator*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida para um dos seguintes motivos:-a enumeração terminou.      -A coleção foi modificada.      -A enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>devem ser feitas.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.IsReadOnly
  id: IsReadOnly
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
  fullName: System.IO.Log.ReservationCollection.IsReadOnly
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém um valor que indica se a coleção é somente leitura."
  remarks: "Um <xref:System.IO.Log.ReservationCollection>nunca é somente leitura.</xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: public bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "Essa propriedade sempre retorna <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  id: MakeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: MakeReservation(Int64)
  nameWithType: ReservationCollection.MakeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.MakeReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, aloca uma reserva do tamanho especificado."
  syntax:
    content: protected abstract void MakeReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho de reserva para alocar."
  overload: System.IO.Log.ReservationCollection.MakeReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Remove(System.Int64)
  id: Remove(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Remove(Int64)
  nameWithType: ReservationCollection.Remove(Int64)
  fullName: System.IO.Log.ReservationCollection.Remove(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Libera uma reserva de tamanho especificado, se um tiver sido feito. Este método não pode ser herdado."
  remarks: ''
  example:
  - "The following example shows how to manually make a reservation. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public bool Remove (long item);
    parameters:
    - id: item
      type: System.Int64
      description: "O tamanho de reserva para liberar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se uma reserva do tamanho especificado foi encontrada e removida; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.Remove*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nenhuma reserva grande o suficiente para ajustar o registro fornecido pode ser encontrada na coleção de reserva especificada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorrerá um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registro está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  id: ReservationFreed(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationFreed(Int64)
  nameWithType: ReservationCollection.ReservationFreed(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationFreed(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, indica que uma reserva foi liberada."
  remarks: "Ao herdar de <xref:System.IO.Log.ReservationCollection>, você deve chamar este método quando uma reserva é lançada por um motivo diferente de removê-lo da coleção.</xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: protected void ReservationFreed (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho de reserva que foi liberado."
  overload: System.IO.Log.ReservationCollection.ReservationFreed*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  id: ReservationMade(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationMade(Int64)
  nameWithType: ReservationCollection.ReservationMade(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationMade(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituído em uma classe derivada, indica que foi feita uma reserva."
  remarks: "Ao herdar de <xref:System.IO.Log.ReservationCollection>, você deve chamar este método quando é feita uma reserva de fora de uma chamada para <xref:System.IO.Log.ReservationCollection.Add%2A>.</xref:System.IO.Log.ReservationCollection.Add%2A> </xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: protected void ReservationMade (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "O tamanho de reserva que foi feita."
  overload: System.IO.Log.ReservationCollection.ReservationMade*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Retorna um enumerador que pode iterar por meio de <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Este método não pode ser herdado."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "Um enumerador que pode iterar por meio de <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida para um dos seguintes motivos:-a enumeração terminou.      -A coleção foi modificada.      -A enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>devem ser feitas.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois que a sequência foi descartada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O acesso para o armazenamento de log especificado é negado pelo sistema operacional."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationCollection.#ctor
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationCollection()
  nameWithType: ReservationCollection.ReservationCollection()
  fullName: System.IO.Log.ReservationCollection.ReservationCollection()
- uid: System.IO.Log.ReservationCollection.Add(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Add(Int64)
  nameWithType: ReservationCollection.Add(Int64)
  fullName: System.IO.Log.ReservationCollection.Add(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.ReservationCollection.Clear
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Clear()
  nameWithType: ReservationCollection.Clear()
  fullName: System.IO.Log.ReservationCollection.Clear()
- uid: System.IO.Log.ReservationCollection.Contains(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Contains(Int64)
  nameWithType: ReservationCollection.Contains(Int64)
  fullName: System.IO.Log.ReservationCollection.Contains(Int64)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: CopyTo(Int64[],Int32)
  nameWithType: ReservationCollection.CopyTo(Int64[],Int32)
  fullName: System.IO.Log.ReservationCollection.CopyTo(Int64[],Int32)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.ReservationCollection.Count
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Count
  nameWithType: ReservationCollection.Count
  fullName: System.IO.Log.ReservationCollection.Count
- uid: System.IO.Log.ReservationCollection.Finalize
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Finalize()
  nameWithType: ReservationCollection.Finalize()
  fullName: System.IO.Log.ReservationCollection.Finalize()
- uid: System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: FreeReservation(Int64)
  nameWithType: ReservationCollection.FreeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.FreeReservation(Int64)
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetBestMatchingReservation(Int64)
  nameWithType: ReservationCollection.GetBestMatchingReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.GetBestMatchingReservation(Int64)
- uid: System.IO.Log.ReservationCollection.GetEnumerator
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetEnumerator()
  nameWithType: ReservationCollection.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.GetEnumerator()
- uid: System.Collections.Generic.IEnumerator{System.Int64}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerator<Int64>
  nameWithType: IEnumerator<Int64>
  fullName: System.Collections.Generic.IEnumerator<System.Int64>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    nameWithType: IEnumerator
    fullName: IEnumerator<System.Int64>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.ReservationCollection.IsReadOnly
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
  fullName: System.IO.Log.ReservationCollection.IsReadOnly
- uid: System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: MakeReservation(Int64)
  nameWithType: ReservationCollection.MakeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.MakeReservation(Int64)
- uid: System.IO.Log.ReservationCollection.Remove(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Remove(Int64)
  nameWithType: ReservationCollection.Remove(Int64)
  fullName: System.IO.Log.ReservationCollection.Remove(Int64)
- uid: System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationFreed(Int64)
  nameWithType: ReservationCollection.ReservationFreed(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationFreed(Int64)
- uid: System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationMade(Int64)
  nameWithType: ReservationCollection.ReservationMade(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationMade(Int64)
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.IO.Log.ReservationCollection.#ctor*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection.ReservationCollection
- uid: System.IO.Log.ReservationCollection.Add*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Add
  nameWithType: ReservationCollection.Add
- uid: System.IO.Log.ReservationCollection.Clear*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Clear
  nameWithType: ReservationCollection.Clear
- uid: System.IO.Log.ReservationCollection.Contains*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Contains
  nameWithType: ReservationCollection.Contains
- uid: System.IO.Log.ReservationCollection.CopyTo*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: CopyTo
  nameWithType: ReservationCollection.CopyTo
- uid: System.IO.Log.ReservationCollection.Count*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Count
  nameWithType: ReservationCollection.Count
- uid: System.IO.Log.ReservationCollection.Finalize*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Finalize
  nameWithType: ReservationCollection.Finalize
- uid: System.IO.Log.ReservationCollection.FreeReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: FreeReservation
  nameWithType: ReservationCollection.FreeReservation
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetBestMatchingReservation
  nameWithType: ReservationCollection.GetBestMatchingReservation
- uid: System.IO.Log.ReservationCollection.GetEnumerator*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetEnumerator
  nameWithType: ReservationCollection.GetEnumerator
- uid: System.IO.Log.ReservationCollection.IsReadOnly*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
- uid: System.IO.Log.ReservationCollection.MakeReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: MakeReservation
  nameWithType: ReservationCollection.MakeReservation
- uid: System.IO.Log.ReservationCollection.Remove*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Remove
  nameWithType: ReservationCollection.Remove
- uid: System.IO.Log.ReservationCollection.ReservationFreed*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationFreed
  nameWithType: ReservationCollection.ReservationFreed
- uid: System.IO.Log.ReservationCollection.ReservationMade*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationMade
  nameWithType: ReservationCollection.ReservationMade
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator
