### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Fornece um <xref:System.IO.Stream>para um arquivo, dando suporte a síncronas e assíncronas operações leitura e gravação.</xref:System.IO.Stream>       Para procurar o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é reduzida.</xref:System.IO.Stream.Close%2A>       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de arquivo para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é reduzida.</xref:System.IO.Stream.Close%2A>       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Um identificador de arquivo para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o modo de criação e o caminho especificado."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o fluxo foi fechado."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> de classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado e o tamanho do buffer."
  remarks: "`FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A> Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de arquivo para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Um <xref href=&quot;System.IO.FileAccess&quot;> </xref> constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> handle </code> parâmetro é um identificador inválido.       - ou - <code> handle </code> parâmetro é um identificador síncrono e assíncrona foi usado."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> bufferSize </code> parâmetro for negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado e <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> propriedade de instância."
  remarks: "O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se esse processo possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A>método também fechará a alça e contagem de identificadores do arquivo é reduzida.</xref:System.IO.Stream.Close%2A> O `FileStream` objeto tem o tamanho do buffer padrão de 4096 bytes.       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar métodos diferentes de `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Um identificador de arquivo para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de arquivo será de propriedade isso <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação e a permissão de leitura/gravação."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina como o arquivo pode ser acessado pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isso também determina os valores retornados pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um arquivo de disco.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado, o tamanho do buffer e o estado de síncrono ou assíncrono."
  remarks: "Definir o `isAsync` parâmetro `true` para abrir o identificador de arquivo de forma assíncrona. Quando o parâmetro for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o parâmetro não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A>método.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando o `isAsync` parâmetro é `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A> Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Identificador de um arquivo para o arquivo que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador foi aberto de forma assíncrona (isto é, em overlapped modo de e/s); Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> handle </code> parâmetro é um identificador inválido.       - ou - <code> handle </code> parâmetro é um identificador síncrono e assíncrona foi usado."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> bufferSize </code> parâmetro for negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> propriedade de instância e o tamanho do buffer."
  remarks: "O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A>método também fechará a alça.</xref:System.IO.Stream.Close%2A> Em particular, a contagem de identificadores do arquivo é reduzida. O `FileStream` objeto tem o tamanho de buffer especificado.       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A> Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Identificador de um arquivo para o arquivo que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de arquivo será de propriedade isso <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação de, a permissão de leitura/gravação e a permissão de compartilhamento."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina como o arquivo pode ser acessado pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isso também determina os valores retornados pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um arquivo de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está executando o Windows 98 ou Windows 98 Segunda edição e <code> share </code> é definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de arquivo especificado, com a permissão de leitura/gravação especificado, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância de propriedade, o tamanho do buffer e o estado síncrono ou assíncrono."
  remarks: "O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A>método também fechará a alça.</xref:System.IO.Stream.Close%2A> Em particular, a contagem de identificadores do arquivo é reduzida. O `FileStream` objeto tem o tamanho de buffer especificado.       `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A>antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.</xref:System.IO.FileStream.Flush%2A> Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.       `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e pode causar uma exceção seja lançada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Identificador de um arquivo para o arquivo que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de arquivo será de propriedade isso <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador foi aberto de forma assíncrona (isto é, em overlapped modo de e/s); Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>é menor que <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> ou maior que <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> ou <code>bufferSize</code> é menor ou igual a 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O identificador é inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como um erro de disco.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de arquivo está definido para acesso somente leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/gravação e compartilhamento de permissão e o tamanho do buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina como o arquivo pode ser acessado pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isso também determina os valores retornados pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um arquivo de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está executando o Windows 98 ou Windows 98 Segunda edição e <code> share </code> é definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/gravação e permissão de compartilhamento, tamanho e síncrono ou assíncrono de estado de buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina como o arquivo pode ser acessado pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isso também determina os valores retornados pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um arquivo de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: useAsync
      type: System.Boolean
      description: "Especifica se deseja usar e/s assíncrona ou e/s síncronas. No entanto, observe que o sistema operacional subjacente podem não dar suporte a e/s assíncrona, portanto, quando especificando <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, o identificador pode ser aberto sincronicamente, dependendo da plataforma. Quando aberto de forma assíncrona, o <> </> *> e <> </> *> métodos melhor executam em grandes leituras ou gravações, mas pode ser muito mais lentos para pequenas leituras ou gravações. Se o aplicativo é projetado para tirar proveito de e/s assíncrona, defina o `useAsync` parâmetro <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Usar e/s assíncrona corretamente pode acelerar aplicativos pelo quanto um fator de 10, mas usá-lo sem recriar o aplicativo para e/s assíncrona pode diminuir o desempenho ao máximo como um fator de 10."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está executando o Windows 98 ou Windows 98 Segunda edição e <code> share </code> é definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/gravação e outros FileStreams permissão, o acesso de compartilhamento pode ter o mesmo arquivo, o tamanho do buffer e outras opções de arquivo."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina como o arquivo pode ser acessado pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isso também determina os valores retornados pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um arquivo de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Um valor que especifica as opções adicionais de arquivo."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> é especificado para <code> options </code>, mas não há suporte para criptografia de arquivo na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome do arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, no modo de criação, direitos de acesso e permissões de compartilhamento, as opções de arquivo adicionais e tamanho do buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Uma constante que determina os direitos de acesso para usar ao criar regras de acesso e auditoria para o arquivo."
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Uma constante que especifica as opções adicionais de arquivo."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "O sistema operacional atual não é do Windows NT ou posterior."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> é especificado para <code> options </code>, mas não há suporte para criptografia de arquivo na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Especificado <code> path </code>, o nome de arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, direitos de acesso e compartilhamento de permissão, o tamanho do buffer, outras opções de arquivo, controle de acesso e auditoria de segurança."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o arquivo que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto encapsulará."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o arquivo."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Uma constante que determina os direitos de acesso para usar ao criar regras de acesso e auditoria para o arquivo."
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina como o arquivo será compartilhado por outros processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivo <xref:System.Int32>valor maior que 0, indicando que o tamanho do buffer.</xref:System.Int32> O tamanho do buffer padrão é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Uma constante que especifica as opções adicionais de arquivo."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Uma constante que determina o controle de acesso e segurança para o arquivo de auditoria."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia de caracteres vazia (&quot;&quot;), contém somente espaços em branco ou contém um ou mais caracteres inválidos.       - ou - <code>path</code> se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não de arquivo, como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. em um ambiente de não-NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O arquivo não for encontrado, por exemplo, quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o arquivo especificado por <code> path </code> não existe. O arquivo já deve existir em um desses modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, como especificando <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o arquivo especificado pelo <code> path </code> já existe, ocorreu.       - ou - o fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, como estando em uma unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> solicitada não é permitido pelo sistema operacional especificado <code> path </code>, por exemplo, quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o arquivo ou diretório está definido para acesso somente leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> é especificado para <code> options </code>, mas não há suporte para criptografia de arquivo na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Especificado <code> path </code>, o nome de arquivo ou ambos excederem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas baseadas em Windows, caminhos devem ter menos de 248 caracteres e nomes de arquivo devem ter menos de 260 caracteres."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "O sistema operacional atual não é do Windows NT ou posterior."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicia uma operação de leitura assíncrona. (Considere o uso de <xref:System.IO.FileStream.ReadAsync*>; consulte a seção comentários.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "No .NET Framework 4 e versões anteriores, você deve usar métodos como BeginRead e <xref:System.IO.FileStream.EndRead%2A>para implementar operações de arquivo assíncrono.</xref:System.IO.FileStream.EndRead%2A> Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar mais facilmente as operações de arquivo assíncrono.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>deve ser chamado apenas uma vez para cada chamada para BeginRead.</xref:System.IO.FileStream.EndRead%2A> Falha ao encerrar um processo de leitura antes do início da leitura outra pode causar comportamento indesejado como deadlock.       <xref:System.IO.FileStream>fornece dois modos diferentes de operação: e/s síncronas e e/s assíncrona.</xref:System.IO.FileStream> Enquanto um pode ser usado, os recursos do sistema operacional subjacente podem permitir acesso em apenas um desses modos. Por padrão, <xref:System.IO.FileStream>abre o identificador de sistema operacional de forma síncrona.</xref:System.IO.FileStream> No Windows, isso reduz a velocidade de métodos assíncronos. Se os métodos assíncronos são usados, use o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>construtor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > Use o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual oferece suporte à leitura.</xref:System.IO.FileStream.CanRead%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Se um fluxo está fechado ou se você passar um argumento inválido, exceções são geradas imediatamente de BeginRead. Erros que ocorrem durante uma solicitação de leitura assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrem no thread do pool e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>deve ser chamado com esse <xref:System.IAsyncResult>para descobrir o número de bytes foram lidas.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "O buffer para ler os dados."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `array` no qual começar a ler."
    - id: numBytes
      type: System.Int32
      description: "O número máximo de bytes a serem lidos."
    - id: userCallback
      type: System.AsyncCallback
      description: "O método a ser chamado quando a operação de leitura assíncrona é concluído."
    - id: stateObject
      type: System.Object
      description: "Um objeto definido pelo usuário que distingue esta solicitação de leitura assíncrona específica de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um objeto que faz referência a leitura assíncrona."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O comprimento da matriz menos <code> offset </code> é menor que <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>numBytes</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Uma leitura assíncrona foi tentada após o fim do arquivo."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicia uma operação de gravação assíncrona. (Considere o uso de <xref:System.IO.FileStream.WriteAsync*>; consulte a seção comentários.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "No .NET Framework 4 e versões anteriores, você deve usar métodos como BeginWrite e <xref:System.IO.FileStream.EndWrite%2A>para implementar operações de arquivo assíncrono.</xref:System.IO.FileStream.EndWrite%2A> Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar mais facilmente as operações de arquivo assíncrono.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>de BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>será bloqueado até que a operação de e/s foi concluída.</xref:System.IO.FileStream.EndWrite%2A>       Esse método substitui <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>fornece dois modos diferentes de operação: e/s síncronas e e/s assíncrona.</xref:System.IO.FileStream> Enquanto um pode ser usado, os recursos do sistema operacional subjacente podem permitir acesso em apenas um desses modos. Por padrão, <xref:System.IO.FileStream>abre o identificador de sistema operacional de forma síncrona.</xref:System.IO.FileStream> No Windows, isso reduz a velocidade de métodos assíncronos. Se os métodos assíncronos são usados, use o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>construtor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Se um fluxo está fechado ou se você passar um argumento inválido, exceções são geradas imediatamente de BeginWrite. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrem no thread do pool e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "O buffer que contém dados a serem gravados no fluxo atual."
    - id: offset
      type: System.Int32
      description: "O deslocamento de bytes baseado em zero em `array` no qual começar a copiar bytes para o fluxo atual."
    - id: numBytes
      type: System.Int32
      description: "O número máximo de bytes a serem gravados."
    - id: userCallback
      type: System.AsyncCallback
      description: "O método a ser chamado quando a operação de gravação assíncrona é concluída."
    - id: stateObject
      type: System.Object
      description: "Um objeto definido pelo usuário que distingue esta solicitação de gravação assíncrona específica de outras solicitações."
    return:
      type: System.IAsyncResult
      description: "Um objeto que faz referência a gravação assíncrona."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>comprimento menos <code>offset</code> é menor que <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>numBytes</code> é negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para gravação."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo atual oferece suporte à leitura."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não dá suporte para leitura, chamadas para o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>e os <xref:System.IO.FileStream.BeginRead%2A>métodos lançam <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, essa propriedade retornará `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo oferece suporte à leitura; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso somente gravação."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo atual oferece suporte à busca."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não dá suporte para busca, chamadas para <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>e <xref:System.IO.FileStream.Seek%2A>Lançar <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, essa propriedade retornará `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo oferece suporte à busca; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi construído a partir de um identificador de sistema operacional como uma barra vertical ou a saída para o console."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo atual oferece suporte à gravação."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não oferece suporte à gravação, uma chamada para <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, ou <xref:System.IO.FileStream.WriteByte%2A>lança <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, essa propriedade retornará `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo oferece suporte à gravação; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso somente leitura."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Libera os recursos não gerenciados usados pelo <xref href=&quot;System.IO.FileStream&quot;> </xref> e, opcionalmente, libera os recursos gerenciados."
  remarks: "Este método é chamado pelo público <xref:System.ComponentModel.Component.Dispose%2A>método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>invoca o método Dispose protegido com o `disposing` parâmetro definido como `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>chama Dispose com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.FileStream>referências.</xref:System.IO.FileStream> Este método chama o <xref:System.ComponentModel.Component.Dispose%2A>método de cada objeto referenciado.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para liberar recursos gerenciados e não gerenciados; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para liberar apenas recursos não gerenciados."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aguarda até que a operação de leitura assíncrona pendente concluir. (Considere o uso de <xref:System.IO.FileStream.ReadAsync*>; consulte a seção comentários.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginRead%2A>e EndRead para implementar operações de arquivo assíncrono.</xref:System.IO.FileStream.BeginRead%2A> Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar mais facilmente as operações de arquivo assíncrono.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       EndRead deve ser chamado exatamente para todas as chamadas para <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> Falha ao encerrar um processo de leitura antes do início da leitura outra pode causar comportamento indesejado como deadlock.       Esse método substitui <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       EndRead pode ser chamado em cada <xref:System.IAsyncResult>de <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> Chamar EndRead indica quantos bytes foram lidos no fluxo. EndRead será bloqueado até que a operação de e/s foi concluída."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "A referência para a solicitação assíncrona pendente para aguardar."
    return:
      type: System.Int32
      description: "O número de bytes lidos do fluxo, entre 0 e o número de bytes solicitado. Os fluxos somente retornam 0 no final do fluxo, caso contrário, eles devem ser bloqueados até que pelo menos 1 byte esteja disponível."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado por meio da chamada <xref:System.IO.FileStream.BeginRead*>desta classe.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead é chamado várias vezes."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo está fechado ou ocorreu um erro interno."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Termina uma operação de gravação assíncrona e bloqueia até que a operação de e/s é concluída. (Considere o uso de <xref:System.IO.FileStream.WriteAsync*>; consulte a seção comentários.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginWrite%2A>e EndWrite para implementar operações de arquivo assíncrono.</xref:System.IO.FileStream.BeginWrite%2A> Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar mais facilmente as operações de arquivo assíncrono.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Esse método substitui <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       EndWrite deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult>de <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> EndWrite será bloqueado até que a operação de e/s foi concluída."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "A solicitação de e/s assíncrona pendente."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado por meio da chamada <xref:System.IO.Stream.BeginWrite*>desta classe.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite for chamado várias vezes."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo está fechado ou ocorreu um erro interno."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Garante que os recursos são liberados e outras operações de limpeza são realizadas quando o coletor de lixo recupera o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "O coletor de lixo chama `Finalize` quando o objeto atual está pronto para ser finalizado. `Finalize`Fecha o `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa os buffers para esse fluxo e faz com que todos os dados armazenados em buffer a ser gravado no arquivo."
  remarks: "Esse método substitui <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Quando você chama o método de limpeza, o buffer de e/s de sistema de operacional também é liberado.       Codificador do fluxo não é liberado, a menos que explicitamente chamar liberação ou descartar o objeto. Definindo <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>para `true` significa que os dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> Isso permite que o codificador deve manter o estado (parcial caracteres) para que ele pode codificar o próximo bloco de caracteres corretamente. Este cenário afeta UTF8 e UTF7 onde determinados caracteres podem ser codificados somente depois que o codificador recebe adjacentes ou mais caracteres.       Como um buffer pode ser usado para leitura ou gravação, liberação executa duas funções a seguir: - todos os dados gravados anteriormente para o buffer são copiados para o arquivo e o buffer será limpo, exceto o estado do codificador.      -Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>é `true` e foi anteriormente copiados do arquivo de dados para o buffer de leitura, a posição atual dentro do arquivo é reduzida pelo número de bytes não lidos no buffer.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> O buffer, em seguida, será limpo.       Use o <xref:System.IO.FileStream.Flush%28System.Boolean%29>sobrecarga de método quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa os buffers para esse fluxo e faz com que todos os dados armazenados em buffer a ser gravado no arquivo e também limpa todos os buffers de arquivo intermediário."
  remarks: "Use essa sobrecarga quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.       Quando você chama o método de limpeza, o buffer de e/s de sistema de operacional também é liberado."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para limpar todos os buffers de arquivo intermediário; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa todos os buffers para esse fluxo assincronamente, faz com que todos os dados armazenados em buffer a ser gravado no dispositivo subjacente e monitora solicitações de cancelamento."
  remarks: "Quando você chama o método FlushAsync, o buffer de e/s de sistema de operacional também é liberado.       Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação assíncrona de liberação."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi descartado."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> objeto que encapsula as entradas de ACL (lista) de controle de acesso para o arquivo descrito pelo atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  remarks: "Enquanto o <xref:System.IO.FileStream>classe e GetAccessControl podem ser usado para recuperar as entradas de ACL (lista) de controle de acesso de um arquivo existente, considere o uso de <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>método, como ele é mais fácil usar.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Use o método GetAccessControl para recuperar as entradas ACL de um arquivo.       Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para obter mais informações, consulte [como: Adicionar ou remover entradas da lista de controle de acesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Um objeto que encapsula as configurações de controle de acesso para o arquivo descrito pelo atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O arquivo seja fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao abrir o arquivo."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "O arquivo não pôde ser encontrado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Não há suporte para esta operação na plataforma atual.       - ou - o chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o identificador de arquivo do sistema operacional para o arquivo atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> encapsula o objeto."
  remarks: "Esta propriedade é um identificador de sistema operacional para uso com chamadas do sistema operacional-fornecido pelo sistema (como `ReadFile` no Windows). Ele não funcionará com funções de biblioteca C que espera um descritor de arquivo, como `fread`.       O identificador de sistema operacional pode ter sido aberto forma síncrona ou assíncrona, dependendo de qual `FileStream` construtor foi chamado. Use o <xref:System.IO.FileStream.IsAsync%2A>propriedade para descobrir se esse identificador foi aberto de forma assíncrona.</xref:System.IO.FileStream.IsAsync%2A> No Win32, isso significa que o identificador foi aberto para e/s sobreposta e requer parâmetros diferentes para `ReadFile` e `WriteFile`.      > [!CAUTION] > Pode ocorrer corrupção de dados se um `FileStream` é criado, seu identificador é passado, alguma operação Move o ponteiro do arquivo do identificador e, em seguida, o `FileStream` é usado novamente. Vários threads com segurança não é possível gravar no mesmo arquivo simultaneamente, e `FileStream` buffer código pressupõe que ele controla exclusivamente o identificador. `FileStream`poderá gerar um <xref:System.IO.IOException>se `FileStream` detecta que algum outro processo passou o ponteiro do arquivo.</xref:System.IO.IOException> Para evitar isso, não grave os dados em uma parte do arquivo que `FileStream` pode ter em buffer e restaurar o ponteiro do arquivo para o local em que estava quando métodos foram chamados pela última vez em `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "O identificador de arquivo do sistema operacional para o arquivo encapsulado por este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto ou -1 se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi fechado."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi aberto de forma assíncrona ou síncrona."
  remarks: "O `IsAsync` propriedade detecta se o `FileStream` identificador foi aberto de forma assíncrona, permitindo que o seu código para usar o <xref:System.IO.FileStream.Handle%2A>propriedade corretamente.</xref:System.IO.FileStream.Handle%2A> No Win32, `IsAsync` sendo true significa que o identificador foi aberto para e/s sobreposta e, portanto, requer parâmetros diferentes para `ReadFile` e `WriteFile`.       Especifique esse valor quando você cria uma instância do <xref:System.IO.FileStream>classe usando um construtor que tenha uma `isAsync`, `useAsync`, ou `options` parâmetro.</xref:System.IO.FileStream> Quando a propriedade for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, a propriedade é assíncrono não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A>método.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando a propriedade é assíncrono for `false` e você chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi aberto de forma assíncrona; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o comprimento em bytes do fluxo."
  remarks: "Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Um valor longo que representa o comprimento do fluxo em bytes."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>para esse fluxo é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, como o arquivo que está sendo fechado."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Impede que outros processos de leitura ou gravação para o <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Bloqueio de um intervalo de um fluxo de arquivos oferece os threads do acesso exclusivo travamento do processo para o intervalo do fluxo de arquivo.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "O início do intervalo de bloqueio. O valor desse parâmetro deve ser igual ou maior que zero (0)."
    - id: length
      type: System.Int64
      description: "O intervalo a ser bloqueada."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>ou <code>length</code> é negativo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O arquivo seja fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O processo não pode acessar o arquivo porque outro processo bloqueou parte do arquivo."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o nome do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> que foi passado para o construtor."
  remarks: "Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Uma cadeia de caracteres que é o nome do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém ou define a posição atual deste fluxo."
  remarks: "Há suporte para busca em qualquer local além do comprimento do fluxo.  Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta.  No Microsoft Windows NT e mais recente, os dados adicionados ao final do arquivo são definidos como zero.  No Microsoft Windows 98 ou anterior, os dados adicionados ao final do arquivo não estão definidos como zero, o que significa que excluído anteriormente dados é visível para o fluxo. Definir a posição do fluxo para um valor grande além do fim do fluxo no Windows 98 ou anterior pode resultar em uma exceção seja gerada.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A posição atual deste fluxo."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para busca."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentativa de definir a posição de um valor negativo."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Tentativa de busca após o término de um fluxo que não oferece suporte a isso."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um bloco de bytes do fluxo e grava os dados em um buffer fornecido."
  remarks: "Esse método substitui <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de buffer) no qual começar a ler e o `count` parâmetro fornece o número máximo de bytes a ser lido do fluxo. O valor retornado é o número real de bytes lidos ou zero se o fim do fluxo for atingido. Se a operação de leitura for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.       O método de leitura retorna zero somente depois de atingir o final do fluxo. Caso contrário, o leitura sempre lê pelo menos um byte do fluxo antes de retornar. Se nenhum dado está disponível no fluxo após uma chamada para leitura, o método será bloqueado até que pelo menos um byte de dados pode ser retornado. Uma implementação está livre para retornar menos bytes que solicitado, mesmo que não foi atingido o fim do fluxo.       Use <xref:System.IO.BinaryReader>para ler tipos de dados primitivos.</xref:System.IO.BinaryReader>       Não interrompa um thread que está executando uma operação de leitura. Embora o aplicativo pode parecer com êxito depois que o thread está desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Quando este método retorna, contém a matriz de bytes especificada com os valores entre `offset` e (`offset`  +  `count` - 1`)` substituídos pelos bytes lidos da origem atual."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `array` no qual os bytes de leitura serão colocados."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem lidos."
    return:
      type: System.Int32
      description: "O número total de bytes lidos no buffer. Isso pode ser menor que o número de bytes solicitado se esse número de bytes não está disponível no momento ou zero se o fim do fluxo for atingido."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para leitura."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrevem um intervalo inválido no <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois que o fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê uma sequência de bytes do fluxo atual, de forma assíncrona avança a posição dentro do fluxo pelo número de bytes lidos e monitora solicitações de cancelamento."
  remarks: "O método ReadAsync permite que você realize operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.       Use o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual oferece suporte à leitura.</xref:System.IO.FileStream.CanRead%2A>       Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "O buffer para gravar os dados."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `buffer` no qual começar a gravar dados no fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem lidos."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operação de leitura de uma tarefa que representa o assíncrona. O valor de <code> TResult </code> parâmetro contém o número total de bytes lidos no buffer. O valor do resultado pode ser menor que o número de bytes solicitado se o número de bytes disponíveis atualmente é menor que o número solicitado, ou pode ser 0 (zero) se o fim do fluxo foi atingido."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento do buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi descartado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está atualmente em uso por uma operação de leitura anterior."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um byte do arquivo e avança o byte de uma posição de leitura."
  remarks: "Esse método substitui <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > Use o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual oferece suporte à leitura.</xref:System.IO.FileStream.CanRead%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "O byte é convertido em um <xref:System.Int32>, ou -1 se o fim do fluxo foi atingido.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo atual não dá suporte para leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo atual está fechado."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> objeto que representa o identificador de arquivo do sistema operacional para o arquivo que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> encapsula o objeto."
  remarks: "A propriedade SafeFileHandle automaticamente libera o fluxo e define a posição do fluxo atual como 0.  Isso permite que o arquivo a ser movido ou a posição de fluxo a ser redefinido por outro fluxo usando o SafeFileHandle retornado por essa propriedade."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um objeto que representa o identificador de arquivo do sistema operacional para o arquivo que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> encapsula o objeto."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define a posição atual deste fluxo como o valor especificado."
  remarks: "Esse método substitui <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > Use o <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>propriedade para determinar se a instância atual oferece suporte à busca.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       Você pode pesquisar em qualquer local além do comprimento do fluxo. Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta. No Windows NT e versões posteriores, os dados adicionados ao final do arquivo são definidos como zero. No Windows 98 ou versões anteriores, os dados adicionados ao final do arquivo não são definidos como zero, o que significa que excluído anteriormente dados é visível para o fluxo.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "O ponto relativo a `origin` no qual iniciar a busca."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Especifica o início, fim ou a posição atual como um ponto de referência para `offset`, usando um valor do tipo <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "A nova posição no fluxo."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para busca, como se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> é construído a partir de uma saída de pipe ou console."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Busca é tentada antes do início do fluxo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois que o fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aplica-se a entradas ACL (lista) de controle de acesso descritas por um <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> objeto para o arquivo descrito pelo atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  remarks: "Enquanto o <xref:System.IO.FileStream>classe e SetAccessControl pode ser usado em um arquivo existente, considere o uso de <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>método como ele é mais fácil usar.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       O método SetAccessControl se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.      > [!CAUTION] > A ACL especificado para o `fileSecurity` parâmetro substitui a ACL existente para o arquivo. Para adicionar permissões para um novo usuário, use o <xref:System.IO.FileStream.GetAccessControl%2A>método para obter a ACL existente, modificá-lo e, em seguida, use SetAccessControl para aplicá-lo de volta para o arquivo.</xref:System.IO.FileStream.GetAccessControl%2A>       Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para obter mais informações, consulte [como: Adicionar ou remover entradas da lista de controle de acesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Um objeto que descreve uma entrada ACL para aplicar ao arquivo atual."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O arquivo seja fechado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "O arquivo não foi encontrado ou modificado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O processo atual não tem acesso ao abrir o arquivo."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define o comprimento deste fluxo como o valor especificado."
  remarks: "Esse método substitui <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo é truncado. Nesse cenário, se a posição atual é maior do que o novo tamanho, a posição atual é movida para o último byte do fluxo. Se o valor especificado é maior que o tamanho atual do fluxo, o fluxo é expandido e a posição atual permanece o mesmo. Se o fluxo é expandido, o conteúdo do fluxo entre o antigo e o novo comprimento é indefinido.       Um fluxo deve dão suporte a gravação e busca de `SetLength` para trabalhar.      > [!NOTE] > Use o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual oferece suporte à gravação e o <xref:System.IO.FileStream.CanSeek%2A>propriedade para determinar se a busca é suportada.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>e <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "O novo tamanho do fluxo."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não oferece suporte tanto gravação e busca."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentativa de definir o <code> value </code> parâmetro para menor que 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Permite o acesso por outros processos para todo ou parte de um arquivo que foi bloqueado anteriormente."
  remarks: "Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "O início do intervalo para desbloquear."
    - id: length
      type: System.Int64
      description: "O intervalo a ser desbloqueada."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>ou <code>length</code> é negativo."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava um bloco de bytes para o fluxo de arquivos."
  remarks: "Esse método substitui <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de buffer) no qual começar a copiar e o `count` parâmetro retorna o número de bytes que serão gravados no fluxo. Se a operação de gravação for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes gravados. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.      > [!NOTE] > Use o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual oferece suporte à gravação.</xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Não interrompa um thread que está executando uma operação de gravação. Embora o aplicativo pode parecer com êxito depois que o thread está desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.       Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "O buffer que contém dados a serem gravados no fluxo."
    - id: offset
      type: System.Int32
      description: "O deslocamento de bytes de base zero no `array` da qual começar a copiar bytes para o fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem gravados."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrevem um intervalo inválido no <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A instância atual do fluxo não dá suporte para gravação."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro do fluxo pelo número de bytes gravados e monitora solicitações de cancelamento."
  remarks: "O método WriteAsync permite que você realize operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.       Use o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual oferece suporte à leitura.</xref:System.IO.FileStream.CanWrite%2A>       Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "O buffer para gravar dados."
    - id: offset
      type: System.Int32
      description: "O deslocamento de bytes de base zero no `buffer` da qual começar a copiar bytes para o fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a serem gravados."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorar solicitações de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação de gravação assíncrona."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento do buffer."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para gravação."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi descartado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está atualmente em uso por uma operação de gravação anterior."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Grava um byte para a posição atual no fluxo de arquivo."
  remarks: "Esse método substitui <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Use `WriteByte` para gravar um byte para um `FileStream` com eficiência. Se o fluxo está fechado ou não gravável, uma exceção será lançada.      > [!NOTE] > Use o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual oferece suporte à gravação.</xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Um byte para gravar no fluxo."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não dá suporte para gravação."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
