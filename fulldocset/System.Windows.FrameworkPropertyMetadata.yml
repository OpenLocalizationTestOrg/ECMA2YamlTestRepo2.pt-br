### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkPropertyMetadata
  id: FrameworkPropertyMetadata
  children:
  - System.Windows.FrameworkPropertyMetadata.#ctor
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  - System.Windows.FrameworkPropertyMetadata.AffectsArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsRender
  - System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  - System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  - System.Windows.FrameworkPropertyMetadata.Inherits
  - System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  - System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  - System.Windows.FrameworkPropertyMetadata.Journal
  - System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  - System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  - System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  - System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  langs:
  - csharp
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata
  fullName: System.Windows.FrameworkPropertyMetadata
  type: Class
  summary: "Relatórios ou aplica metadados para uma propriedade de dependência, especificamente, adicionando características do sistema de propriedade específica da estrutura."
  remarks: "Essa classe é derivada de <xref:System.Windows.PropertyMetadata>(por meio de <xref:System.Windows.UIPropertyMetadata>).</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.PropertyMetadata> Para fins de desenvolvimento de aplicativo de nível da estrutura de maioria dos WPF, FrameworkPropertyMetadata é o tipo usado para metadados de propriedade de dependência, em vez de tipos de base de metadados <xref:System.Windows.PropertyMetadata>ou <xref:System.Windows.UIPropertyMetadata>.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.PropertyMetadata> Isso é verdadeiro para as propriedades de dependência existente e na maioria dos cenários de propriedade de dependência personalizada.       Os membros declarados por esta classe esse suplemento a <xref:System.Windows.PropertyMetadata>classe base inclui várias propriedades Boolianas que especifique ou comportamento do sistema de propriedade de nível de framework WPF como herança de propriedade, associação de dados e layout de relatório.</xref:System.Windows.PropertyMetadata>       Várias assinaturas de construtor para criar uma instância de FrameworkPropertyMetadata levar um <xref:System.Windows.FrameworkPropertyMetadataOptions>parâmetro.</xref:System.Windows.FrameworkPropertyMetadataOptions> O <xref:System.Windows.FrameworkPropertyMetadataOptions>enumeração é usada somente para especificar o comportamento inicial no construtor e não é exposta caso contrário, depois FrameworkPropertyMetadata é construído.</xref:System.Windows.FrameworkPropertyMetadataOptions> Em uma instância criada, você pode obter ou definir as informações correspondentes por meio de várias propriedades que compartilham o nome dos valores de enumeração usado na chamada de construtor.      <a name=&quot;xamlTextUsage_FrameworkPropertyMetadata&quot;></a># # Uso de texto XAML essa classe não é usada normalmente em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type. That metadata is cast to FrameworkPropertyMetadata. If the cast returned a valid FrameworkPropertyMetadata, then various FrameworkPropertyMetadata property values are reported through a simple UI (not shown).  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: 'public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata'
  inheritance:
  - System.Object
  - System.Windows.PropertyMetadata
  - System.Windows.UIPropertyMetadata
  implements: []
  inheritedMembers:
  - System.Windows.PropertyMetadata.CoerceValueCallback
  - System.Windows.PropertyMetadata.DefaultValue
  - System.Windows.PropertyMetadata.IsSealed
  - System.Windows.PropertyMetadata.PropertyChangedCallback
  - System.Windows.UIPropertyMetadata.IsAnimationProhibited
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe."
  remarks: "Esta assinatura inicializa todos os valores de FrameworkPropertyMetadata aos seus padrões de propriedade. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>será `null`e os diversos <xref:System.Windows.FrameworkPropertyMetadata>Propriedades Boolianas serão `false`.</xref:System.Windows.FrameworkPropertyMetadata></xref:System.Windows.PropertyMetadata.DefaultValue%2A>"
  syntax:
    content: public FrameworkPropertyMetadata ();
    parameters: []
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor padrão especificado."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> retorno de chamada."
  remarks: ''
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1paramcallback](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1paramcallback)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de nível de estrutura de metadados e o valor padrão fornecido."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcados como definir sinalizadores no `flags` parâmetro definirá o valor booliano de <xref:System.Windows.FrameworkPropertyMetadata>propriedades que correspondem que <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Posteriormente, você pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Essas opções especificam características da propriedade de dependência que interagem com sistemas como o layout ou a associação de dados."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor padrão fornecido e especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> retorno de chamada."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor2param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor2param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com os retornos de chamada especificados."
  remarks: "Essa implementação chama um inicializador de base e, em seguida, adiciona o `coerceValueCallback` , definindo a propriedade na instância de base."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação do manipulador ser chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>para essa propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de metadados de estrutura e o valor padrão fornecido e especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> retorno de chamada."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcados como definir sinalizadores no `flags` parâmetro definirá o valor booliano de <xref:System.Windows.FrameworkPropertyMetadata>propriedades que correspondem que <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um valor de um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Essas opções especificam características da propriedade de dependência que interagem com sistemas como o layout ou a associação de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor padrão fornecido e retornos de chamada especificados."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor3param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor3param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um tipo específico."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação do manipulador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>para essa propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor padrão fornecido e opções de metadados da estrutura e retornos de chamada especificados."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcados como definir sinalizadores no `flags` parâmetro definirá o valor booliano de <xref:System.Windows.FrameworkPropertyMetadata>propriedades que correspondem que <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Essas opções especificam características da propriedade de dependência que interagem com sistemas como o layout ou a associação de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação do manipulador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>em relação a essa propriedade.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de metadados de estrutura e o valor padrão fornecido, retornos de chamada especificados e um valor booleano que pode ser usado para impedir que a animação da propriedade."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       O `isAnimationProhibited` parâmetro define o valor inicial para a <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>propriedade declarada por base imediata <xref:System.Windows.UIPropertyMetadata>classe.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>       Valores marcados como definir sinalizadores no `flags` parâmetro definirá o valor booliano de <xref:System.Windows.FrameworkPropertyMetadata>propriedades que correspondem que <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Essas opções especificam características da propriedade de dependência que interagem com sistemas como o layout ou a associação de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação do manipulador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>com essa propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para impedir que o sistema de propriedade animar a propriedade de metadados é aplicado ao. Essas propriedades gerará uma exceção de tempo de execução de origem do sistema de propriedade se a tentaram de animações deles. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>para permitir que a propriedade de animação. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> opções de classe com os metadados de estrutura e o valor padrão fornecido, retornos de chamada especificados, um valor booleano que pode ser usado para impedir que a animação da propriedade e um padrão de gatilho de atualização de associação de dados."
  remarks: "O tipo do valor fornecido para `defaultValue` devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       O `isAnimationProhibited` parâmetro define o valor inicial para a <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>propriedade declarada por base imediata <xref:System.Windows.UIPropertyMetadata>classe.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>       Para obter mais informações sobre o comportamento de origem de atualização para associações, consulte [visão geral de associação de dados](~/add/includes/ajax-current-ext-md.md).       Valores marcados como definir sinalizadores no `flags` parâmetro definirá o valor booliano de <xref:System.Windows.FrameworkPropertyMetadata>propriedades que correspondem que <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica."
  example:
  - "[!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor padrão da propriedade de dependência, geralmente é fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Essas opções especificam características da propriedade de dependência que interagem com sistemas como o layout ou a associação de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação do manipulador que o sistema de propriedade chamará sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação do manipulador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>em relação a essa propriedade.</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para impedir que o sistema de propriedade animar a propriedade de metadados é aplicado ao. Essas propriedades gerará uma exceção de tempo de execução de origem do sistema de propriedade se a tentaram de animações deles. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: defaultUpdateSourceTrigger
      type: System.Windows.Data.UpdateSourceTrigger
      description: "O <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> para usar quando associações para essa propriedade são aplicadas com seus <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> definida como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>é definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; consulte comentários."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  id: AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organizar durante as operações de mecanismo de layout."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor efetivo e tem metadados com AffectsArrange definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento (uma chamada para <xref:System.Windows.UIElement.InvalidateArrange%2A>).</xref:System.Windows.UIElement.InvalidateArrange%2A> Porque essa implementação de nível de framework WPF já está em vigor, você normalmente não precisa pesquisar para propriedades de dependência com AffectsArrange, a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.       Personalizar <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde AffectsArrange `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsArrange&quot;></a># # XAML texto uso membros dessa classe ou não são geralmente usados em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a etapa de organização; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  id: AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medição durante as operações de mecanismo de layout."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor efetivo e tem metadados com AffectsMeasure definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento. Porque essa implementação de nível de framework WPF já está em vigor, você normalmente não precisa pesquisar para propriedades de dependência com AffectsMeasure, a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.       Personalizar <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde AffectsMeasure `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsMeasure&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a passagem de medida; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  id: AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a etapa de organização do layout do seu elemento pai durante as operações de mecanismo de layout."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor efetivo e tem metadados com AffectsParentArrange definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.       Em geral, você não precisa alterações de relatório de um <xref:System.Windows.FrameworkElement>propriedade para um elemento pai usando AffectsParentArrange porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>como `true`.</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement> É geralmente suficiente, como as alterações no elemento filho geralmente iniciam um pai organizar quando apropriado. AffectsParentArrange às vezes é usado para <xref:System.Windows.FrameworkContentElement>derivado da classe.</xref:System.Windows.FrameworkContentElement> Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement>classe derivada não controla seu próprio processamento.</xref:System.Windows.FrameworkContentElement> O processamento é tratado por um <xref:System.Windows.FrameworkElement>elemento pai que serve como o host de conteúdo.</xref:System.Windows.FrameworkElement> Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>propriedade anexada por um elemento filho invalida organizar do pai, porque a posição do filho no pai deve ser alterada.</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> Portanto, o <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>propriedade anexada tem metadados onde AffectsParentArrange é `true`.</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> Outro exemplo é <xref:System.Windows.Controls.Control.Padding%2A>; quando alterações de propriedade, o pai pode alterar o posicionamento do filho, dependendo do espaço disponível.</xref:System.Windows.Controls.Control.Padding%2A>       Porque essa implementação de nível de framework WPF já está em vigor, você normalmente não precisa pesquisar para propriedades de dependência com AffectsParentArrange, a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.       Personalizar <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde AffectsParentArrange `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentArrange&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool AffectsParentArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a passagem de organizar especificamente em seu elemento pai. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  id: AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medida de layout de seu elemento pai durante as operações de mecanismo de layout."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor efetivo e tem metadados com AffectsParentMeasure definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai. Porque essa implementação de nível de framework WPF já está em vigor, você normalmente não precisa pesquisar para propriedades de dependência com AffectsParentMeasure, a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.       Em geral, você não precisa alterações de relatório de um <xref:System.Windows.FrameworkElement>propriedade para um elemento pai usando AffectsParentMeasure porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>como `true`.</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement> Que é geralmente suficiente, como as alterações no elemento filho geralmente iniciam uma passagem de medidas pai quando apropriado. AffectsParentMeasure às vezes é usado para <xref:System.Windows.FrameworkContentElement>derivado da classe.</xref:System.Windows.FrameworkContentElement> Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement>classe derivada não controla seu próprio processamento.</xref:System.Windows.FrameworkContentElement> O processamento é tratado por um <xref:System.Windows.FrameworkElement>elemento pai que serve como o host de conteúdo.</xref:System.Windows.FrameworkElement> Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>propriedade por um elemento filho invalida a medida do pai, pois o espaçamento relativo dos parágrafos pode alterar e pode aumentar ou diminuir o tamanho do host de conteúdo.</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName> Portanto, o <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>propriedade tem metadados onde AffectsParentMeasure é `true`.</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>       Elementos de host de conteúdo frequentemente procure alterações nas propriedades de dependência onde AffectsParentMeasure é `true`, como parte da lógica de processamento do host de conteúdo. Por exemplo, o <xref:System.Windows.Controls.TextBox>elemento deve responder a determinadas alterações em texto que podem exigir que a caixa delimitadora do <xref:System.Windows.Controls.TextBox>próprio ser alterado.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.TextBox>       Personalizar <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde AffectsParentMeasure `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentMeasure&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool AffectsParentMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a passagem de medição especificamente em seu elemento pai. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  id: AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência pode afeta o layout geral de tal forma que não influenciam especificamente organização ou medida, mas requer uma atualização."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor efetivo e tem metadados com AffectsRender definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento. Porque essa implementação de nível de framework WPF já está em vigor, você normalmente não precisa pesquisar para propriedades de dependência com AffectsRender, a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.       Personalizar <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde AffectsRender `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsRender&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem afeta o processamento; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  id: BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a propriedade associa bidirecionais por padrão."
  remarks: "Na ausência dessa propriedade está sendo `true`, as atualizações de vinculação são unidirecionais por padrão, com base no comportamento padrão do <xref:System.Windows.Data.Binding>construtores ou equivalente [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sintaxe.</xref:System.Windows.Data.Binding>       Elementos existentes, você encontrará esta propriedade definida como `true` nos metadados de propriedade de dependência que estado de relatório e podem ser modificadas por ação do usuário, por exemplo <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>.</xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>       Essa propriedade só reporta as características de atualização de associação padrão da propriedade de dependência em geral. Nenhuma associação de conjunto para essa propriedade em uma instância local pode definir o <xref:System.Windows.Data.Binding.Mode%2A>propriedade da associação e alterar esse padrão.</xref:System.Windows.Data.Binding.Mode%2A>       Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_BindsTwoWayByDefault&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool BindsTwoWayByDefault { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência na qual esses metadados existem associa bidirecionais por padrão. Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  id: DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o padrão para <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> para usar ao associações para a propriedade com esses metadados são aplicadas, que têm suas <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> definida como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  remarks: "Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_DefaultUpdateSourceTrigger&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }
    return:
      type: System.Windows.Data.UpdateSourceTrigger
      description: "Um valor de enumeração, que não seja <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Essa propriedade é definida como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>; o valor definido deve para se tornar o padrão quando solicitado por associações."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  id: Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se o valor da propriedade de dependência é herdável."
  remarks: "Herança de valor de propriedade é um recurso do [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema de propriedade no nível de framework do WPF, na qual determinadas propriedades de dependência podem ser definidas localmente em um elemento ou próximo a raiz de um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elemento árvore e, em seguida, tem seu valor herdado por todos os elementos dentro da árvore lógica de elementos filho que também possuem essa propriedade. Herança de valor de propriedade não está habilitada por padrão, e permitindo que ele tem algumas implicações de desempenho. Para obter detalhes, consulte [herança de valor de propriedade](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Embora a herança de valor de propriedade pode parecer funcionar para as propriedades de dependência, o comportamento de herança de uma propriedade não anexada por certos divisões de objeto do objeto na árvore de tempo de execução é indefinido. Sempre use <xref:System.Windows.DependencyProperty.RegisterAttached%2A>para registrar as propriedades em que você especificar Inherits nos metadados.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Inherits&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool Inherits { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor da propriedade é herdável; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.Inherits*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  id: IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se a associação de dados tem suporte para a propriedade de dependência."
  remarks: "Essa propriedade reporta `false` para uma das duas condições possíveis: a associação de dados para uma propriedade de dependência não é permitida porque a propriedade de dependência é somente leitura (como relatado no identificador de propriedade de dependência, não os metadados), ou o valor de outra propriedade de metadados, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, é definido como `true` no metadados.</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> Essa propriedade é exposta como uma conveniência para que os chamadores não precisam verificar os dois <xref:System.Windows.DependencyProperty.ReadOnly%2A>e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.DependencyProperty.ReadOnly%2A>       Se você estiver tentando criar os metadados que especifica que uma propriedade de leitura/gravação deve não oferecem suporte à associação de dados, especifique o sinalizador <xref:System.Windows.FrameworkPropertyMetadataOptions>(Observe a diferença de convenção de nomenclatura pequena versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.FrameworkPropertyMetadataOptions>      <a name=&quot;xamlTextUsage_IsDataBindingAllowed&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool IsDataBindingAllowed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a associação de dados é suportada na propriedade de dependência ao qual se aplica a esses metadados; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  id: IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a propriedade de dependência dá suporte à associação de dados."
  remarks: "Observe que essa propriedade de metadados é definida como `true` especificamente para propriedades que não devem dar suporte a associação de dados, apesar de ser propriedades de leitura-gravação. A expectativa é que na maioria dos casos em que uma propriedade de dependência é declarada, associação de dados é desejada, como associação de dados é um dos principais cenários em que uma propriedade de dependência é útil. Ao contrário de <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, isso não altera simplesmente um padrão que pode ser alterado posteriormente em uma associação específica.</xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A> A definição dessa propriedade `true` nos metadados para uma propriedade de dependência metadados desabilitará todas as associações da aplicação de seus valores por meio de expressões de propriedade de dependência.       Propriedades de dependência somente leitura não dão suporte à associação de dados (porque eles têm nenhum setter que pode aplicar valores alterados), mas ainda será relatório `false` para IsNotDataBindable. Isso ocorre porque as propriedades que correspondem a um <xref:System.Windows.FrameworkPropertyMetadataOptions>valores relatará paridade com como os metadados foi realmente estabelecido, em vez de relatórios sempre o comportamento do resultado final o nome da propriedade implicar.</xref:System.Windows.FrameworkPropertyMetadataOptions> Para determinar se uma propriedade de dependência permite associação de dados, você normalmente deve verificar <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>em vez disso.</xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>é uma conveniência para a verificação de ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A>e IsNotDataBindable como uma única operação, produzindo o resultado esperado.</xref:System.Windows.DependencyProperty.ReadOnly%2A></xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_IsNotDataBindable&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool IsNotDataBindable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade não dá suporte à associação de dados; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  id: Journal
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se esta propriedade contém informações de registro em log que aplicativos pode ou devem armazenar como parte de uma implementação do registro em log."
  remarks: "Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Journal&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool Journal { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o diário deve ser executado na propriedade de dependência que esses metadados é aplicado a; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.Journal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  id: Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Permite que uma mesclagem de uma fonte de metadados com metadados de base."
  remarks: "Esse método é usado internamente quando metadados estão sendo substituído."
  syntax:
    content: protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);
    parameters:
    - id: baseMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados de base para mesclagem."
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade de dependência que esses metadados está sendo aplicado."
  overload: System.Windows.FrameworkPropertyMetadata.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  id: OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Chamado quando esses metadados foi aplicado a uma propriedade, que indica se os metadados está sendo lacrado."
  remarks: "Qualquer Mutabilidade da estrutura de dados de um <xref:System.Windows.FrameworkPropertyMetadata>instância deve ser marcada como imutável quando esse método é chamado.</xref:System.Windows.FrameworkPropertyMetadata>"
  syntax:
    content: protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade de dependência para a qual os metadados foi aplicado."
    - id: targetType
      type: System.Type
      description: "O tipo associado com esses metadados quando se trata de um tipo específico metadados. Quando se trata de metadados padrão, esse valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.OnApply*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  id: OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a avaliação de herança de valor de propriedade deve abranger certos limites conteúdo na árvore lógica de elementos."
  remarks: "Esses metadados informa uma modificação raramente aplicado ao comportamento de herança de valor de propriedade nos limites do elemento filho do elemento pai especial. O exemplo canônico de tal um limite é o conteúdo de um <xref:System.Windows.Controls.Frame>, onde o <xref:System.Windows.Controls.Frame>conteúdo pode obter recarregado independentemente da existência de <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Controls.Frame> </xref:System.Windows.Controls.Frame> O comportamento do sistema de propriedade desejada é que herança de valor de propriedade não deve percorrer o conteúdo do <xref:System.Windows.Controls.Frame>, pois esses conteúdos podem ser elementos que o aplicativo que hospeda o quadro não possui ou controla.</xref:System.Windows.Controls.Frame> Especificar metadados com OverridesInheritanceBehavior definido como `true`, bem como especificando <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>como `true`, fará com que a propriedade na qual os metadados é aplicado para ser herdável mesmo no <xref:System.Windows.Controls.Frame>limite ou limites semelhantes.</xref:System.Windows.Controls.Frame> </xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_OverridesInheritanceBehavior&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool OverridesInheritanceBehavior { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a herança de valor de propriedade deve abranger em determinados limites de conteúdo; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  id: SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se as subpropriedades da propriedade de dependência não afetam o processamento do objeto contentor."
  remarks: "Essa opção de metadados é pertinente para propriedades de dependência que são tipos de referência, em que esse tipo tem valores de propriedade de seu próprio. Normalmente, a lógica do sistema de layout é supõem que qualquer propriedade de dependência com subpropriedades potencialmente afetará layout, porque a verificação de todas as subpropriedades de alterações é mais demorado do que realmente em execução outro renderizar passagem. Definir essa opção como `true` é útil para otimizar o desempenho da implementação de sistema de layout de nível de framework WPF.       Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata>geralmente são definidas no modelo de objeto como leitura-gravação.</xref:System.Windows.PropertyMetadata> Isso é possível ajustá-los após a inicialização da instância. No entanto, quando os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nesses metadados instância gerará uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_SubPropertiesDoNotAffectRender&quot;></a># # XAML texto uso membros dessa classe não são normalmente usados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool SubPropertiesDoNotAffectRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se as alterações nos valores de propriedade sub não afetam a renderização se alterada; Caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O padrão é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está lacrado e não não possível definir propriedades de metadados."
  platform:
  - net462
references:
- uid: System.Windows.UIPropertyMetadata
  isExternal: false
  name: System.Windows.UIPropertyMetadata
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
- uid: System.Windows.PropertyChangedCallback
  parent: System.Windows
  isExternal: false
  name: PropertyChangedCallback
  nameWithType: PropertyChangedCallback
  fullName: System.Windows.PropertyChangedCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
- uid: System.Windows.FrameworkPropertyMetadataOptions
  parent: System.Windows
  isExternal: false
  name: FrameworkPropertyMetadataOptions
  nameWithType: FrameworkPropertyMetadataOptions
  fullName: System.Windows.FrameworkPropertyMetadataOptions
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.CoerceValueCallback
  parent: System.Windows
  isExternal: false
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
- uid: System.Windows.Data.UpdateSourceTrigger
  parent: System.Windows.Data
  isExternal: false
  name: UpdateSourceTrigger
  nameWithType: UpdateSourceTrigger
  fullName: System.Windows.Data.UpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
- uid: System.Windows.FrameworkPropertyMetadata.#ctor*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge
  nameWithType: FrameworkPropertyMetadata.Merge
- uid: System.Windows.FrameworkPropertyMetadata.OnApply*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply
  nameWithType: FrameworkPropertyMetadata.OnApply
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
