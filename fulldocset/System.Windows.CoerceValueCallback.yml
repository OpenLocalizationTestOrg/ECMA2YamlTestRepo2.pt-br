### YamlMime:ManagedReference
items:
- uid: System.Windows.CoerceValueCallback
  id: CoerceValueCallback
  langs:
  - csharp
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
  type: Delegate
  summary: "Fornece um modelo para um método que é chamado sempre que um valor de propriedade de dependência está sendo avaliado novamente ou coerção solicitada especificamente."
  remarks: "Retornos de chamada com base em CoerceValueCallback podem ser atribuídos a uma propriedade de dependência por meio de várias técnicas diferentes. Cada uma dessas técnicas requer que você primeiro crie um novo objeto de metadados de propriedade (<xref:System.Windows.PropertyMetadata>, ou uma classe derivada como <xref:System.Windows.FrameworkPropertyMetadata>).</xref:System.Windows.FrameworkPropertyMetadata> </xref:System.Windows.PropertyMetadata> Criar o objeto de metadados usando uma assinatura de construtor que recebe o `coerceValueCallback` parâmetro e atribuir esse parâmetro para o manipulador de retorno de chamada. Ou criar os metadados por qualquer assinatura e o conjunto de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>propriedade antes de colocar os metadados em uso.</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Quando você tiver esses metadados, você pode:-definir uma nova propriedade de dependência em uma nova classe, usando qualquer uma das assinaturas de <xref:System.Windows.DependencyProperty.Register%2A>, fornecendo os metadados, como o `typeMetadata` valor.</xref:System.Windows.DependencyProperty.Register%2A>      -Substituir os metadados (chamar <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) para uma propriedade de dependência existente, quando você derivar da classe que possui a propriedade de dependência.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>      -Adicionar uma propriedade de dependência existente para uma nova <xref:System.Windows.DependencyObject>classe, usando os novos metadados, chamando <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> </xref:System.Windows.DependencyObject>       Implementações desse retorno de chamada devem verificar o valor `baseValue` e determinar com base no valor ou o tipo, se este é um valor que precisa ser forçado adicional.       O <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>de uma dependência de propriedade é invocada sempre que o sistema de propriedade ou qualquer outro chamador chama <xref:System.Windows.DependencyObject.CoerceValue%2A>em um <xref:System.Windows.DependencyObject>instância, especificando o identificador da propriedade como o `dp`.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.CoerceValue%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       As alterações para o valor da propriedade podem ter vindo de qualquer participante possíveis no sistema de propriedade. Isso inclui estilos, invalidação genérica, gatilhos, herança de valor de propriedade e configuração do valor local.       Geralmente você deve evitar a especificação de mais de um <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>para qualquer dado propriedade de dependência (substituindo ou adição de novos metadados para uma propriedade de dependência que já tinha um <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Somente um dos retornos de chamada poderá agir. O retorno de chamada de ação será aquele que foi aplicado à classe mais derivado na herança, em comparação com o <xref:System.Windows.DependencyObject>chamador.</xref:System.Windows.DependencyObject> Outras chamadas de retorno conforme são atribuídos a metadados para a propriedade de dependência que existia superior na hierarquia de proprietário são substituídas quando os metadados é substituído."
  example:
  - "The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value. In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] (not shown) to remove that dropdown from the effective choices.  \n  \n [!code-cs[DPCustom#CoerceValueCallback](~/add/codesnippet/csharp/DPCustom/default.xaml.cs#coercevaluecallback)]\n [!code-vb[DPCustom#CoerceValueCallback](~/add/codesnippet/visualbasic/dpcustom/default.xaml.vb#coercevaluecallback)]"
  syntax:
    content: public delegate object CoerceValueCallback(DependencyObject d, object baseValue);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
